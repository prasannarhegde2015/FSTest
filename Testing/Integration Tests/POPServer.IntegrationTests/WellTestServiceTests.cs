using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Reflection;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Weatherford.POP.DTOs;
using Weatherford.POP.Enums;
using Newtonsoft.Json;
using System.IO;

namespace Weatherford.POP.Server.IntegrationTests
{
    [TestClass]
    public class WellTestServiceTests : APIClientTestBase
    {
        private List<string> _modelFilesToRemove;

        [TestInitialize]
        public override void Init()
        {
            base.Init();
            _modelFilesToRemove = new List<string>();
        }

        [TestCleanup]
        public override void Cleanup()
        {
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
            base.Cleanup();
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetAnalysisInputDataAndUnitsForESPTest()
        {
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo =
             Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO()
             {
                 CalibrationMethod = CalibrationMethodId.ReservoirPressure,
                 OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR),
                                                                                                ((long)OptionalUpdates.PumpWearFactor) }
             });

            string model = modelInfo.Item1;
            WellTypeId wellType = modelInfo.Item2;
            ModelFileOptionDTO options = modelInfo.Item3;

            Trace.WriteLine("Testing model: " + model);

            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today, WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + modelInfo.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime();
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            if (wellType == WellTypeId.ESP)
            {
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = well.Id,
                    SPTCodeDescription = "AllocatableTest",
                    AverageTubingPressure = 5000,
                    AverageTubingTemperature = 65,
                    PumpIntakePressure = 10000,
                    PumpDischargePressure = 11000,
                    GaugePressure = 12000,
                    Oil = 5000,
                    Gas = 500,
                    Water = 8000,
                    ChokeSize = 50,
                    FlowLinePressure = 50,
                    SeparatorPressure = 10000,
                    Frequency = 20,
                    MotorVolts = 250,
                    MotorCurrent = 48,
                };

                testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());

                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                // Set system to US units
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");

                // -------------- Get well test data in US units --------------

                var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                Assert.IsNotNull(latestValidTestDataPair);

                Assert.AreEqual("psia", latestValidTestDataPair.Units.AverageCasingPressure.UnitKey, "Incorrect US units for well test average casing pressure:" + latestValidTestDataPair.Units.AverageCasingPressure.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.AverageCasingPressure.Precision, "Incorrect US units precision for well test average casing pressure:" + latestValidTestDataPair.Units.AverageCasingPressure.Precision.ToString());

                Assert.AreEqual("ft", latestValidTestDataPair.Units.AverageFluidAbovePump.UnitKey, "Incorrect US units for well test fluid above pump:" + latestValidTestDataPair.Units.AverageFluidAbovePump.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.AverageFluidAbovePump.Precision, "Incorrect US units precision for well test fluid above pump:" + latestValidTestDataPair.Units.AverageFluidAbovePump.Precision);

                Assert.AreEqual("psia", latestValidTestDataPair.Units.AverageTubingPressure.UnitKey, "Incorrect US units for well test average tubing pressure:" + latestValidTestDataPair.Units.AverageTubingPressure.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.AverageTubingPressure.Precision, "Incorrect US units precision for well test average tubing pressure:" + latestValidTestDataPair.Units.AverageTubingPressure.Precision);

                Assert.AreEqual("F", latestValidTestDataPair.Units.AverageTubingTemperature.UnitKey, "Incorrect US units for well test average tubing temperature:" + latestValidTestDataPair.Units.AverageTubingTemperature.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPair.Units.AverageTubingTemperature.Precision, "Incorrect US units precision for well test average tubing temperature:" + latestValidTestDataPair.Units.AverageTubingTemperature.Precision);

                Assert.AreEqual("1/64in", latestValidTestDataPair.Units.ChokeSize.UnitKey, "Incorrect US units for well test choke size:" + latestValidTestDataPair.Units.ChokeSize.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPair.Units.ChokeSize.Precision, "Incorrect US units precision for well test choke size:" + latestValidTestDataPair.Units.ChokeSize.Precision);

                Assert.AreEqual("psia", latestValidTestDataPair.Units.FlowLinePressure.UnitKey, "Incorrect US units for well test flow line pressure:" + latestValidTestDataPair.Units.FlowLinePressure.UnitKey);
                Assert.AreEqual("psia", latestValidTestDataPair.Units.FlowingBottomholePressure.UnitKey, "Incorrect US units for well test flowing bottom hole pressure:" + latestValidTestDataPair.Units.FlowingBottomholePressure.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.FlowLinePressure.Precision, "Incorrect US units precsion for well test flow line pressure:" + latestValidTestDataPair.Units.FlowLinePressure.Precision);

                Assert.AreEqual("Hz", latestValidTestDataPair.Units.Frequency.UnitKey, "Incorrect US units for well test frequency:" + latestValidTestDataPair.Units.Frequency.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.Frequency.Precision, "Incorrect US units precision for well test frequency:" + latestValidTestDataPair.Units.Frequency.Precision);

                Assert.AreEqual("scf/STB", latestValidTestDataPair.Units.GOR.UnitKey, "Incorrect US units for well test GOR:" + latestValidTestDataPair.Units.GOR.UnitKey);

                Assert.AreEqual("Mscf/d", latestValidTestDataPair.Units.Gas.UnitKey, "Incorrect US units for well test gas rate:" + latestValidTestDataPair.Units.Gas.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.Gas.Precision, "Incorrect US units precision for well test gas rate:" + latestValidTestDataPair.Units.Gas.Precision);

                Assert.AreEqual("SG", latestValidTestDataPair.Units.GasGravity.UnitKey, "Incorrect US units for well test gas gravity:" + latestValidTestDataPair.Units.GasGravity.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPair.Units.GasGravity.Precision, "Incorrect US units precision for well test gas gravity:" + latestValidTestDataPair.Units.GasGravity.Precision);

                Assert.AreEqual("Mscf/d", latestValidTestDataPair.Units.GasInjectionRate.UnitKey, "Incorrect US units for well test gas injection rate:" + latestValidTestDataPair.Units.GasInjectionRate.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.GasInjectionRate.Precision, "Incorrect US units precision for well test gas injection rate:" + latestValidTestDataPair.Units.GasInjectionRate.Precision);

                Assert.AreEqual("psia", latestValidTestDataPair.Units.GaugePressure.UnitKey, "Incorrect US units for well test gauge pressure:" + latestValidTestDataPair.Units.GaugePressure.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.GaugePressure.Precision, "Incorrect US units precision for well test gauge pressure:" + latestValidTestDataPair.Units.GaugePressure.Precision);

                Assert.AreEqual("scf/STB", latestValidTestDataPair.Units.InjectionGLR.UnitKey, "Incorrect US units for well test injection GLR:" + latestValidTestDataPair.Units.InjectionGLR.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPair.Units.InjectionGLR.Precision, "Incorrect US units precision for well test injection GLR:" + latestValidTestDataPair.Units.InjectionGLR.Precision);

                Assert.AreEqual("STB/d/psi", latestValidTestDataPair.Units.InjectivityIndex.UnitKey, "Incorrect US units for well test injectiviy index:" + latestValidTestDataPair.Units.InjectivityIndex.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPair.Units.InjectivityIndex.Precision, "Incorrect US units precision for well test injectiviy index:" + latestValidTestDataPair.Units.InjectivityIndex.Precision);

                Assert.AreEqual("A", latestValidTestDataPair.Units.MotorCurrent.UnitKey, "Incorrect US units for well test motor current:" + latestValidTestDataPair.Units.MotorCurrent.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.MotorCurrent.Precision, "Incorrect US units precision for well test motor current:" + latestValidTestDataPair.Units.MotorCurrent.Precision);

                Assert.AreEqual("V", latestValidTestDataPair.Units.MotorVolts.UnitKey, "Incorrect US units for well test motor volts:" + latestValidTestDataPair.Units.MotorVolts.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.MotorVolts.Precision, "Incorrect US units precision for well test motor volts:" + latestValidTestDataPair.Units.MotorVolts.Precision);

                Assert.AreEqual("STB/d", latestValidTestDataPair.Units.Oil.UnitKey, "Incorrect US units for well test oil rate:" + latestValidTestDataPair.Units.Oil.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPair.Units.Oil.Precision, "Incorrect US units precision for well test oil rate:" + latestValidTestDataPair.Units.Oil.Precision);

                Assert.AreEqual("APIG", latestValidTestDataPair.Units.OilGravity.UnitKey, "Incorrect US units for well test oil gravity:" + latestValidTestDataPair.Units.OilGravity.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPair.Units.OilGravity.Precision, "Incorrect US units for well test oil gravity:" + latestValidTestDataPair.Units.OilGravity.UnitKey);

                Assert.AreEqual("1/64in", latestValidTestDataPair.Units.OrificeSize.UnitKey, "Incorrect US units for well test orifice size:" + latestValidTestDataPair.Units.OrificeSize.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPair.Units.OrificeSize.Precision, "Incorrect US units precision for well test orifice size:" + latestValidTestDataPair.Units.OrificeSize.Precision);

                Assert.AreEqual("STB/d/psi", latestValidTestDataPair.Units.ProductivityIndex.UnitKey, "Incorrect US units for well test productivity index:" + latestValidTestDataPair.Units.ProductivityIndex.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPair.Units.ProductivityIndex.Precision, "Incorrect US units precision for well test productivity index:" + latestValidTestDataPair.Units.ProductivityIndex.Precision);

                Assert.AreEqual("psia", latestValidTestDataPair.Units.PumpDischargePressure.UnitKey, "Incorrect US units for well test pump discharge pressure:" + latestValidTestDataPair.Units.PumpDischargePressure.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.PumpDischargePressure.Precision, "Incorrect US units precision for well test pump discharge pressure:" + latestValidTestDataPair.Units.PumpDischargePressure.Precision);

                Assert.AreEqual("%", latestValidTestDataPair.Units.PumpEfficiency.UnitKey, "Incorrect US units for well test pump efficiency:" + latestValidTestDataPair.Units.PumpEfficiency.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.PumpEfficiency.Precision, "Incorrect US units precision for well test pump efficiency:" + latestValidTestDataPair.Units.PumpEfficiency.Precision);

                Assert.AreEqual("psia", latestValidTestDataPair.Units.PumpIntakePressure.UnitKey, "Incorrect US units for well test pump intake pressure:" + latestValidTestDataPair.Units.PumpIntakePressure.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.PumpIntakePressure.Precision, "Incorrect US units precision for well test pump intake pressure:" + latestValidTestDataPair.Units.PumpIntakePressure.Precision);

                Assert.AreEqual("fraction", latestValidTestDataPair.Units.PumpWearFactor.UnitKey, "Incorrect US units for well test pump wear factor:" + latestValidTestDataPair.Units.PumpWearFactor.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPair.Units.PumpWearFactor.Precision, "Incorrect US units precision for well test pump wear factor:" + latestValidTestDataPair.Units.PumpWearFactor.Precision);

                Assert.AreEqual("psia", latestValidTestDataPair.Units.ReservoirPressure.UnitKey, "Incorrect US units for well test reservoir pressure:" + latestValidTestDataPair.Units.ReservoirPressure.UnitKey);

                Assert.AreEqual("psia", latestValidTestDataPair.Units.SeparatorPressure.UnitKey, "Incorrect US units for well test separator pressurer:" + latestValidTestDataPair.Units.SeparatorPressure.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.SeparatorPressure.Precision, "Incorrect US units precision for well test separator pressurer:" + latestValidTestDataPair.Units.SeparatorPressure.Precision);

                Assert.AreEqual("STB/d", latestValidTestDataPair.Units.TotalFluid.UnitKey, "Incorrect US units for well test total fluid:" + latestValidTestDataPair.Units.TotalFluid.UnitKey);

                Assert.AreEqual("SPM", latestValidTestDataPair.Units.StrokePerMinute.UnitKey, "Incorrect US units for well test SPM:" + latestValidTestDataPair.Units.StrokePerMinute.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPair.Units.StrokePerMinute.Precision, "Incorrect US units for well test SPM:" + latestValidTestDataPair.Units.StrokePerMinute.Precision);

                Assert.AreEqual("Mscf/d", latestValidTestDataPair.Units.TotalGasRate.UnitKey, "Incorrect US units for well test total gas rate:" + latestValidTestDataPair.Units.TotalGasRate.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPair.Units.TotalGasRate.Precision, "Incorrect US units precision for well test total gas rate:" + latestValidTestDataPair.Units.TotalGasRate.Precision);

                Assert.AreEqual("STB/d", latestValidTestDataPair.Units.Water.UnitKey, "Incorrect US units for well test water rate:" + latestValidTestDataPair.Units.Water.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPair.Units.Water.Precision, "Incorrect US units precision for well test water rate:" + latestValidTestDataPair.Units.Water.Precision);

                Assert.AreEqual("fraction", latestValidTestDataPair.Units.WaterCut.UnitKey, "Incorrect US units for well test water cut:" + latestValidTestDataPair.Units.WaterCut.UnitKey);

                Assert.AreEqual("SG", latestValidTestDataPair.Units.WaterGravity.UnitKey, "Incorrect US units for well test water gravity:" + latestValidTestDataPair.Units.WaterGravity.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPair.Units.WaterGravity.Precision, "Incorrect US units precision for well test water gravity:" + latestValidTestDataPair.Units.WaterGravity.Precision);

                // -------------- Get analysis inputs in US units --------------

                var analysisInput_US = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                Assert.AreEqual("A", analysisInput_US.ModelData.ESPData.Units.MotorAmps.UnitKey, "Incorrect US units for motor amps:" + analysisInput_US.ModelData.ESPData.Units.MotorAmps.UnitKey);
                Assert.AreEqual(2, (int)analysisInput_US.ModelData.ESPData.Units.MotorAmps.Precision, "Incorrect US units precision for motor amps:" + analysisInput_US.ModelData.ESPData.Units.MotorAmps.Precision);

                Assert.AreEqual("V", analysisInput_US.ModelData.ESPData.Units.MotorVolts.UnitKey, "Incorrect US units for motor volts:" + analysisInput_US.ModelData.ESPData.Units.MotorVolts.UnitKey);
                Assert.AreEqual(2, (int)analysisInput_US.ModelData.ESPData.Units.MotorVolts.Precision, "Incorrect US units precision for motor volts:" + analysisInput_US.ModelData.ESPData.Units.MotorVolts.Precision);

                Assert.AreEqual("Hz", analysisInput_US.ModelData.ESPData.Units.OperatingFrequency.UnitKey, "Incorrect US units for operating frequency:" + analysisInput_US.ModelData.ESPData.Units.OperatingFrequency.UnitKey);
                Assert.AreEqual(2, (int)analysisInput_US.ModelData.ESPData.Units.OperatingFrequency.Precision, "Incorrect US units precision for operating frequency:" + analysisInput_US.ModelData.ESPData.Units.OperatingFrequency.Precision);

                Assert.AreEqual("ft", analysisInput_US.ModelData.ESPData.Units.PumpDepth.UnitKey, "Incorrect US units for pump depth:" + analysisInput_US.ModelData.ESPData.Units.PumpDepth.UnitKey);
                Assert.AreEqual(2, (int)analysisInput_US.ModelData.ESPData.Units.PumpDepth.Precision, "Incorrect US units precision for pump depth:" + analysisInput_US.ModelData.ESPData.Units.PumpDepth.Precision);

                Assert.AreEqual("psia", analysisInput_US.ModelData.ESPData.Units.PumpDischargePressure.UnitKey, "Incorrect US units for pump discharge pressure:" + analysisInput_US.ModelData.ESPData.Units.PumpDischargePressure.UnitKey);
                Assert.AreEqual(2, (int)analysisInput_US.ModelData.ESPData.Units.PumpDischargePressure.Precision, "Incorrect US units precision for pump discharge pressure:" + analysisInput_US.ModelData.ESPData.Units.PumpDischargePressure.Precision);

                Assert.AreEqual("psia", analysisInput_US.ModelData.ESPData.Units.PumpIntakePressure.UnitKey, "Incorrect US units for pump intake pressure:" + analysisInput_US.ModelData.ESPData.Units.PumpIntakePressure.UnitKey);
                Assert.AreEqual(2, (int)analysisInput_US.ModelData.ESPData.Units.PumpIntakePressure.Precision, "Incorrect US units precision for pump intake pressure:" + analysisInput_US.ModelData.ESPData.Units.PumpIntakePressure.Precision);

                // Set system to metric units
                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");

                // -------------- Get well test data in metric units --------------

                var latestValidTestDataPairMetric = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                Assert.IsNotNull(latestValidTestDataPairMetric);

                Assert.AreEqual("kPa", latestValidTestDataPairMetric.Units.AverageCasingPressure.UnitKey, "Incorrect metric units for well test average casing pressure:" + latestValidTestDataPairMetric.Units.AverageCasingPressure.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPairMetric.Units.AverageCasingPressure.Precision, "Incorrect metric units precision for well test average casing pressure:" + latestValidTestDataPairMetric.Units.AverageCasingPressure.Precision.ToString());

                Assert.AreEqual("m", latestValidTestDataPairMetric.Units.AverageFluidAbovePump.UnitKey, "Incorrect metric units for well test fluid above pump:" + latestValidTestDataPairMetric.Units.AverageFluidAbovePump.UnitKey);
                Assert.AreEqual(3, (int)latestValidTestDataPairMetric.Units.AverageFluidAbovePump.Precision, "Incorrect metric units precision for well test fluid above pump:" + latestValidTestDataPairMetric.Units.AverageFluidAbovePump.Precision);

                Assert.AreEqual("kPa", latestValidTestDataPairMetric.Units.AverageTubingPressure.UnitKey, "Incorrect metric units for well test average tubing pressure:" + latestValidTestDataPairMetric.Units.AverageTubingPressure.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPairMetric.Units.AverageTubingPressure.Precision, "Incorrect metric units precision for well test average tubing pressure:" + latestValidTestDataPairMetric.Units.AverageTubingPressure.Precision);

                Assert.AreEqual("C", latestValidTestDataPairMetric.Units.AverageTubingTemperature.UnitKey, "Incorrect metric units for well test average tubing temperature:" + latestValidTestDataPairMetric.Units.AverageTubingTemperature.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPairMetric.Units.AverageTubingTemperature.Precision, "Incorrect metric units precision for well test average tubing temperature:" + latestValidTestDataPairMetric.Units.AverageTubingTemperature.Precision);

                Assert.AreEqual("mm", latestValidTestDataPairMetric.Units.ChokeSize.UnitKey, "Incorrect metric units for well test choke size:" + latestValidTestDataPairMetric.Units.ChokeSize.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPairMetric.Units.ChokeSize.Precision, "Incorrect metric units precision for well test choke size:" + latestValidTestDataPairMetric.Units.ChokeSize.Precision);

                Assert.AreEqual("kPa", latestValidTestDataPairMetric.Units.FlowLinePressure.UnitKey, "Incorrect metric units for well test flow line pressure:" + latestValidTestDataPairMetric.Units.FlowLinePressure.UnitKey);
                Assert.AreEqual("kPa", latestValidTestDataPairMetric.Units.FlowingBottomholePressure.UnitKey, "Incorrect metric units for well test flowing bottom hole pressure:" + latestValidTestDataPairMetric.Units.FlowingBottomholePressure.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPairMetric.Units.FlowLinePressure.Precision, "Incorrect metric units precsion for well test flow line pressure:" + latestValidTestDataPairMetric.Units.FlowLinePressure.Precision);

                Assert.AreEqual("Hz", latestValidTestDataPairMetric.Units.Frequency.UnitKey, "Incorrect metric units for well test frequency:" + latestValidTestDataPairMetric.Units.Frequency.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPairMetric.Units.Frequency.Precision, "Incorrect metric units precision for well test frequency:" + latestValidTestDataPairMetric.Units.Frequency.Precision);

                Assert.AreEqual("sm3/sm3", latestValidTestDataPairMetric.Units.GOR.UnitKey, "Incorrect metric units for well test GOR:" + latestValidTestDataPairMetric.Units.GOR.UnitKey);

                Assert.AreEqual("sm3/d", latestValidTestDataPairMetric.Units.Gas.UnitKey, "Incorrect metric units for well test gas rate:" + latestValidTestDataPairMetric.Units.Gas.UnitKey);
                Assert.AreEqual(3, (int)latestValidTestDataPairMetric.Units.Gas.Precision, "Incorrect metric units precision for well test gas rate:" + latestValidTestDataPairMetric.Units.Gas.Precision);

                Assert.AreEqual("SG", latestValidTestDataPairMetric.Units.GasGravity.UnitKey, "Incorrect metric units for well test gas gravity:" + latestValidTestDataPairMetric.Units.GasGravity.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPairMetric.Units.GasGravity.Precision, "Incorrect metric units precision for well test gas gravity:" + latestValidTestDataPairMetric.Units.GasGravity.Precision);

                Assert.AreEqual("sm3/d", latestValidTestDataPairMetric.Units.GasInjectionRate.UnitKey, "Incorrect metric units for well test gas injection rate:" + latestValidTestDataPairMetric.Units.GasInjectionRate.UnitKey);
                Assert.AreEqual(3, (int)latestValidTestDataPairMetric.Units.GasInjectionRate.Precision, "Incorrect metric units precision for well test gas injection rate:" + latestValidTestDataPairMetric.Units.GasInjectionRate.Precision);

                Assert.AreEqual("kPa", latestValidTestDataPairMetric.Units.GaugePressure.UnitKey, "Incorrect metric units for well test gauge pressure:" + latestValidTestDataPairMetric.Units.GaugePressure.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPairMetric.Units.GaugePressure.Precision, "Incorrect metric units precision for well test gauge pressure:" + latestValidTestDataPairMetric.Units.GaugePressure.Precision);

                Assert.AreEqual("sm3/sm3", latestValidTestDataPairMetric.Units.InjectionGLR.UnitKey, "Incorrect metric units for well test injection GLR:" + latestValidTestDataPairMetric.Units.InjectionGLR.UnitKey);
                Assert.AreEqual(5, (int)latestValidTestDataPairMetric.Units.InjectionGLR.Precision, "Incorrect metric units precision for well test injection GLR:" + latestValidTestDataPairMetric.Units.InjectionGLR.Precision);

                Assert.AreEqual("sm3/d/kPa", latestValidTestDataPairMetric.Units.InjectivityIndex.UnitKey, "Incorrect metric units for well test injectiviy index:" + latestValidTestDataPairMetric.Units.InjectivityIndex.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPairMetric.Units.InjectivityIndex.Precision, "Incorrect metric units for well test injectiviy index:" + latestValidTestDataPairMetric.Units.InjectivityIndex.Precision);

                Assert.AreEqual("A", latestValidTestDataPairMetric.Units.MotorCurrent.UnitKey, "Incorrect metric units for well test motor current:" + latestValidTestDataPairMetric.Units.MotorCurrent.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPairMetric.Units.MotorCurrent.Precision, "Incorrect metric units precision for well test motor current:" + latestValidTestDataPairMetric.Units.MotorCurrent.Precision);

                Assert.AreEqual("V", latestValidTestDataPairMetric.Units.MotorVolts.UnitKey, "Incorrect metric units for well test motor volts:" + latestValidTestDataPairMetric.Units.MotorVolts.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPairMetric.Units.MotorVolts.Precision, "Incorrect metric units precision for well test motor volts:" + latestValidTestDataPairMetric.Units.MotorVolts.Precision);

                Assert.AreEqual("sm3/d", latestValidTestDataPairMetric.Units.Oil.UnitKey, "Incorrect metric units for well test oil rate:" + latestValidTestDataPairMetric.Units.Oil.UnitKey);
                Assert.AreEqual(3, (int)latestValidTestDataPairMetric.Units.Oil.Precision, "Incorrect metric units precision for well test oil rate:" + latestValidTestDataPairMetric.Units.Oil.Precision);

                Assert.AreEqual("SG", latestValidTestDataPairMetric.Units.OilGravity.UnitKey, "Incorrect metric units for well test oil gravity:" + latestValidTestDataPairMetric.Units.OilGravity.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPairMetric.Units.OilGravity.Precision, "Incorrect metric units precision for well test oil gravity:" + latestValidTestDataPairMetric.Units.OilGravity.Precision);

                Assert.AreEqual("mm", latestValidTestDataPairMetric.Units.OrificeSize.UnitKey, "Incorrect metric units for well test orifice size:" + latestValidTestDataPairMetric.Units.OrificeSize.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPairMetric.Units.OrificeSize.Precision, "Incorrect metric units precision for well test orifice size:" + latestValidTestDataPairMetric.Units.OrificeSize.Precision);

                Assert.AreEqual("sm3/d/kPa", latestValidTestDataPairMetric.Units.ProductivityIndex.UnitKey, "Incorrect metric units for well test productivity index:" + latestValidTestDataPairMetric.Units.ProductivityIndex.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPairMetric.Units.ProductivityIndex.Precision, "Incorrect metric units precision for well test productivity index:" + latestValidTestDataPairMetric.Units.ProductivityIndex.Precision);

                Assert.AreEqual("kPa", latestValidTestDataPairMetric.Units.PumpDischargePressure.UnitKey, "Incorrect metric units for well test pump discharge pressure:" + latestValidTestDataPairMetric.Units.PumpDischargePressure.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPairMetric.Units.PumpDischargePressure.Precision, "Incorrect metric units precision for well test pump discharge pressure:" + latestValidTestDataPairMetric.Units.PumpDischargePressure.Precision);

                Assert.AreEqual("%", latestValidTestDataPairMetric.Units.PumpEfficiency.UnitKey, "Incorrect metric units for well test pump efficiency:" + latestValidTestDataPairMetric.Units.PumpEfficiency.UnitKey);
                Assert.AreEqual(2, (int)latestValidTestDataPairMetric.Units.PumpEfficiency.Precision, "Incorrect metric units precision for well test pump efficiency:" + latestValidTestDataPairMetric.Units.PumpEfficiency.Precision);

                Assert.AreEqual("kPa", latestValidTestDataPairMetric.Units.PumpIntakePressure.UnitKey, "Incorrect metric units for well test pump intake pressure:" + latestValidTestDataPairMetric.Units.PumpIntakePressure.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPairMetric.Units.PumpIntakePressure.Precision, "Incorrect metric units precision for well test pump intake pressure:" + latestValidTestDataPairMetric.Units.PumpIntakePressure.Precision);

                Assert.AreEqual("fraction", latestValidTestDataPairMetric.Units.PumpWearFactor.UnitKey, "Incorrect metric units for well test pump wear factor:" + latestValidTestDataPairMetric.Units.PumpWearFactor.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPairMetric.Units.PumpWearFactor.Precision, "Incorrect metric units precision for well test pump wear factor:" + latestValidTestDataPairMetric.Units.PumpWearFactor.Precision);

                Assert.AreEqual("kPa", latestValidTestDataPairMetric.Units.ReservoirPressure.UnitKey, "Incorrect metric units for well test reservoir pressure:" + latestValidTestDataPairMetric.Units.ReservoirPressure.UnitKey);

                Assert.AreEqual("kPa", latestValidTestDataPairMetric.Units.SeparatorPressure.UnitKey, "Incorrect metric units for well test separator pressurer:" + latestValidTestDataPairMetric.Units.SeparatorPressure.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPairMetric.Units.SeparatorPressure.Precision, "Incorrect metric units precision for well test separator pressurer:" + latestValidTestDataPairMetric.Units.SeparatorPressure.Precision);

                Assert.AreEqual("SPM", latestValidTestDataPairMetric.Units.StrokePerMinute.UnitKey, "Incorrect metric units for well test SPM:" + latestValidTestDataPairMetric.Units.StrokePerMinute.UnitKey);
                Assert.AreEqual(1, (int)latestValidTestDataPairMetric.Units.StrokePerMinute.Precision, "Incorrect metric units for well test SPM:" + latestValidTestDataPairMetric.Units.StrokePerMinute.Precision);

                Assert.AreEqual("sm3/d", latestValidTestDataPairMetric.Units.TotalFluid.UnitKey, "Incorrect metric units for well test total fluid:" + latestValidTestDataPairMetric.Units.TotalFluid.UnitKey);

                Assert.AreEqual("sm3/d", latestValidTestDataPairMetric.Units.TotalGasRate.UnitKey, "Incorrect metric units for well test total gas rate:" + latestValidTestDataPairMetric.Units.TotalGasRate.UnitKey);
                Assert.AreEqual(3, (int)latestValidTestDataPairMetric.Units.TotalGasRate.Precision, "Incorrect metric units precision for well test total gas rate:" + latestValidTestDataPairMetric.Units.TotalGasRate.Precision);

                Assert.AreEqual("sm3/d", latestValidTestDataPairMetric.Units.Water.UnitKey, "Incorrect metric units for well test water rate:" + latestValidTestDataPairMetric.Units.Water.UnitKey);
                Assert.AreEqual(3, (int)latestValidTestDataPairMetric.Units.Water.Precision, "Incorrect metric units precision for well test water rate:" + latestValidTestDataPairMetric.Units.Water.Precision);

                Assert.AreEqual("fraction", latestValidTestDataPairMetric.Units.WaterCut.UnitKey, "Incorrect metric units for well test water cut:" + latestValidTestDataPairMetric.Units.WaterCut.UnitKey);

                Assert.AreEqual("SG", latestValidTestDataPairMetric.Units.WaterGravity.UnitKey, "Incorrect metric units for well test water gravity:" + latestValidTestDataPairMetric.Units.WaterGravity.UnitKey);
                Assert.AreEqual(4, (int)latestValidTestDataPairMetric.Units.WaterGravity.Precision, "Incorrect metric units precision for well test water gravity:" + latestValidTestDataPairMetric.Units.WaterGravity.Precision);

                // ------------ Get metric analysis inputs ------------

                var analysisInput_Metric = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                Assert.AreEqual("A", analysisInput_Metric.ModelData.ESPData.Units.MotorAmps.UnitKey, "Incorrect metric units for motor amps:" + analysisInput_Metric.ModelData.ESPData.Units.MotorAmps.UnitKey);
                Assert.AreEqual(2, (int)analysisInput_Metric.ModelData.ESPData.Units.MotorAmps.Precision, "Incorrect metric units precision for motor amps:" + analysisInput_Metric.ModelData.ESPData.Units.MotorAmps.Precision);

                Assert.AreEqual("V", analysisInput_Metric.ModelData.ESPData.Units.MotorVolts.UnitKey, "Incorrect metric units for motor volts:" + analysisInput_Metric.ModelData.ESPData.Units.MotorVolts.UnitKey);
                Assert.AreEqual(2, (int)analysisInput_Metric.ModelData.ESPData.Units.MotorVolts.Precision, "Incorrect metric units precision for motor volts:" + analysisInput_Metric.ModelData.ESPData.Units.MotorVolts.Precision);

                Assert.AreEqual("Hz", analysisInput_Metric.ModelData.ESPData.Units.OperatingFrequency.UnitKey, "Incorrect metric units for operating frequency:" + analysisInput_Metric.ModelData.ESPData.Units.OperatingFrequency.UnitKey);
                Assert.AreEqual(2, (int)analysisInput_Metric.ModelData.ESPData.Units.OperatingFrequency.Precision, "Incorrect metric units precision for operating frequency:" + analysisInput_Metric.ModelData.ESPData.Units.OperatingFrequency.Precision);

                Assert.AreEqual("m", analysisInput_Metric.ModelData.ESPData.Units.PumpDepth.UnitKey, "Incorrect metric units for pump depth:" + analysisInput_Metric.ModelData.ESPData.Units.PumpDepth.UnitKey);
                Assert.AreEqual(3, (int)analysisInput_Metric.ModelData.ESPData.Units.PumpDepth.Precision, "Incorrect metric units precision for pump depth:" + analysisInput_Metric.ModelData.ESPData.Units.PumpDepth.Precision);

                Assert.AreEqual("kPa", analysisInput_Metric.ModelData.ESPData.Units.PumpDischargePressure.UnitKey, "Incorrect metric units for pump discharge pressure:" + analysisInput_Metric.ModelData.ESPData.Units.PumpDischargePressure.UnitKey);
                Assert.AreEqual(1, (int)analysisInput_Metric.ModelData.ESPData.Units.PumpDischargePressure.Precision, "Incorrect metric units precision for pump discharge pressure:" + analysisInput_Metric.ModelData.ESPData.Units.PumpDischargePressure.Precision);

                Assert.AreEqual("kPa", analysisInput_Metric.ModelData.ESPData.Units.PumpIntakePressure.UnitKey, "Incorrect metric units for pump intake pressure:" + analysisInput_Metric.ModelData.ESPData.Units.PumpIntakePressure.UnitKey);
                Assert.AreEqual(1, (int)analysisInput_Metric.ModelData.ESPData.Units.PumpIntakePressure.Precision, "Incorrect metric units precision for pump intake pressure:" + analysisInput_Metric.ModelData.ESPData.Units.PumpIntakePressure.Precision);

                // --------- Cross convert well test data using the conversion factors in UnitInformation.xml -----------

                if (latestValidTestDataPair.Units.AverageCasingPressure.Min != null)
                {
                    // US to metric - minumum
                    Assert.AreEqual((double)latestValidTestDataPair.Units.AverageCasingPressure.Min * 6.894757, (double)latestValidTestDataPairMetric.Units.AverageCasingPressure.Min, 0.1, "Incorrect min average casing pressure conversion from US to metric");
                    // metric to US - minumum
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.AverageCasingPressure.Min / 6.894757, (double)latestValidTestDataPair.Units.AverageCasingPressure.Min, 0.1, "Incorrect min average casing pressure conversion from metric to US");

                    // US to metric - maxumum
                    Assert.AreEqual((double)latestValidTestDataPair.Units.AverageCasingPressure.Max * 6.894757, (double)latestValidTestDataPairMetric.Units.AverageCasingPressure.Max, 0.1, "Incorrect max average casing pressure conversion from US to metric");
                    // metric to US - maxumum
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.AverageCasingPressure.Max / 6.894757, (double)latestValidTestDataPair.Units.AverageCasingPressure.Max, 0.1, "Incorrect max average casing pressure conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.AverageFluidAbovePump.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.AverageFluidAbovePump.Min * 0.3048, (double)latestValidTestDataPairMetric.Units.AverageFluidAbovePump.Min, 0.1, "Incorrect max average fluid above pump conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.AverageFluidAbovePump.Min / 0.3048, (double)latestValidTestDataPair.Units.AverageFluidAbovePump.Min, 0.1, "Incorrect max average fluid above pump conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.AverageFluidAbovePump.Max * 0.3048, (double)latestValidTestDataPairMetric.Units.AverageFluidAbovePump.Max, 0.1, "Incorrect max average fluid above pump conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.AverageFluidAbovePump.Max / 0.3048, (double)latestValidTestDataPair.Units.AverageFluidAbovePump.Max, 0.1, "Incorrect max average fluid above pump conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.AverageTubingPressure.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.AverageTubingPressure.Min * 6.894757, (double)latestValidTestDataPairMetric.Units.AverageTubingPressure.Min, "Incorrect max average tubing pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.AverageTubingPressure.Min / 6.894757, (double)latestValidTestDataPair.Units.AverageTubingPressure.Min, "Incorrect max average tubing pressure conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.AverageTubingPressure.Max * 6.894757, (double)latestValidTestDataPairMetric.Units.AverageTubingPressure.Max, "Incorrect max average tubing pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.AverageTubingPressure.Max / 6.894757, (double)latestValidTestDataPair.Units.AverageTubingPressure.Max, 0.1, "Incorrect max average tubing pressure conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.AverageTubingTemperature.Min != null)
                {
                    Assert.AreEqual(((double)latestValidTestDataPair.Units.AverageTubingTemperature.Min - 32) * 0.55555555555555555555555555555556, (double)latestValidTestDataPairMetric.Units.AverageTubingTemperature.Min, 0.1, "Incorrect min average tubing temperature conversion from US to metric");
                    Assert.AreEqual(((double)latestValidTestDataPairMetric.Units.AverageTubingTemperature.Min * (1.0 / 0.55555555555555555555555555555556) + 32), (double)latestValidTestDataPair.Units.AverageTubingTemperature.Min, 0.1, "Incorrect min average tubing temperature conversion from metric to US");
                    Assert.AreEqual(((double)latestValidTestDataPair.Units.AverageTubingTemperature.Max - 32) * 0.55555555555555555555555555555556, (double)latestValidTestDataPairMetric.Units.AverageTubingTemperature.Max, 0.1, "Incorrect max average tubing temperature conversion from US to metric");
                    Assert.AreEqual(((double)latestValidTestDataPairMetric.Units.AverageTubingTemperature.Max * (1.0 / 0.55555555555555555555555555555556) + 32), (double)latestValidTestDataPair.Units.AverageTubingTemperature.Max, 0.1, "Incorrect max average tubing temperature conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.ChokeSize.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.ChokeSize.Min * 0.396875, (double)latestValidTestDataPairMetric.Units.ChokeSize.Min, 0.1, "Incorrect min choke size conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.ChokeSize.Min / 0.396875, (double)latestValidTestDataPair.Units.ChokeSize.Min, 0.1, "Incorrect min choke size conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.ChokeSize.Max * 0.396875, (double)latestValidTestDataPairMetric.Units.ChokeSize.Max, 0.1, "Incorrect max choke size conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.ChokeSize.Max / 0.396875, (double)latestValidTestDataPair.Units.ChokeSize.Max, 0.1, "Incorrect max choke size conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.FlowLinePressure.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.FlowLinePressure.Min * 6.894757, (double)latestValidTestDataPairMetric.Units.FlowLinePressure.Min, 0.1, "Incorrect min flow line pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.FlowLinePressure.Min / 6.894757, (double)latestValidTestDataPair.Units.FlowLinePressure.Min, 0.1, "Incorrect min flow line pressure conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.FlowLinePressure.Max * 6.894757, (double)latestValidTestDataPairMetric.Units.FlowLinePressure.Max, 0.1, "Incorrect max flow line pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.FlowLinePressure.Max / 6.894757, (double)latestValidTestDataPair.Units.FlowLinePressure.Max, 0.1, "Incorrect max flow line pressure conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.Gas.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.Gas.Min * 28.3168466, (double)latestValidTestDataPairMetric.Units.Gas.Min, 0.1, "Incorrect min gas rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.Gas.Min / 28.3168466, (double)latestValidTestDataPair.Units.Gas.Min, 0.1, "Incorrect min gas rate conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.Gas.Max * 28.3168466, (double)latestValidTestDataPairMetric.Units.Gas.Max, 0.1, "Incorrect max gas rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.Gas.Max / 28.3168466, (double)latestValidTestDataPair.Units.Gas.Max, 0.1, "Incorrect max gas rate conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.GasInjectionRate.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.GasInjectionRate.Min * 28.3168466, (double)latestValidTestDataPairMetric.Units.GasInjectionRate.Min, 0.1, "Incorrect min gas injection rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.GasInjectionRate.Min / 28.3168466, (double)latestValidTestDataPair.Units.GasInjectionRate.Min, 0.1, "Incorrect min gas injection rate conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.GasInjectionRate.Max * 28.3168466, (double)latestValidTestDataPairMetric.Units.GasInjectionRate.Max, 0.1, "Incorrect max gas injection rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.GasInjectionRate.Max / 28.3168466, (double)latestValidTestDataPair.Units.GasInjectionRate.Max, 0.1, "Incorrect max gas injection rate conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.GaugePressure.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.GaugePressure.Min * 6.894757, (double)latestValidTestDataPairMetric.Units.GaugePressure.Min, 0.1, "Incorrect min gauge pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.GaugePressure.Min / 6.894757, (double)latestValidTestDataPair.Units.GaugePressure.Min, 0.1, "Incorrect min gauge pressure conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.GaugePressure.Max * 6.894757, (double)latestValidTestDataPairMetric.Units.GaugePressure.Max, 0.1, "Incorrect max gauge pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.GaugePressure.Max / 6.894757, (double)latestValidTestDataPair.Units.GaugePressure.Max, 0.1, "Incorrect max gauge pressure conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.Oil.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.Oil.Min * 0.1589873, (double)latestValidTestDataPairMetric.Units.Oil.Min, 0.1, "Incorrect min oil rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.Oil.Min / 0.1589873, (double)latestValidTestDataPair.Units.Oil.Min, 0.1, "Incorrect min oil rate conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.Oil.Max * 0.1589873, (double)latestValidTestDataPairMetric.Units.Oil.Max, 0.1, "Incorrect max oil rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.Oil.Max / 0.1589873, (double)latestValidTestDataPair.Units.Oil.Max, 0.1, "Incorrect max oil rateconversion from metric to US");
                }

                if (latestValidTestDataPair.Units.PumpDischargePressure.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.PumpDischargePressure.Min * 6.894757, (double)latestValidTestDataPairMetric.Units.PumpDischargePressure.Min, 0.1, "Incorrect min Pump Discharge Pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.PumpDischargePressure.Min / 6.894757, (double)latestValidTestDataPair.Units.PumpDischargePressure.Min, 0.1, "Incorrect min Pump Discharge Pressure conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.PumpDischargePressure.Max * 6.894757, (double)latestValidTestDataPairMetric.Units.PumpDischargePressure.Max, 0.1, "Incorrect max Pump Discharge Pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.PumpDischargePressure.Max / 6.894757, (double)latestValidTestDataPair.Units.PumpDischargePressure.Max, 0.1, "Incorrect max Pump Discharge Pressure conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.PumpIntakePressure.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.PumpIntakePressure.Min * 6.894757, (double)latestValidTestDataPairMetric.Units.PumpIntakePressure.Min, 0.1, "Incorrect min Pump Intake Pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.PumpIntakePressure.Min / 6.894757, (double)latestValidTestDataPair.Units.PumpIntakePressure.Min, 0.1, "Incorrect min Pump Intake Pressure conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.PumpIntakePressure.Max * 6.894757, (double)latestValidTestDataPairMetric.Units.PumpIntakePressure.Max, 0.1, "Incorrect max Pump Intake Pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.PumpIntakePressure.Max / 6.894757, (double)latestValidTestDataPair.Units.PumpIntakePressure.Max, 0.1, "Incorrect max Pump Intake Pressure conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.SeparatorPressure.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.SeparatorPressure.Min * 6.894757, (double)latestValidTestDataPairMetric.Units.SeparatorPressure.Min, 0.1, "Incorrect min Separator Pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.SeparatorPressure.Min / 6.894757, (double)latestValidTestDataPair.Units.SeparatorPressure.Min, 0.1, "Incorrect min Separator Pressure conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.SeparatorPressure.Max * 6.894757, (double)latestValidTestDataPairMetric.Units.SeparatorPressure.Max, 0.1, "Incorrect max Separator Pressure conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.SeparatorPressure.Max / 6.894757, (double)latestValidTestDataPair.Units.SeparatorPressure.Max, 0.1, "Incorrect max Separator Pressure conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.TotalGasRate.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.TotalGasRate.Min * 28.3168466, (double)latestValidTestDataPairMetric.Units.TotalGasRate.Min, 0.1, "Incorrect min Total Gas Rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.TotalGasRate.Min / 28.3168466, (double)latestValidTestDataPair.Units.TotalGasRate.Min, 0.1, "Incorrect min Total Gas Rate conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.TotalGasRate.Max * 28.3168466, (double)latestValidTestDataPairMetric.Units.TotalGasRate.Max, 0.1, "Incorrect max Total Gas Rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.TotalGasRate.Max / 28.3168466, (double)latestValidTestDataPair.Units.TotalGasRate.Max, 0.1, "Incorrect max Total Gas Rate conversion from metric to US");
                }

                if (latestValidTestDataPair.Units.Water.Min != null)
                {
                    Assert.AreEqual((double)latestValidTestDataPair.Units.Water.Min * 0.1589873, (double)latestValidTestDataPairMetric.Units.Water.Min, 0.1, "Incorrect min Water Rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.Water.Min / 0.1589873, (double)latestValidTestDataPair.Units.Water.Min, 0.1, "Incorrect min Water Rate Rate conversion from metric to US");
                    Assert.AreEqual((double)latestValidTestDataPair.Units.Water.Max * 0.1589873, (double)latestValidTestDataPairMetric.Units.Water.Max, 0.1, "Incorrect max Water Rate conversion from US to metric");
                    Assert.AreEqual((double)latestValidTestDataPairMetric.Units.Water.Max / 0.1589873, (double)latestValidTestDataPair.Units.Water.Max, 0.1, "Incorrect max Water Rate Rate conversion from metric to US");
                }

                // --------------------------- Cross convert the analysis inputs ---------------------------

                // US to metric
                Assert.AreEqual((double)analysisInput_US.ModelData.ESPData.Value.PumpDepth * 0.3048, (double)analysisInput_Metric.ModelData.ESPData.Value.PumpDepth, 0.1, "Incorrect Pump Depth conversion from US to metric");
                // metric to US
                Assert.AreEqual((double)analysisInput_Metric.ModelData.ESPData.Value.PumpDepth / 0.3048, (double)analysisInput_US.ModelData.ESPData.Value.PumpDepth, 0.1, "Incorrect Pump Depth conversion from US to metric");

                Assert.AreEqual((double)analysisInput_US.ModelData.ESPData.Value.PumpDischargePressure * 6.894757, (double)analysisInput_Metric.ModelData.ESPData.Value.PumpDischargePressure, 0.1, "Incorrect Pump Discharge Pressure conversion from US to metric");
                Assert.AreEqual((double)analysisInput_Metric.ModelData.ESPData.Value.PumpDischargePressure / 6.894757, (double)analysisInput_US.ModelData.ESPData.Value.PumpDischargePressure, 0.1, "Incorrect Pump Discharge Pressure conversion from US to metric");

                Assert.AreEqual((double)analysisInput_US.ModelData.ESPData.Value.PumpIntakePressure * 6.894757, (double)analysisInput_Metric.ModelData.ESPData.Value.PumpIntakePressure, 0.1, "Incorrect Pump Intake Pressure conversion from US to metric");
                Assert.AreEqual((double)analysisInput_Metric.ModelData.ESPData.Value.PumpIntakePressure / 6.894757, (double)analysisInput_US.ModelData.ESPData.Value.PumpIntakePressure, 0.1, "Incorrect Pump Intake Pressure conversion from US to metric");

                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WellTestDataHandlingTest()
        {
            //add new well for test
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add new wellTestData
            var testDataDTO = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 30, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCode = 9, SPTCodeDescription = "RejectedTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(100));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            //get the added well test data
            var TestDataCollection = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
            WellTestDTO[] TestDataArray = TestDataCollection.Values;

            //check if the get data matches with added data
            WellTestDTO wellTestGetDTO = new WellTestDTO();
            wellTestGetDTO = TestDataArray.ToList().FirstOrDefault(wt => wt.SampleDate.Date == testDataDTO.SampleDate.Date);
            Assert.AreEqual(wellTestGetDTO.WellId, testDataDTO.WellId, "Well Test - Well Id does not match");
            Assert.AreEqual(wellTestGetDTO.AverageCasingPressure, testDataDTO.AverageCasingPressure, "Well Test - Average Casing Pressure does not match");
            Assert.AreEqual(wellTestGetDTO.AverageFluidAbovePump, testDataDTO.AverageFluidAbovePump, "Well Test - Average Fluid Above Pump does not match");
            Assert.AreEqual(wellTestGetDTO.AverageTubingPressure, testDataDTO.AverageTubingPressure, "Well Test - Average Tubing Pressure does not match");
            Assert.AreEqual(wellTestGetDTO.AverageTubingTemperature, testDataDTO.AverageTubingTemperature, "Well Test - Average Tubing Temperature does not match");
            Assert.AreEqual(wellTestGetDTO.Gas, testDataDTO.Gas, "Well Test - Gas does not match");
            Assert.AreEqual(wellTestGetDTO.GasGravity, testDataDTO.GasGravity, "Well Test - Gas Gravity does not match");
            Assert.AreEqual(wellTestGetDTO.Oil, testDataDTO.Oil, "Well Test - Oil does not match");
            Assert.AreEqual(wellTestGetDTO.OilGravity, testDataDTO.OilGravity, "Well Test - Oil Gravity does not match");
            Assert.AreEqual(wellTestGetDTO.PumpEfficiency, testDataDTO.PumpEfficiency, "Well Test - Pump Efficiency does not match");
            Assert.AreEqual(wellTestGetDTO.PumpIntakePressure, testDataDTO.PumpIntakePressure, "Well Test - Pump Intake Pressure does not match");
            Assert.AreEqual(wellTestGetDTO.PumpingHours, testDataDTO.PumpingHours, "Well Test - Pumping Hours does not match");
            Assert.AreEqual(wellTestGetDTO.SPTCode, testDataDTO.SPTCode, "Well Test - SPT Code does not match");
            Assert.AreEqual(wellTestGetDTO.SPTCodeDescription, testDataDTO.SPTCodeDescription, "Well Test - SPT Code Description does not match");
            Assert.AreEqual(wellTestGetDTO.StrokePerMinute, testDataDTO.StrokePerMinute, "Well Test - Stroke Per Minute does not match");
            Assert.AreEqual(wellTestGetDTO.TestDuration, testDataDTO.TestDuration, "Well Test - Test Duration does not match");
            Assert.AreEqual(wellTestGetDTO.Water, testDataDTO.Water, "Well Test - Water does not match");
            Assert.AreEqual(wellTestGetDTO.WaterGravity, testDataDTO.WaterGravity, "Well Test - Water Gravity does not match");

            string Id = "";
            foreach (WellTestDTO test in TestDataArray)
            {
                Id = Id + test.Id.ToString() + ",";
            }
            string testIds = Id.TrimEnd(',');
            var TestDataArraybyTestIDCollection = WellTestDataService.GetWellTestDataByWellIdAndTestIds(well.Id.ToString(), testIds);
            WellTestDTO[] TestDataArraybyTestID = TestDataArraybyTestIDCollection.Values;
            Assert.AreEqual(TestDataArray.Length, TestDataArraybyTestID.Length);
            WellTestDTO latestTestData = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            //adding welltest without a model file will change the SPT code to "AllocatableTest"
            Assert.AreEqual("RejectedTest", latestTestData.SPTCodeDescription);
            var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNull(latestValidTestDataPair);

            //Update Group TestData
            foreach (var wellTest in TestDataArraybyTestIDCollection.Values)
                wellTest.BeChanged = true;
            var updatedTests = WellTestDataService.UpdateGroupWellTestData(TestDataArraybyTestIDCollection);
            int modifiedTestNumber = (TestDataArraybyTestIDCollection?.Values?.Length ?? 0);
            int updatedTestNumber = (updatedTests?.Values?.Length ?? 0);
            bool GroupUpdate = (modifiedTestNumber == updatedTestNumber);
            Assert.IsTrue(GroupUpdate);

            //Default TestData API
            var defaultTestValues = WellTestDataService.GetWellTestDefaults(well.Id.ToString());
            Assert.IsNull(defaultTestValues.Value);
            WellTestDTO[] allValidTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
            Assert.AreEqual(0, allValidTests.Length);
            WellTestDTO testDataDTOCheck = TestDataArray.FirstOrDefault(a => a.WellId == well.Id);
            Assert.IsNotNull(testDataDTOCheck);
            Assert.AreEqual(1, Convert.ToDouble(testDataDTOCheck.AverageCasingPressure), 1.0E-9);
            Assert.AreEqual(1, Convert.ToDouble(testDataDTOCheck.AverageFluidAbovePump), 1.0E-9);
            Assert.AreEqual(90, Convert.ToDouble(testDataDTOCheck.AverageTubingPressure), 1.0E-9);
            Assert.AreEqual(100, Convert.ToDouble(testDataDTOCheck.AverageTubingTemperature), 1.0E-9);
            Assert.AreEqual(100, Convert.ToDouble(testDataDTOCheck.PumpIntakePressure), 1.0E-9);
            Assert.AreEqual(10, Convert.ToDouble(testDataDTOCheck.PumpingHours), 1.0E-9);
            Assert.AreEqual(83, Convert.ToDouble(testDataDTOCheck.Oil), 1.0E-9);
            Assert.AreEqual(3, Convert.ToDouble(testDataDTOCheck.TestDuration), 1.0E-9);
            Assert.AreEqual(75, Convert.ToDouble(testDataDTOCheck.Water), 1.0E-9);

            //change the added well test data and save
            testDataDTOCheck.AverageCasingPressure = 5;
            testDataDTOCheck.AverageFluidAbovePump = 6;
            testDataDTOCheck.Gas = 1;
            testDataDTOCheck.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(10));
            WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTOCheck));

            //get the changed well test data
            TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
            testDataDTOCheck = null;
            testDataDTOCheck = TestDataArray.FirstOrDefault(a => a.WellId == well.Id);
            Assert.IsNotNull(testDataDTOCheck);
            Assert.AreEqual(5, Convert.ToDouble(testDataDTOCheck.AverageCasingPressure), 1.0E-9);
            Assert.AreEqual(6, Convert.ToDouble(testDataDTOCheck.AverageFluidAbovePump), 1.0E-9);
            Assert.AreEqual(1, Convert.ToDouble(testDataDTOCheck.Gas), 1.0E-9);

            //delete the added well test data
            WellTestDataService.DeleteWellTestData(testDataDTOCheck.Id.ToString());
            testDataDTOCheck = null;
            TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
            testDataDTOCheck = TestDataArray.FirstOrDefault(a => a.WellId == well.Id);
            Assert.IsNull(testDataDTOCheck);

            //remove the added well
            //WellService.RemoveWell(well.Id.ToString());
            WellConfigurationService.RemoveWellConfig(well.Id.ToString());
            _wellsToRemove.Remove(well);
        }

        /// <summary>
        /// Tests for: GetLatestValidWellTestByWellId
        ///            AddWellTestData
        ///            UpdateWellTestData
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetLatestValidWellTestByWellIdSinceMoPChangedTest()
        {
            var allWellsBefore = WellService.GetAllWells().ToList();

            // Add our test well. We only need 1.
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            // Create a place holder well model so the attempt to retrieve the well test headers will not fail for lack of one.
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            // add 20 new well tests having sample dates 1 day apart.
            for (int i = 0; i < 20; i++)
            {
                // The first 5 well tests will be invalid, and they will have sample dates AFTER the MoP change date.
                // The last 15 will all be valid, but only 5 of them will have sample dates after the MoP change date.
                long sptCode = i < 5 ? 9 : 2;

                WellTestDTO testDataDTO = new WellTestDTO
                {
                    WellId = well.Id,
                    AverageCasingPressure = 1,
                    AverageFluidAbovePump = 1,
                    AverageTubingPressure = 90,
                    AverageTubingTemperature = 100,
                    Gas = 0,
                    GasGravity = 0,
                    Oil = 83,
                    OilGravity = 25,
                    PumpEfficiency = 0,
                    PumpIntakePressure = 100,
                    PumpingHours = 10,
                    SPTCode = sptCode,
                    SPTCodeDescription = sptCode == 9 ? WellTestQuality.RejectedTest.ToString() : WellTestQuality.RepresentativeTest.ToString(),
                    StrokePerMinute = 0,
                    TestDuration = 3,
                    Water = 75,
                    WaterGravity = 1.010M,
                };

                // Each well test will have a sample date 1 day prior to the previous one (except for the first well test).
                testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i));
                WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            }

            // The MoP change date is set to 10 days prior to today. That should leave only 5 valid well tests occurring on or after the change date.
            DateTime mopChangeTestDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(10);

            WellMoPHistoryDTO wellMoPHistoryDTO = new WellMoPHistoryDTO();
            wellMoPHistoryDTO.WellId = well.Id;
            wellMoPHistoryDTO.WellType = WellTypeId.ESP;
            wellMoPHistoryDTO.ChangeDate = mopChangeTestDate;
            wellMoPHistoryDTO.Comment = "RRL to ESP";

            // Change the MoP
            WellService.ChangeWellType(wellMoPHistoryDTO);

            #region GetLatestValidWellTestByWellId test

            // Get the latest valid well test with a sample date AFTER the MOP change date.
            WellTestAndUnitsDTO validWellTestsSinceMopChange = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());

            // Because of the way we set up this test the latest valid well test will have a sample date 5 days after the MoP change date.
            Assert.AreEqual(validWellTestsSinceMopChange.Value.SampleDate.AddDays(-5), mopChangeTestDate, "Incorect sample date for latest valid well test. Expected: {0}. Actual: {1}", mopChangeTestDate.ToString(), validWellTestsSinceMopChange.Value.SampleDate.AddDays(-5).ToString());

            #endregion GetLatestValidWellTestByWellId test

            #region AddWellTestData test for adding new well test with sample data AFTER MoP change date

            // Try to add a well test with sample date AFTER the MoP change date.
            WellTestDTO testDataDTO2 = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 1,
                AverageFluidAbovePump = 1,
                AverageTubingPressure = 90,
                AverageTubingTemperature = 100,
                Gas = 0,
                GasGravity = 0,
                Oil = 83,
                OilGravity = 25,
                PumpEfficiency = 0,
                PumpIntakePressure = 100,
                PumpingHours = 10,
                SPTCode = 2,
                SPTCodeDescription = WellTestQuality.RepresentativeTest.ToString(),
                StrokePerMinute = 0,
                TestDuration = 3,
                Water = 75,
                WaterGravity = 1.010M,
            };

            // Make the sample date 6 hours prior to today. We know that this sample date does not exist yet and
            // we know it occurs AFTER the Mop change date.
            testDataDTO2.SampleDate = (DateTime.Today.ToUniversalTime().AddHours(-6));

            // Try to add it. It should succeed.
            bool result = WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO2));

            // If the previous call to WellTestDataService.AddWellTestData fails to add the well test because of an inappropriate
            // sample date, it will throw an exception and never return back here. So we know that the test succeeded
            // if the call returns at all. So, no real value in the following statement.
            Assert.IsTrue(result, "Add well test failed for a well test with sample date AFTER the MoP change date");

            #endregion AddWellTestData test for adding new well test with sample data AFTER MoP change date

            #region Can't test adding new well test with sample data PRIOR to MoP change date

            // ************************************************************************

            // The following section was intended to test the attempt to add a well test with a sample date PRIOR to the MoP
            // change date. However, because the call to WellTestDataService.AddWellTestData throws an
            // exception when this situation occurs and never returns to the caller, there is no way for us to get a
            // return boolean type of false. Hence, we cannot get a test result.

            //WellTestDTO testDataDTO3 = new WellTestDTO
            //{
            //    WellId = well.Id,
            //    AverageCasingPressure = 1,
            //    AverageFluidAbovePump = 1,
            //    AverageTubingPressure = 90,
            //    AverageTubingTemperature = 100,
            //    Gas = 0,
            //    GasGravity = 0,
            //    Oil = 83,
            //    OilGravity = 25,
            //    PumpEfficiency = 0,
            //    PumpIntakePressure = 100,
            //    PumpingHours = 10,
            //    SPTCode = 2,
            //    SPTCodeDescription = WellTestQuality.RepresentativeTest.ToString(),
            //    StrokePerMinute = 0,
            //    TestDuration = 3,
            //    Water = 75,
            //    WaterGravity = 1.010M,
            //};

            // Make the sample date 1 day PRIOR to the MoP change date. This should fail.
            //testDataDTO3.SampleDate = mopChangeTestDate.AddDays(-1);
            //result = WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO3));

            // ************************************************************************

            #endregion Can't test adding new well test with sample data PRIOR to MoP change date

            #region UpdateWellTestData with well test sample date AFTER the MoP change date

            validWellTestsSinceMopChange.Value.Oil = 99;
            validWellTestsSinceMopChange.Value.Water = 88;
            validWellTestsSinceMopChange.Value.Gas = 77;

            result = WellTestDataService.UpdateWellTestData(validWellTestsSinceMopChange);

            // If the previous call to WellTestDataService.UpdateWellTestData fails to update the well test because of an inappropriate
            // sample date (i.e. a sample date PRIOR to the MoP change date), it will throw an exception and never return back here.
            // So we know that the test succeeded if the call returns at all. So, no real value in the following statement.
            Assert.IsTrue(result, "Failed to update a well test with sample date AFTER the MoP change date.");

            #endregion UpdateWellTestData with well test sample date AFTER the MoP change date
        }

        /// <summary>
        /// Tests for: GetAllValidWellTestByWellId
        ///            GetValidWellTestHeadersByWellId
        ///            GetWellTestDataByWellId
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetWellTestsForCurrentMoPOnlyTest()
        {
            var allWellsBefore = WellService.GetAllWells().ToList();

            // Add our test well. We only need 1.
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            // Create a place holder well model so the attempt to retrieve the well test headers will not fail for lack of one.
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            // add 20 new well tests having sample dates 1 day apart.
            for (int i = 0; i < 20; i++)
            {
                var testDataDTO = new WellTestDTO
                {
                    WellId = well.Id,
                    AverageCasingPressure = 1,
                    AverageFluidAbovePump = 1,
                    AverageTubingPressure = 90,
                    AverageTubingTemperature = 100,
                    Gas = 0,
                    GasGravity = 0,
                    Oil = 83,
                    OilGravity = 25,
                    PumpEfficiency = 0,
                    PumpIntakePressure = 100,
                    PumpingHours = 10,
                    SPTCode = 2,
                    SPTCodeDescription = WellTestQuality.RepresentativeTest.ToString(),
                    StrokePerMinute = 0,
                    TestDuration = 3,
                    Water = 75,
                    WaterGravity = 1.010M,
                };

                // Each well test will have a sample date 1 day prior to the previous one (except for the first well test).
                testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i));
                WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            }

            // The MoP change date is set to 10 days prior to today. That should leave only 11 well tests occurring on or after the change date.
            DateTime mopChangeTestDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(10);

            // Change the well type to ESP
            WellMoPHistoryDTO wellMoPHistoryDTO = new WellMoPHistoryDTO();
            wellMoPHistoryDTO.WellId = well.Id;
            wellMoPHistoryDTO.WellType = WellTypeId.ESP;
            wellMoPHistoryDTO.ChangeDate = mopChangeTestDate;
            wellMoPHistoryDTO.Comment = "RRL to ESP";
            WellService.ChangeWellType(wellMoPHistoryDTO);

            #region GetAllValidWellTestByWellId test

            WellTestDTO[] validWellTestsSinceMopChange = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

            // If all is well there are 11 well tests that occurred on or after the MoP change date.
            Assert.AreEqual(11, validWellTestsSinceMopChange.Count(), "Incorrect number of well tests retrieved after well type change.");
            foreach (WellTestDTO wellTestDTO in validWellTestsSinceMopChange)
            {
                // Sample date is earlier than the MoP change date.
                Assert.IsTrue(wellTestDTO.SampleDate >= mopChangeTestDate, "Well test sample date of {0} preceeds the MoP change date of {1}.", wellTestDTO.SampleDate, mopChangeTestDate);
            }

            #endregion GetAllValidWellTestByWellId test

            #region GetValidWellTestHeadersByWellId test

            WellTestHeaderDTO[] wellTestHeadersSinceMopChange = WellTestDataService.GetValidWellTestHeadersByWellId(well.Id.ToString());
            // If all is well there are 11 well tests that occurred on or after the MoP change date.
            Assert.AreEqual(11, wellTestHeadersSinceMopChange.Count(), "Incorrect number of well test headers retrieved after well type change.");
            foreach (WellTestHeaderDTO headerDTO in wellTestHeadersSinceMopChange)
            {
                // Sample date is earlier than the MoP change date.
                Assert.IsTrue(headerDTO.SampleDate >= mopChangeTestDate, "Well test header sample date of {0} preceeds the MoP change date of {1}.", headerDTO.SampleDate, mopChangeTestDate);
            }

            #endregion GetValidWellTestHeadersByWellId test

            #region GetWellTestDataByWellId test

            WellTestArrayAndUnitsDTO wellTestsSinceMopChange = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());

            // If all is well there are 11 well tests that occurred on or after the MoP change date.
            Assert.AreEqual(11, wellTestsSinceMopChange.Values.Count(), "Incorrect number of well tests retrieved after well type change.");

            // Inspect each sample date to make sure it conforms to the filter imposed in the call to GetWellTestDataByWellId().
            foreach (WellTestDTO wellTest in wellTestsSinceMopChange.Values)
            {
                // Sample date is earlier than the MoP change date.
                Assert.IsTrue(wellTest.SampleDate >= mopChangeTestDate, "Well test sample date of {0} preceeds the MoP change date of {1}.", wellTest.SampleDate, mopChangeTestDate);
            }

            #endregion GetWellTestDataByWellId test
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void DeleteTestDataGroup()
        {
            //add new well for test
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add new wellTestData
            var testDataDTO = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "RejectedTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(100));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            //get the added well test data
            var TestDataCollection = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
            WellTestDTO[] TestDataArray = TestDataCollection.Values;
            Assert.AreEqual(1, TestDataArray.Length);
            long[] wellTestIds = TestDataArray.Select(t => t.Id).ToArray();
            WellTestDataService.DeleteWellTestDataGroup(wellTestIds);

            var afterTestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
            Assert.AreEqual(0, afterTestDataArray.Length);
        }

        public void AddWell(string facility_tag)
        {
            string facilityId;
            if (s_isRunningInATS)
                facilityId = facility_tag + "00001";
            else
                facilityId = facility_tag + "0001";
            WellConfigurationService.AddWellConfig(new WellConfigDTO()
            {
                Well = SetDefaultFluidType(new WellDTO()
                {
                    Name = DefaultWellName,
                    FacilityId = facilityId,
                    DataConnection = GetDefaultCygNetDataConnection(),
                    SubAssemblyAPI = "testSubAssemblyAPI",
                    AssemblyAPI = "testAssemblyAPI",
                    CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)),
                    WellType = WellTypeId.RRL,
                })
            });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);
        }

        public void CreateWellandWellTest(WellTypeId wellTypeId)
        {
            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellTypeId.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellTypeId }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellTypeId.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            //add new wellTestData
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 2,
                SPTCodeDescription = "RepresentativeTest",
                TestDuration = 3,
                Water = 1900,
                WaterGravity = (decimal)1.0239,
                GaugePressure = (decimal)1610
            };

            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1));
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            WellTestDTO[] addedWelltests = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
            Assert.AreEqual(1, addedWelltests.Count(), "Mismatch in added well tests");
            WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
            Assert.IsNotNull(testDataDTOCheck);
            Assert.AreEqual("RepresentativeTest", testDataDTOCheck.SPTCodeDescription);
            Assert.AreEqual(600, testDataDTOCheck.AverageTubingPressure);
            Assert.AreEqual(100, testDataDTOCheck.AverageTubingTemperature);
            Assert.AreEqual(2204, Convert.ToDouble(testDataDTOCheck.Gas));
            Assert.AreEqual(0.6722, Convert.ToDouble(testDataDTOCheck.GasGravity), 1.0E-9);
            Assert.AreEqual(1900, testDataDTOCheck.Oil);
            Assert.AreEqual(46.2415, Convert.ToDouble(testDataDTOCheck.OilGravity), 1.0E-9);
            Assert.AreEqual(1610, testDataDTOCheck.GaugePressure);
            Assert.AreEqual(2, testDataDTOCheck.SPTCode);
            Assert.AreEqual(3, testDataDTOCheck.TestDuration);
            Assert.AreEqual(1900, testDataDTOCheck.Water);
            //Assert.AreEqual(1.029, Convert.ToDouble(testDataDTOCheck.WaterGravity), 1.0E-9);
            Assert.AreEqual(DateTime.Today.AddDays(-1).ToUniversalTime(), testDataDTOCheck.SampleDate);

        }

        public void WellTestTrend(WellTestQuantity wellTestTrendItem, string value, string unitsData)
        {
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName));
            var assembly = WellboreComponentService.GetAssemblyByWellId(well.Id.ToString());
            int trend = (int)wellTestTrendItem;
            CygNetTrendDTO wellTestTrend = WellTestDataService.GetWellTestTrendByDateRange(well.Id.ToString(), trend.ToString(), DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime().AddMonths(-1)), DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime()));
            Assert.AreEqual("Success", wellTestTrend.ErrorMessage, "Exception occurred while plotting the WelltestData trend : " + wellTestTrend.ErrorMessage);
            Assert.AreEqual(wellTestTrendItem.ToString(), wellTestTrend.PointUDC, "Mismatch between the plotted and requested trend");
            Assert.AreEqual(unitsData, wellTestTrend.Units);
            for (int i = 0; i < wellTestTrend.PointValues.Count(); i++)
            {
                Assert.AreEqual(value, (wellTestTrend.PointValues[i].Value.HasValue ? Math.Round(wellTestTrend.PointValues[i].Value.Value) : 0).ToString(), "Mismatch betwenn WellTestTrend data and WellTest data for : " + wellTestTrendItem.ToString());
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WellTestTrendData()
        {
            AddWell("RPOC_");
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName));

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add new wellTestData
            for (int i = 0; i < 15; i++)
            {
                //add new wellTestData
                var testDataDTO = new WellTestDTO
                {
                    WellId = well.Id,
                    AverageCasingPressure = 1,
                    AverageFluidAbovePump = 1,
                    AverageTubingPressure = 90,
                    AverageTubingTemperature = 100,
                    Gas = 0,
                    GasGravity = 0,
                    Oil = 83,
                    OilGravity = 25,
                    PumpEfficiency = 0,
                    PumpIntakePressure = 100,
                    PumpingHours = 10,
                    //SPTCode = 1,
                    SPTCodeDescription = WellTestQuality.RepresentativeTest.ToString(),
                    StrokePerMinute = 0,
                    TestDuration = 3,
                    Water = 75,
                    WaterGravity = 1.010M,
                };
                testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i + 10));
                WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            }
            //Get all valid well tests
            WellTestDTO[] addedWelltests = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
            Assert.AreEqual(15, addedWelltests.Count(), "Mismatch in added well tests");
            //Validating Well Test trend for every test trend point
            var wellTestArrayAndUnits = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
            WellTestAndUnitsDTO testData = new WellTestAndUnitsDTO { Value = wellTestArrayAndUnits.Values.First(), Units = wellTestArrayAndUnits.Units };
            WellTestTrendList(well.Id.ToString(), well.Name.ToString());
            //below code is commented because of new validation 
            //WellTestTrend(WellTestQuantity.Oil, Math.Round(testData.Value.Oil.Value).ToString(), testData.Units.Oil.UnitKey);
            //WellTestTrend(WellTestQuantity.Water, Math.Round(testData.Value.Water.Value).ToString(), testData.Units.Water.UnitKey);
            //WellTestTrend(WellTestQuantity.GOR, Math.Round(testData.Value.GOR.Value).ToString(), testData.Units.GOR.UnitKey);
            //WellTestTrend(WellTestQuantity.TotalFluid, Math.Round(testData.Value.TotalFluid.Value).ToString(), testData.Units.TotalFluid.UnitKey);
            //WellTestTrend(WellTestQuantity.WaterCut, Math.Round(testData.Value.WaterCut.Value).ToString(), testData.Units.WaterCut.UnitKey);

        }


        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateWellTestsForAddedModelFile_AllocatableTest()
        {
            TestUpdatedWellTestForModelFile(0, "AllocatableTest", true);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateWellTestsForAddedModelFile_RepresentativeTest()
        {
            TestUpdatedWellTestForModelFile(2, "RepresentativeTest", true);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateWellTestsForAddedModelFile_OilPotentialTest()
        {
            TestUpdatedWellTestForModelFile(1, "OilPotentialTest", false);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateWellTestsForAddedModelFile_RejectedTest()
        {
            TestUpdatedWellTestForModelFile(9, "RejectedTest", false);
        }

        private void TestUpdatedWellTestForModelFile(int sptCode, string sptCodeDescription, bool shouldUpdateWellTest)
        {
            //Create well
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add wellTest 20 Days Old
            var wellTest_20DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 30, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCode = sptCode, SPTCodeDescription = sptCodeDescription, StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_20DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(20));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_20DaysOld));
            WellTestDTO latestWellTest = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            Assert.IsNotNull(latestWellTest);
            var addedDate = latestWellTest.LastChangedDT;

            // Add some sleep before adding model data
            System.Threading.Thread.Sleep(5000);
            //Create model file 30 Days Old
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);   // It will internally call WellTestDataService.UpdateWellTestsForAddedModelFile
            ModelFileDTO model_30DaysOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(model_30DaysOld);
            _modelFilesToRemove.Add(model_30DaysOld.Id.ToString());

            bool result = WellTestDataService.UpdateWellTestsForAddedModelFile(model_30DaysOld.Id.ToString(), model_30DaysOld.ApplicableDate.ToString());
            Assert.IsTrue(result == shouldUpdateWellTest); //no update will return false

            latestWellTest = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            Assert.IsNotNull(latestWellTest);
            // Last Changed date will be updated here based on the time when model file was added.
            // We can check this to confirm if the well test data has been updated
            var updatedDate = latestWellTest.LastChangedDT;

            if (shouldUpdateWellTest)
            {
                Assert.IsTrue(updatedDate > addedDate);
            }
            else
            {
                Assert.AreEqual(updatedDate, addedDate);
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetWellTestsForAddedModelFile_AllocatableTest()
        {
            //Create well
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add wellTest 20 Days Old - AllocatableTest
            var wellTest_20DaysOld_AllocatableTest = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 30, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCode = 0, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_20DaysOld_AllocatableTest.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(20));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_20DaysOld_AllocatableTest));
            WellTestDTO latestWellTest = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            Assert.IsNotNull(latestWellTest);
            var addedDate_AllocatableTest = latestWellTest.LastChangedDT;

            // Add some sleep before adding model data
            System.Threading.Thread.Sleep(5000);
            //Create model file 30 Days Old
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);   // It will internally call WellTestDataService.UpdateWellTestsForAddedModelFile
            ModelFileDTO model_30DaysOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(model_30DaysOld);
            _modelFilesToRemove.Add(model_30DaysOld.Id.ToString());

            latestWellTest = WellTestDataService.GetWellTestsForAddedModelFile(model_30DaysOld.Id.ToString(), model_30DaysOld.ApplicableDate.ToString()).FirstOrDefault();

            Assert.IsNotNull(latestWellTest);
            // Last Changed date will be updated here based on the time when model file was added.
            // We can check this to confirm if the well test data has been updated
            var updatedDate = latestWellTest.LastChangedDT;

            Assert.IsTrue(updatedDate > addedDate_AllocatableTest);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetWellTestsForAddedModelFile_RepresentativeTest()
        {
            //Create well
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add wellTest 20 Days Old - RepresentativeTest
            var wellTest_20DaysOld_RepresentativeTest = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 30, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCode = 2, SPTCodeDescription = "RepresentativeTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_20DaysOld_RepresentativeTest.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(21));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_20DaysOld_RepresentativeTest));
            var latestWellTest = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            Assert.IsNotNull(latestWellTest);
            var addedDate_RepresentativeTest = latestWellTest.LastChangedDT;

            // Add some sleep before adding model data
            System.Threading.Thread.Sleep(5000);
            //Create model file 30 Days Old
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);   // It will internally call WellTestDataService.UpdateWellTestsForAddedModelFile
            ModelFileDTO model_30DaysOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(model_30DaysOld);
            _modelFilesToRemove.Add(model_30DaysOld.Id.ToString());

            latestWellTest = WellTestDataService.GetWellTestsForAddedModelFile(model_30DaysOld.Id.ToString(), model_30DaysOld.ApplicableDate.ToString()).FirstOrDefault();

            Assert.IsNotNull(latestWellTest);
            // Last Changed date will be updated here based on the time when model file was added.
            // We can check this to confirm if the well test data has been updated
            var updatedDate = latestWellTest.LastChangedDT;

            Assert.IsTrue(updatedDate > addedDate_RepresentativeTest);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetWellTestsForAddedModelFile_OilPotentialTest()
        {
            //Create well
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add wellTest 20 Days Old - OilPotentialTest
            var wellTest_20DaysOld_OilPotentialTest = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 30, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCode = 1, SPTCodeDescription = "OilPotentialTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_20DaysOld_OilPotentialTest.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(22));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_20DaysOld_OilPotentialTest));
            var latestWellTest = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            Assert.IsNotNull(latestWellTest);
            var addedDate_OilPotentialTest = latestWellTest.LastChangedDT;

            // Add some sleep before adding model data
            System.Threading.Thread.Sleep(5000);
            //Create model file 30 Days Old
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);   // It will internally call WellTestDataService.UpdateWellTestsForAddedModelFile
            ModelFileDTO model_30DaysOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(model_30DaysOld);
            _modelFilesToRemove.Add(model_30DaysOld.Id.ToString());

            latestWellTest = WellTestDataService.GetWellTestsForAddedModelFile(model_30DaysOld.Id.ToString(), model_30DaysOld.ApplicableDate.ToString()).FirstOrDefault();

            Assert.IsNotNull(latestWellTest);
            // Last Changed date will be updated here based on the time when model file was added.
            // We can check this to confirm if the well test data has been updated
            var updatedDate = latestWellTest.LastChangedDT;

            // Updated model file does not trigger well test update for OilPotentialTest
            Assert.IsTrue(updatedDate == addedDate_OilPotentialTest);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetWellTestsForAddedModelFile_RejectedTest()
        {
            //Create well
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add wellTest 20 Days Old - RejectedTest
            var wellTest_20DaysOld_RejectedTest = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 30, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCode = 9, SPTCodeDescription = "RejectedTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_20DaysOld_RejectedTest.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(23));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_20DaysOld_RejectedTest));
            var latestWellTest = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            Assert.IsNotNull(latestWellTest);
            var addedDate_RejectedTest = latestWellTest.LastChangedDT;

            // Add some sleep before adding model data
            System.Threading.Thread.Sleep(5000);
            //Create model file 30 Days Old
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);   // It will internally call WellTestDataService.UpdateWellTestsForAddedModelFile
            ModelFileDTO model_30DaysOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(model_30DaysOld);
            _modelFilesToRemove.Add(model_30DaysOld.Id.ToString());

            latestWellTest = WellTestDataService.GetWellTestsForAddedModelFile(model_30DaysOld.Id.ToString(), model_30DaysOld.ApplicableDate.ToString()).FirstOrDefault();

            Assert.IsNotNull(latestWellTest);
            // Last Changed date will be updated here based on the time when model file was added.
            // We can check this to confirm if the well test data has been updated
            var updatedDate = latestWellTest.LastChangedDT;

            // Updated model file does not trigger well test update for RejectedTest
            Assert.IsTrue(updatedDate == addedDate_RejectedTest);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetWellTestsForModelFileAndUpdate()
        {
            //Create well
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //Create model file 30 Days Old
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);
            ModelFileDTO model_30DaysOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());

            //Create model file 1 Day old
            modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-1));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);
            ModelFileDTO model_1DayOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());

            //add wellTest 20 Days Old
            var wellTest_20DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_20DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(20));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_20DaysOld));

            //add wellTest 10 Days Old
            var wellTest_10DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_10DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(10));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_10DaysOld));

            //add wellTest 5 Days Old
            var wellTest_5DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_5DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(5));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_5DaysOld));

            //add wellTest Today
            var wellTest_Today = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_Today.SampleDate = (DateTime.Today.ToUniversalTime());
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_Today));

            //Call UpdateWellTestsForDeletedModelFile for First Model
            bool isSuccess = WellTestDataService.UpdateWellTestsForDeletedModelFile(model_30DaysOld.Id.ToString());
            Assert.IsTrue(isSuccess, "Update well test for deleted model file failed");

            //Call GetWellTestsForDeletedModelFile for First Model
            WellTestDTO[] wellTestResults_30DayModel = WellTestDataService.GetWellTestsForDeletedModelFile(model_30DaysOld.Id.ToString());
            Assert.IsNotNull(wellTestResults_30DayModel);
            Assert.AreEqual(3, wellTestResults_30DayModel.Length);

            //Check to make sure each is set to Needs Tuning(Not Complete)
            foreach (WellTestDTO test in wellTestResults_30DayModel)
            {
                Assert.AreEqual(Enums.WellTestStatus.TUNING_NOT_COMPLETE, test.Status);
            }

            //Call GetWellTestsForDeletedModelFile for Second Model
            WellTestDTO[] wellTestResults_1DayModel = WellTestDataService.GetWellTestsForDeletedModelFile(model_1DayOld.Id.ToString());
            Assert.IsNotNull(wellTestResults_1DayModel);
            Assert.AreEqual(1, wellTestResults_1DayModel.Length);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WellTestAddUpdateDeleteNonRRL()
        {
            //GasInjection model in test documents not good for tuning
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
             Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } }),
             Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.PI, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("WellfloWaterInjectionExample1.wflx", WellTypeId.WInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.InjectivityIndex, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("WellfloGasLiftExampleTuningTrace.WFLX", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR) } }),
             //Tuple.Create("WellfloGasInjectionExample1.wflx", WellTypeId.GInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
            };
            foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
            {
                int i = 1;
                string model = modelInfo.Item1;
                WellTypeId wellType = modelInfo.Item2;
                ModelFileOptionDTO options = modelInfo.Item3;

                Trace.WriteLine("Testing model: " + model);
                //Create a new well
                WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
                var allWells = WellService.GetAllWells().ToList();
                WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                Assert.IsNotNull(well);
                _wellsToRemove.Add(well);

                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                options.Comment = "CASETest Upload " + modelInfo.Item1;
                modelFile.Options = options;
                modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i);
                modelFile.WellId = well.Id;

                byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                Assert.IsNotNull(fileAsByteArray);
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                Assert.IsNotNull(ModelFileValidationData);
                ModelFileService.AddWellModelFile(modelFile);
                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());

                #region ESP

                if (wellType == WellTypeId.ESP)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCode = 0,
                        SPTCodeDescription = "AllocatableTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        PumpIntakePressure = 10000,
                        PumpDischargePressure = 11000,
                        GaugePressure = 12000,
                        Oil = 5000,
                        Gas = 500,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                        Frequency = 20,
                        MotorVolts = 250,
                        MotorCurrent = 48,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual("AllocatableTest", testDataDTOCheck.SPTCodeDescription);
                    Assert.AreEqual(5000, Convert.ToDouble(testDataDTOCheck.AverageTubingPressure), 1.0E-9);
                    Assert.AreEqual(65, testDataDTOCheck.AverageTubingTemperature);
                    Assert.AreEqual(10000, Convert.ToDouble(testDataDTOCheck.PumpIntakePressure), 1.0E-9);
                    Assert.AreEqual(11000, Convert.ToDouble(testDataDTOCheck.PumpDischargePressure), 1.0E-9);
                    Assert.AreEqual(12000, Convert.ToDouble(testDataDTOCheck.GaugePressure), 1.0E-9);
                    Assert.AreEqual(5000, Convert.ToDouble(testDataDTOCheck.Oil), 1.0E-9);
                    Assert.AreEqual(500, Convert.ToDouble(testDataDTOCheck.Gas), 1.0E-9);
                    Assert.AreEqual(8000, Convert.ToDouble(testDataDTOCheck.Water), 1.0E-9);
                    Assert.AreEqual(50, Convert.ToDouble(testDataDTOCheck.ChokeSize), 1.0E-9);
                    Assert.AreEqual(50, Convert.ToDouble(testDataDTOCheck.FlowLinePressure), 1.0E-9);
                    Assert.AreEqual(10000, Convert.ToDouble(testDataDTOCheck.SeparatorPressure), 1.0E-9);
                    Assert.AreEqual(20, testDataDTOCheck.Frequency);
                    Assert.AreEqual(250, testDataDTOCheck.MotorVolts);
                    Assert.AreEqual(48, testDataDTOCheck.MotorCurrent);
                    Assert.AreEqual(WellTestStatus.TUNING_IPR_TUNING_ONLY_FAILED, testDataDTOCheck.Status);

                    //change the added well test data and save
                    testDataDTOCheck.PumpIntakePressure = 10001;
                    testDataDTOCheck.GaugePressure = 12001;
                    testDataDTOCheck.Gas = 501;
                    testDataDTOCheck.Frequency = 25;
                    testDataDTOCheck.MotorVolts = 350;
                    testDataDTOCheck.MotorCurrent = 50;

                    WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTOCheck));

                    //get the changed well test data
                    var TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(10001, Convert.ToDouble(testDataDTOCheck.PumpIntakePressure), 1.0E-9);
                    Assert.AreEqual(12001, Convert.ToDouble(testDataDTOCheck.GaugePressure), 1.0E-9);
                    Assert.AreEqual(501, Convert.ToDouble(testDataDTOCheck.Gas), 1.0E-9);
                    Assert.AreEqual(25, testDataDTOCheck.Frequency);
                    Assert.AreEqual(350, testDataDTOCheck.MotorVolts);
                    Assert.AreEqual(50, testDataDTOCheck.MotorCurrent);
                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                    var TestDataArray1 = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray1.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                }

                #endregion ESP

                #region WaterInjection

                else if (wellType == WellTypeId.WInj)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCode = 2,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        PumpIntakePressure = 10000,
                        PumpDischargePressure = 11000,
                        GaugePressure = 12000,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual("RepresentativeTest", testDataDTOCheck.SPTCodeDescription);
                    Assert.AreEqual(5000, Convert.ToDouble(testDataDTOCheck.AverageTubingPressure), 1.0E-9);
                    Assert.AreEqual(65, testDataDTOCheck.AverageTubingTemperature);
                    Assert.AreEqual(10000, Convert.ToDouble(testDataDTOCheck.PumpIntakePressure), 1.0E-9);
                    Assert.AreEqual(11000, Convert.ToDouble(testDataDTOCheck.PumpDischargePressure), 1.0E-9);
                    Assert.AreEqual(12000, Convert.ToDouble(testDataDTOCheck.GaugePressure), 1.0E-9);
                    Assert.AreEqual(8000, Convert.ToDouble(testDataDTOCheck.Water), 1.0E-9);
                    Assert.AreEqual(50, Convert.ToDouble(testDataDTOCheck.ChokeSize), 1.0E-9);
                    Assert.AreEqual(50, Convert.ToDouble(testDataDTOCheck.FlowLinePressure), 1.0E-9);
                    Assert.AreEqual(WellTestStatus.TUNING_SUCCEEDED, testDataDTOCheck.Status);

                    //change the added well test data and save
                    testDataDTOCheck.PumpIntakePressure = 10001;
                    testDataDTOCheck.GaugePressure = 12001;
                    testDataDTOCheck.ChokeSize = 25;

                    WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTOCheck));

                    //get the changed well test data
                    var TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(10001, Convert.ToDouble(testDataDTOCheck.PumpIntakePressure), 1.0E-9);
                    Assert.AreEqual(12001, Convert.ToDouble(testDataDTOCheck.GaugePressure), 1.0E-9);
                    Assert.AreEqual(25, Convert.ToDouble(testDataDTOCheck.ChokeSize), 1.0E-9);
                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                    var TestDataArray1 = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray1.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                }

                #endregion WaterInjection

                #region GasLift

                else if (wellType == WellTypeId.GLift)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCode = 2,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        AverageCasingPressure = 1000,
                        GasInjectionRate = 1000,
                        FlowLinePressure = 50,
                        SeparatorPressure = 30,
                        GaugePressure = 12000,
                        Oil = (decimal)1497.8,
                        Gas = 500,
                        Water = (decimal)2246.6,
                        ChokeSize = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestAndUnitsDTO WellTestAndUnits = new WellTestAndUnitsDTO();
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO;
                    WellTestDataService.SaveWellTest(WellTestAndUnits);

                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNotNull(testDataDTOCheck);

                    Assert.AreEqual("RepresentativeTest", testDataDTOCheck.SPTCodeDescription);
                    Assert.AreEqual(5000, Convert.ToDouble(testDataDTOCheck.AverageTubingPressure), 1.0E-9);
                    Assert.AreEqual(65, Convert.ToDouble(testDataDTOCheck.AverageTubingTemperature), 1.0E-9);
                    Assert.AreEqual(1000, Convert.ToDouble(testDataDTOCheck.AverageCasingPressure), 1.0E-9);

                    Assert.AreEqual(12000, Convert.ToDouble(testDataDTOCheck.GaugePressure), 1.0E-9);
                    Assert.AreEqual(1497.8, Convert.ToDouble(testDataDTOCheck.Oil), 1.0E-9);
                    Assert.AreEqual(500, Convert.ToDouble(testDataDTOCheck.Gas), 1.0E-9);
                    Assert.AreEqual(2246.6, Convert.ToDouble(testDataDTOCheck.Water), 1.0E-9);
                    Assert.AreEqual(50, Convert.ToDouble(testDataDTOCheck.ChokeSize), 1.0E-9);
                    Assert.AreEqual(50, Convert.ToDouble(testDataDTOCheck.FlowLinePressure), 1.0E-9);
                    Assert.AreEqual(0, testDataDTOCheck.OrificeSize);
                    //Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_RESERVOIR_PRESSURE_TOO_HIGH, testDataDTOCheck.Status);
                    Assert.AreEqual(WellTestStatus.TUNING_IPR_TUNING_ONLY_FAILED, testDataDTOCheck.Status);

                    //change the added well test data and save

                    testDataDTOCheck.GasInjectionRate = 1001;
                    testDataDTOCheck.FlowLinePressure = 51;
                    WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTOCheck));

                    //get the changed well test data
                    var TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(1001, Convert.ToDouble(testDataDTOCheck.GasInjectionRate), 1.0E-9);
                    Assert.AreEqual(51, Convert.ToDouble(testDataDTOCheck.FlowLinePressure), 1.0E-9);
                    Assert.AreEqual(CalibrationMethodId.ReservoirPressure, testDataDTOCheck.CalibrationMethod); //3= ReservoirPressure

                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                    var TestDataArray1 = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray1.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(6000, ModelFileValidationData.DHPG);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                }

                #endregion GasLift

                #region NF

                else if (wellType == WellTypeId.NF)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCode = 2,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        GaugePressure = 12000,
                        Oil = 5000,
                        Gas = 500,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual("RepresentativeTest", testDataDTOCheck.SPTCodeDescription);
                    Assert.AreEqual(5000, Convert.ToDouble(testDataDTOCheck.AverageTubingPressure), 1.0E-9);
                    Assert.AreEqual(65, testDataDTOCheck.AverageTubingTemperature);
                    Assert.AreEqual(12000, Convert.ToDouble(testDataDTOCheck.GaugePressure), 1.0E-9);
                    Assert.AreEqual(5000, Convert.ToDouble(testDataDTOCheck.Oil), 1.0E-9);
                    Assert.AreEqual(500, Convert.ToDouble(testDataDTOCheck.Gas), 1.0E-9);
                    Assert.AreEqual(8000, Convert.ToDouble(testDataDTOCheck.Water), 1.0E-9);
                    Assert.AreEqual(50, Convert.ToDouble(testDataDTOCheck.ChokeSize), 1.0E-9);
                    Assert.AreEqual(50, Convert.ToDouble(testDataDTOCheck.FlowLinePressure), 1.0E-9);
                    Assert.AreEqual(10000, Convert.ToDouble(testDataDTOCheck.SeparatorPressure), 1.0E-9);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_SUCCEEDED, testDataDTOCheck.Status);
                    Assert.AreEqual(WellTestStatus.TUNING_IPR_TUNING_ONLY_FAILED, testDataDTOCheck.Status);

                    //change the added well test data and save
                    testDataDTOCheck.GaugePressure = 12001;
                    testDataDTOCheck.Gas = 501;
                    testDataDTOCheck.ChokeSize = 25;
                    WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTOCheck));

                    //get the changed well test data
                    var TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(12001, Convert.ToDouble(testDataDTOCheck.GaugePressure), 1.0E-9);
                    Assert.AreEqual(501, Convert.ToDouble(testDataDTOCheck.Gas), 1.0E-9);
                    Assert.AreEqual(25, Convert.ToDouble(testDataDTOCheck.ChokeSize), 1.0E-9);

                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                    var TestDataArray1 = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray1.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                }

                #endregion NF
            }
        }

        public void GlWellWithTestData()
        {
            //pick up the right model file
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("GL-01-Base.wflx", WellTypeId.GLift, new ModelFileOptionDTO() { CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), (long)OptionalUpdates.UpdateWCT_WGR, ((long)OptionalUpdates.CalculateChokeD_Factor) } });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);
            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(2);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            //add new wellTestData
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 2,
                SPTCodeDescription = "RepresentativeTest",
                TestDuration = 3,
                Water = 1900,
                ChokeSize = 64,
                WaterGravity = (decimal)1.0239,
                //LFactor = 1,
                //ReservoirPressure = 5250,
                //ProductivityIndex = (decimal)1.36,
                GaugePressure = (decimal)1610
            };

            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1));
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetValidWellTestHeadersByWellId()
        {
            //pick up the right model file
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("GL-01-Base.wflx", WellTypeId.GLift, new ModelFileOptionDTO() { CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);
            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            //add new wellTestData
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 2,
                SPTCodeDescription = "RepresentativeTest",
                TestDuration = 3,
                Water = 1900,
                WaterGravity = (decimal)1.0239,
                GaugePressure = (decimal)1610
            };

            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(-100));
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            //get the newly added (latest) valid well test header
            WellTestHeaderDTO[] latestValidTests = WellTestDataService.GetValidWellTestHeadersByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTests);
            Assert.IsTrue(latestValidTests.Count() > 0);

            var latestValidTest = latestValidTests[0];

            Assert.AreEqual(testDataDTO.SampleDate, latestValidTest.SampleDate);
            Assert.AreEqual(testDataDTO.SPTCode, latestValidTest.SPTCode);
            Assert.AreEqual("RepresentativeTest", latestValidTest.SPTCodeDescription);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PumpWearFactorForTandemESPPumpsTest()
        {
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("Esp_TandemPumpsExample.wflx",
                                                                                WellTypeId.ESP,
                                                                                new ModelFileOptionDTO()
                                                                                {
                                                                                    CalibrationMethod = CalibrationMethodId.ReservoirPressureAndLFactor,
                                                                                    Comment = "auto test",
                                                                                    PumpPressure = PIPandPDPOption.Has_PumpDischargePressure,
                                                                                    OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR),
                                                                                                                                         ((long)OptionalUpdates.UpdateGOR_CGR),
                                                                                                                                         ((long)OptionalUpdates.PumpWearFactor)},
                                                                                });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            // Add a well and test for its existence in the database.
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");

            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);

            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            // create an allocatable well test
            WellTestDTO testDataDTO = new WellTestDTO()
            {
                WellId = well.Id,
                SPTCodeDescription = "AllocatableTest",
                AverageTubingPressure = 1615,
                AverageTubingTemperature = 83,
                PumpIntakePressure = 1500,
                PumpDischargePressure = 2000,
                GaugePressure = 1648,
                ReservoirPressure = 3000,
                Oil = 1594,
                Gas = 1862,
                Water = 1832,
                ChokeSize = 76,
                FlowLinePressure = 50,
                SeparatorPressure = 54,
                Frequency = 73,
                MotorVolts = 250,
                MotorCurrent = 48,
            };

            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());

            // save well test
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            // We do NOT want to bypass surface parameter validation
            SystemSettingDTO systemSetting = SettingService.GetSystemSettingByName(SettingServiceStringConstants.BYPASS_SURFACE_PARAMETER_VALIDATION);
            SettingService.SaveSystemSetting(new SystemSettingDTO
            {
                SettingId = systemSetting.Id,
                Setting = systemSetting.Setting,
                NumericValue = 1,
            });

            // ------------ Create well settings that ensure that well test validation will succeed. ------------

            SettingDTO setting = SettingService.GetSettingByName(SettingServiceStringConstants.LFACTOR_MIN_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 0.1,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.LFACTOR_MAX_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 2,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.RESERVOIR_PRESSURE_MIN_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 14.7,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.RESERVOIR_PRESSURE_MAX_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 25000,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.PUMPWEARFACTOR_MIN_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 0.1,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.PUMPWEARFACTOR_MAX_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 2.0,
                WellId = well.Id
            });

            // --------------------------------------------------------------------------------------------

            //int result = WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
            //Assert.AreEqual(1, result, "Failed to save pump wear factor well test.");
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

            // The pump wear factor has already been calculated and saved with the well test. All we need to do it retrieve the test.
            WellTestAndUnitsDTO latestValidTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTest, "Could not retrieve latest well test containing the pump wear factor.");

            WellTestDTO latestValidTestDto = latestValidTest.Value;

            // Based on the well model and the well test used in this test, WellFlo calculates the pump wear factor to be 0.1709.
            // Compare the WellFlo result with the WAMI result to verify the pump wear factor.
            //Assert.AreEqual(0.1709, (double)latestValidTestDto.PumpWearFactor, 0.0005, "Pump wear factor misaatch: Expected: {0} Actual: {1}", 0.1709, latestValidTestDto.PumpWearFactor);
            Assert.AreEqual(0.153572, (double)latestValidTestDto.PumpWearFactor, 0.0005, "Pump wear factor misaatch: Expected: {0} Actual: {1}", 0.153572, latestValidTestDto.PumpWearFactor);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetValidWellTestHeadersByWellId_BadTest()
        {
            //pick up the right model file
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("GL-01-Base.wflx", WellTypeId.GLift, new ModelFileOptionDTO() { CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);
            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            //add new wellTestData with WellTestQuality.RejectedTest SPTCode
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 9,    // WellTestQuality.RejectedTest
                SPTCodeDescription = "RejectedTest",
                TestDuration = 3,
                Water = 1900,
                WaterGravity = (decimal)1.0239,
                GaugePressure = (decimal)1610
            };

            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(10));
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            //get the newly added (latest) valid well test header
            WellTestHeaderDTO[] latestValidTests = WellTestDataService.GetValidWellTestHeadersByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTests);
            Assert.IsTrue(latestValidTests.Count() == 0);  // Since RejectedTest data will not be returned, count will be 0
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GasLiftAnalysisTest()
        {
            GlWellWithTestData();
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + WellTypeId.GLift.ToString()));
            var myassembly = WellboreComponentService.GetAssemblyByWellId(well.Id.ToString());
            Assert.IsNotNull(myassembly);
            //get the newly added (latest) well test data
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            //Validating Analysis input
            NodalAnalysisInputAndUnitsDTO glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());
            Assert.IsNotNull(glAnalysisInput, "Failed to get Analysis input with the provided test data");
            Assert.IsNotNull(glAnalysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
            Assert.IsNotNull(glAnalysisInput.ModelData, "Model data is not available for the obtained Analysis input");
            Assert.IsNotNull(glAnalysisInput.TestData, "Test data is not available for the obtained Analysis input");
            //Validating AOF and Chokesize
            Assert.IsNotNull(glAnalysisInput.TestData.Value.ChokeSize, "ChokeSize is not available for the obtained Analysis input");
            Assert.IsNotNull(glAnalysisInput.TestData.Value.LiquidAoF, "LiquidAoF is not available for the obtained Analysis input");
            Assert.IsNull(glAnalysisInput.TestData.Value.GasAoF, "GasAoF is available for fluid type well");

            Assert.IsNotNull(glAnalysisInput.ModelData.SolutionNode, "Solution node is not available on modeldata");
            Assert.IsNotNull(glAnalysisInput.ModelData.StartNode, "Start node is not available on modal data");
            Assert.AreNotEqual(glAnalysisInput.ModelData.SolutionNode.Value.Name, glAnalysisInput.ModelData.StartNode.Value.Name, "Start and Solution node cannot be same");
            Assert.AreEqual(3, glAnalysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of Solution nodes are available on Analysis input modal data");
            Assert.AreEqual(3, glAnalysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of Start nodes are available on Analysis input modal data");

            Assert.IsNotNull(glAnalysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
            Assert.IsNotNull(glAnalysisInput.CalibrationData.Value.ProductivityIndex, "ProductivityIndex is not defined in the calibration data");
            Assert.IsNotNull(glAnalysisInput.CalibrationData.Value.ReservoirPressure, "ReservoirPressure is not defined in the calibration data");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageCasingPressure ?? 0), (decimal)Math.Round(glAnalysisInput.TestData.Value.CasingHeadPressure), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual((latestValidTestDataPair.Value.GaugePressure.HasValue ? Math.Round(latestValidTestDataPair.Value.GaugePressure.Value) : 0m), (decimal)Math.Round(glAnalysisInput.TestData.Value.DownholeGaugePressure), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(latestValidTestDataPair.Value.GOR, (glAnalysisInput.TestData.Value.GasOilRatio.HasValue ? (decimal)Math.Round(glAnalysisInput.TestData.Value.GasOilRatio.Value) : 0m), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(latestValidTestDataPair.Value.Gas, (decimal)Math.Round(glAnalysisInput.TestData.Value.GasRate), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)Math.Round(glAnalysisInput.TestData.Value.OilRate), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(latestValidTestDataPair.Value.Id, glAnalysisInput.TestData.Value.Id, "Mismatch between the Provide test data and Analysis input test data");
            //Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.WaterCut), (decimal)Math.Round(glAnalysisInput.TestData.WaterCut), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingPressure.Value), (decimal)Math.Round(glAnalysisInput.TestData.Value.WellHeadPressure), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingTemperature ?? 0.0m), (decimal)Math.Round(glAnalysisInput.TestData.Value.WellHeadTemperature), "Mismatch between the Provide test data and Analysis input test data");

            //Validating the GL Analysis result
            GasLiftAnalysisResultsAndUnitsDTO glAnalysisResult = WellTestDataService.PerformGasLiftAnalysis(glAnalysisInput);
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults, "Unable to get Operating point results after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults.FlowCurves, "Unable to get Flow curves after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults.OperatingPoint, "Unable to get Operating point after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.GasRate);
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.OilRate);
            Assert.AreEqual(latestValidTestDataPair.Value.GOR, (decimal)Math.Round(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.ProducedGOR));
            Assert.AreEqual(latestValidTestDataPair.Value.WaterCut, (decimal)Math.Round(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.WaterCut, 1));
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.WaterRate);

            Assert.IsNotNull(glAnalysisResult.PressureDropResults, "Unable to get Pressure drop results after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.PressureDropResults.SolutionPoint, "Unable to get Solution point results after GL Analysis");
            Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)glAnalysisResult.PressureDropResults.SolutionPoint.Value.OilRate);
            Assert.AreEqual(latestValidTestDataPair.Value.GOR, (decimal)Math.Round(glAnalysisResult.PressureDropResults.SolutionPoint.Value.ProducedGOR));
            Assert.AreEqual(Math.Round(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.Temperature), Math.Round(glAnalysisResult.PressureDropResults.SolutionPoint.Value.Temperature));
            Assert.AreEqual(latestValidTestDataPair.Value.WaterCut, (decimal)glAnalysisResult.PressureDropResults.SolutionPoint.Value.WaterCut);
            Assert.AreEqual(latestValidTestDataPair.Value.Water, (decimal)glAnalysisResult.PressureDropResults.SolutionPoint.Value.WaterRate);

            Assert.IsNotNull(glAnalysisResult.PressureDropResults.GradientCurves.GradientCurves, "Unable to get gradient curves after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.PressureDropResults.GradientCurves.ValveCurves, "Unable to get Valve curves after GL Analysis");
            Assert.AreEqual(glAnalysisInput.ModelData.SolutionNode.Value.MD, Math.Round(glAnalysisResult.PressureDropResults.GradientCurves.MaximumMD));
            //only one active valve
            Assert.AreEqual(1, glAnalysisResult.PressureDropResults.ValveDiagnostics.Values.Count());
            Assert.AreEqual(Math.Round(glAnalysisInput.ModelData.GasLiftData.Value.GasInjectionDepth, 2), glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[0].MD);

            Assert.IsNotNull(glAnalysisResult.WellPerformanceCurves, "Unable to get WellPerformanceCurves after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.WellPerformanceCurves.WellPerformanceCurves, "Unable to get WellPerformanceCurves after GL Analysis");

            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            // -------------- Get well analysis data in US units --------------

            Assert.AreEqual("1/64in", glAnalysisInput.TestData.Units.ChokeSize.UnitKey, "Incorrect US units for ChokeSize:" + glAnalysisInput.TestData.Units.ChokeSize.UnitKey);
            Assert.AreEqual(1, (int)glAnalysisInput.TestData.Units.ChokeSize.Precision, "Incorrect US units precision for ChokeSize:" + glAnalysisInput.TestData.Units.ChokeSize.Precision);

            Assert.AreEqual("STB/d", glAnalysisInput.TestData.Units.LiquidAoF.UnitKey, "Incorrect US units for Liquid AOF:" + glAnalysisInput.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(1, (int)glAnalysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + glAnalysisInput.TestData.Units.LiquidAoF.Precision);

            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            NodalAnalysisInputAndUnitsDTO analysisInput_metric = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());


            Assert.AreEqual("mm", analysisInput_metric.TestData.Units.ChokeSize.UnitKey, "Incorrect metric units for Chokesize:" + analysisInput_metric.TestData.Units.ChokeSize.UnitKey);
            Assert.AreEqual("sm3/d", analysisInput_metric.TestData.Units.LiquidAoF.UnitKey, "Incorrect metric units for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(3, (int)analysisInput_metric.TestData.Units.LiquidAoF.Precision, "Incorrect metric units precision for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.Precision);

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
        }
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GLAOFCheck_Condensate()
        {
            var modelFileName = "GLDHPGCondensate.wflx";
            WellTypeId wellType = WellTypeId.GLift;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("GLWELL_", wellType, WellFluidType.Condensate, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 2,
                SPTCodeDescription = "RepresentativeTest",
                TestDuration = 3,
                Water = 1900,
                ChokeSize = 64,
                GasInjectionRate = 100,
                WaterGravity = (decimal)1.0239,
                //LFactor = 1,
                //ReservoirPressure = 5250,
                //ProductivityIndex = (decimal)1.36,
                GaugePressure = (decimal)1610
            };
            testData.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1));
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testData));

            WellTestAndUnitsDTO validWellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(validWellTest, "Added WellTest is not valid");
            var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());
            Assert.IsNotNull(analysisInput, "Failed to get Analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.TestData.Value.ChokeSize, "ChokeSize is defined in the TestData");
            Assert.IsNull(analysisInput.TestData.Value.LiquidAoF, "LiquidAoF is defined in the TestData");
            Assert.IsNotNull(analysisInput.TestData.Value.GasAoF, "GasAoF is not available for Condensate type well");


            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            // -------------- Get well analysis data in US units --------------
            Assert.AreEqual("STB/d", analysisInput.TestData.Units.LiquidAoF.UnitKey, "Incorrect US units for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.Precision);

            Assert.AreEqual("1/64in", analysisInput.TestData.Units.ChokeSize.UnitKey, "Incorrect US units for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.ChokeSize.Precision, "Incorrect US units precision for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.Precision);

            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            NodalAnalysisInputAndUnitsDTO analysisInput_metric = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());

            Assert.AreEqual("mm", analysisInput_metric.TestData.Units.ChokeSize.UnitKey, "Incorrect metric units for Chokesize:" + analysisInput_metric.TestData.Units.ChokeSize.UnitKey);

            Assert.AreEqual("sm3/d", analysisInput_metric.TestData.Units.LiquidAoF.UnitKey, "Incorrect metric units for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(3, (int)analysisInput_metric.TestData.Units.LiquidAoF.Precision, "Incorrect metric units precision for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.Precision);

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GasLiftGetAnalysisInputDataUsingDailyAverageTest()
        {
            GlWellWithTestData();
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + WellTypeId.GLift.ToString()));

            WellTestAndUnitsDTO wellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(wellTest, "Failed to get well test.");
            var dailyAverage = new WellDailyAverageValueDTO()
            {
                OilRateInferred = (double?)wellTest.Value.Oil,
                WaterRateInferred = (double?)wellTest.Value.Water,
                GasRateInferred = (double?)wellTest.Value.Gas,
                Status = WellDailyAverageDataStatus.Calculated,
                ChokeDiameter = (double?)wellTest.Value.ChokeSize,
                CHP = (double)(wellTest.Value.AverageCasingPressure ?? 0),
                DHPG = (double?)wellTest.Value.GaugePressure,
                Duration = null,
                EndDateTime = wellTest.Value.SampleDate.AddDays(1),
                StartDateTime = wellTest.Value.SampleDate,
                WellId = well.Id,
                WellTestId = wellTest.Value.Id,
            };
            bool result = SurveillanceService.AddUpdateWellDailyAverageData(dailyAverage);
            Assert.IsTrue(result, "Adding daily average record failed.");
            var dailyAverageRecord = SurveillanceService.GetDailyAverages(well.Id.ToString(), (DateTime.Today - TimeSpan.FromDays(30)).ToUniversalTime().ToISO8601(), (DateTime.Today + TimeSpan.FromDays(1)).ToUniversalTime().ToISO8601()).Values.FirstOrDefault();
            Assert.IsNotNull(dailyAverageRecord);
            var record_id = dailyAverageRecord.Id;
            NodalAnalysisInputAndUnitsDTO glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(record_id.ToString(), 1.ToString(), 1.ToString());

            Assert.AreEqual(dailyAverageRecord.OilRateInferred, glAnalysisInput.TestData.Value.OilRate, "Mismatch between the Provide daily average data and Analysis input daily average data");
            Assert.AreEqual(dailyAverageRecord.WaterRateInferred, glAnalysisInput.TestData.Value.WaterRate, "Mismatch between the Provide daily average data and Analysis input daily average data");
            Assert.AreEqual(dailyAverageRecord.GasRateInferred, glAnalysisInput.TestData.Value.GasRate, "Mismatch between the Provide daily average data and Analysis input daily average data");
            Assert.AreEqual(dailyAverageRecord.CHP, glAnalysisInput.TestData.Value.CasingHeadPressure, "Mismatch between the Provide daily average data and Analysis input daily average data");
            Assert.AreEqual(dailyAverageRecord.DHPG, glAnalysisInput.TestData.Value.DownholeGaugePressure, "Mismatch between the Provide daily average data and Analysis input daily average data");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GLPressureDropResults()
        {
            GlWellWithTestData();
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + WellTypeId.GLift.ToString()));
            var myassembly = WellboreComponentService.GetAssemblyByWellId(well.Id.ToString());
            Assert.IsNotNull(myassembly);
            //get the newly added (latest) well test data
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            //Validating PressureDropAnalysis results
            NodalAnalysisInputAndUnitsDTO glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());
            Assert.IsNotNull(glAnalysisInput, "Failed to get Analysis input with the provided test data");
            Assert.IsNotNull(glAnalysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
            Assert.IsNotNull(glAnalysisInput.ModelData, "Model data is not available for the obtained Analysis input");
            Assert.IsNotNull(glAnalysisInput.TestData, "Test data is not available for the obtained Analysis input");

            GasLiftAnalysisResultsAndUnitsDTO glAnalysisResult = WellTestDataService.PerformGasLiftAnalysis(glAnalysisInput);
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults, "Unable to get Operating point results after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults.FlowCurves, "Unable to get Flow curves after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults.OperatingPoint, "Unable to get Operating point after GL Analysis");

            GasLiftPressureDropAnalysisResultsAndUnitsDTO glPressureDropAnalysis = WellTestDataService.PerformGasLiftPressureDrop(glAnalysisInput);
            Assert.IsNotNull(glPressureDropAnalysis);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.GradientCurves.GradientCurves.Values.Count(), glPressureDropAnalysis.GradientCurves.GradientCurves.Values.Count());
            for (int i = 0; i < glPressureDropAnalysis.GradientCurves.GradientCurves.Values.Count(); i++)
            {
                Assert.AreEqual(glAnalysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i].CasingPressure, glPressureDropAnalysis.GradientCurves.GradientCurves.Values[i].CasingPressure);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i].MD, glPressureDropAnalysis.GradientCurves.GradientCurves.Values[i].MD);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i].Temperature, glPressureDropAnalysis.GradientCurves.GradientCurves.Values[i].Temperature);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i].TubingPressure, glPressureDropAnalysis.GradientCurves.GradientCurves.Values[i].TubingPressure);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i].TVD, glPressureDropAnalysis.GradientCurves.GradientCurves.Values[i].TVD);
            }

            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.BottomholePressure, glPressureDropAnalysis.SolutionPoint.Value.BottomholePressure);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.GasRate, glPressureDropAnalysis.SolutionPoint.Value.GasRate);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.InjectionGasRate, glPressureDropAnalysis.SolutionPoint.Value.InjectionGasRate);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.InjectionMD, glPressureDropAnalysis.SolutionPoint.Value.InjectionMD);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.InjectionTVD, glPressureDropAnalysis.SolutionPoint.Value.InjectionTVD);
            Assert.IsNotNull(glPressureDropAnalysis.SolutionPoint.Value.IPRFlowRate);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.LiquidRate, glPressureDropAnalysis.SolutionPoint.Value.LiquidRate);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.OilRate, glPressureDropAnalysis.SolutionPoint.Value.OilRate);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.OperatingPointStability, glPressureDropAnalysis.SolutionPoint.Value.OperatingPointStability);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.OperatingPointStatus, glPressureDropAnalysis.SolutionPoint.Value.OperatingPointStatus);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.Pressure, glPressureDropAnalysis.SolutionPoint.Value.Pressure);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.ProducedCGR, glPressureDropAnalysis.SolutionPoint.Value.ProducedCGR);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.ProducedGLR, glPressureDropAnalysis.SolutionPoint.Value.ProducedGLR);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.ProducedGOR, glPressureDropAnalysis.SolutionPoint.Value.ProducedGOR);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.Temperature, glPressureDropAnalysis.SolutionPoint.Value.Temperature);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.WaterCut, glPressureDropAnalysis.SolutionPoint.Value.WaterCut);
            Assert.AreEqual(glAnalysisResult.PressureDropResults.SolutionPoint.Value.WaterRate, glPressureDropAnalysis.SolutionPoint.Value.WaterRate);

            Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values.Count(), glPressureDropAnalysis.ValveDiagnostics.Values.Count());
            for (int i = 0; i < glPressureDropAnalysis.ValveDiagnostics.Values.Count(); i++)
            {
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].CasingPressure, glPressureDropAnalysis.ValveDiagnostics.Values[i].CasingPressure);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].CasingPressureToOpen, glPressureDropAnalysis.ValveDiagnostics.Values[i].CasingPressureToOpen);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].InjectionGasRate, glPressureDropAnalysis.ValveDiagnostics.Values[i].InjectionGasRate);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].Manufacturer, glPressureDropAnalysis.ValveDiagnostics.Values[i].Manufacturer);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].MD, glPressureDropAnalysis.ValveDiagnostics.Values[i].MD);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].Model, glPressureDropAnalysis.ValveDiagnostics.Values[i].Model);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].PortSize, glPressureDropAnalysis.ValveDiagnostics.Values[i].PortSize);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].PTRO, glPressureDropAnalysis.ValveDiagnostics.Values[i].PTRO);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].Status, glPressureDropAnalysis.ValveDiagnostics.Values[i].Status);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].TBRatio, glPressureDropAnalysis.ValveDiagnostics.Values[i].TBRatio);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].Temperature, glPressureDropAnalysis.ValveDiagnostics.Values[i].Temperature);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].TubingPressure, glPressureDropAnalysis.ValveDiagnostics.Values[i].TubingPressure);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].TubingPressureToOpen, glPressureDropAnalysis.ValveDiagnostics.Values[i].TubingPressureToOpen);
                Assert.AreEqual(glAnalysisResult.PressureDropResults.ValveDiagnostics.Values[i].TVD, glPressureDropAnalysis.ValveDiagnostics.Values[i].TVD);
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GLOperatingPointResults()
        {
            GlWellWithTestData();
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + WellTypeId.GLift.ToString()));
            var myassembly = WellboreComponentService.GetAssemblyByWellId(well.Id.ToString());
            Assert.IsNotNull(myassembly);
            //get the newly added (latest) well test data
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            //Validating Operating point results
            NodalAnalysisInputAndUnitsDTO glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());
            Assert.IsNotNull(glAnalysisInput, "Failed to get Analysis input with the provided test data");
            Assert.IsNotNull(glAnalysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
            Assert.IsNotNull(glAnalysisInput.ModelData, "Model data is not available for the obtained Analysis input");
            Assert.IsNotNull(glAnalysisInput.TestData, "Test data is not available for the obtained Analysis input");

            GasLiftAnalysisResultsAndUnitsDTO glAnalysisResult = WellTestDataService.PerformGasLiftAnalysis(glAnalysisInput);
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults, "Unable to get Operating point results after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults.FlowCurves, "Unable to get Flow curves after GL Analysis");
            Assert.IsNotNull(glAnalysisResult.OperatingPointResults.OperatingPoint, "Unable to get Operating point after GL Analysis");

            GasLiftOperatingPointAnalysisResultsAndUnitsDTO glOperatingPointAnalysis = WellTestDataService.PerformGasLiftOperatingPointAnalysis(glAnalysisInput);
            Assert.IsNotNull(glOperatingPointAnalysis, "Unable to get Operation point Analysis");
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.BubblePointPressure, glOperatingPointAnalysis.OperatingPoint.Value.BubblePointPressure);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.FlowCurves.Values.Count(), glOperatingPointAnalysis.FlowCurves.Values.Count());
            for (int i = 0; i < glOperatingPointAnalysis.FlowCurves.Values.Count(); i++)
            {
                Assert.AreEqual(glAnalysisResult.OperatingPointResults.FlowCurves.Values[i].InflowPressure, glOperatingPointAnalysis.FlowCurves.Values[i].InflowPressure);
                Assert.AreEqual(glAnalysisResult.OperatingPointResults.FlowCurves.Values[i].OilRate, glOperatingPointAnalysis.FlowCurves.Values[i].OilRate);
                Assert.AreEqual(glAnalysisResult.OperatingPointResults.FlowCurves.Values[i].OutflowPressure, glOperatingPointAnalysis.FlowCurves.Values[i].OutflowPressure);
                Assert.AreEqual(glAnalysisResult.OperatingPointResults.FlowCurves.Values[i].Rate, glOperatingPointAnalysis.FlowCurves.Values[i].Rate);
            }
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.MaximumFlowRate, glOperatingPointAnalysis.MaximumFlowRate);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.MaximumOilRate, glOperatingPointAnalysis.MaximumOilRate);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.MaximumPressure, glOperatingPointAnalysis.MaximumPressure);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.BottomholePressure, glOperatingPointAnalysis.OperatingPoint.Value.BottomholePressure);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.GasRate, glOperatingPointAnalysis.OperatingPoint.Value.GasRate);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.InjectionGasRate, glOperatingPointAnalysis.OperatingPoint.Value.InjectionGasRate);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.InjectionMD, glOperatingPointAnalysis.OperatingPoint.Value.InjectionMD);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.InjectionTVD, glOperatingPointAnalysis.OperatingPoint.Value.InjectionTVD);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.IPRFlowRate, glOperatingPointAnalysis.OperatingPoint.Value.IPRFlowRate);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.LiquidRate, glOperatingPointAnalysis.OperatingPoint.Value.LiquidRate);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.OilRate, glOperatingPointAnalysis.OperatingPoint.Value.OilRate);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.OperatingPointStability, glOperatingPointAnalysis.OperatingPoint.Value.OperatingPointStability);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.OperatingPointStatus, glOperatingPointAnalysis.OperatingPoint.Value.OperatingPointStatus);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.Pressure, glOperatingPointAnalysis.OperatingPoint.Value.Pressure);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.ProducedCGR, glOperatingPointAnalysis.OperatingPoint.Value.ProducedCGR);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.ProducedGLR, glOperatingPointAnalysis.OperatingPoint.Value.ProducedGLR);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.ProducedGOR, glOperatingPointAnalysis.OperatingPoint.Value.ProducedGOR);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.Temperature, glOperatingPointAnalysis.OperatingPoint.Value.Temperature);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.WaterCut, glOperatingPointAnalysis.OperatingPoint.Value.WaterCut);
            Assert.AreEqual(glAnalysisResult.OperatingPointResults.OperatingPoint.Value.WaterRate, glOperatingPointAnalysis.OperatingPoint.Value.WaterRate);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void StartNodesAndSolutionNodesTestNonRRL()
        {
            //GasInjection model in test documents not good for tuning
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
             Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } }),
             Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.PI, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
             Tuple.Create("WellfloWaterInjectionExample1.wflx", WellTypeId.WInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.InjectivityIndex, OptionalUpdate = new long[] { ((long)OptionalUpdates.CalculateChokeD_Factor), ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("WellfloGasLiftExampleTuningTrace.WFLX", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
             //Tuple.Create("WellfloGasInjectionExample1.wflx", WellTypeId.GInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
            };
            foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
            {
                int i = 1;
                string model = modelInfo.Item1;
                WellTypeId wellType = modelInfo.Item2;
                ModelFileOptionDTO options = modelInfo.Item3;

                Trace.WriteLine("Testing model: " + model);
                //Create a new well
                WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
                var allWells = WellService.GetAllWells().ToList();
                WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                Assert.IsNotNull(well);
                _wellsToRemove.Add(well);

                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                options.Comment = "CASETest Upload " + modelInfo.Item1;
                modelFile.Options = options;
                modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i);
                modelFile.WellId = well.Id;

                byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                Assert.IsNotNull(fileAsByteArray);
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                Assert.IsNotNull(ModelFileValidationData);
                ModelFileService.AddWellModelFile(modelFile);
                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());

                #region ESP

                if (wellType == WellTypeId.ESP)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "AllocatableTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        PumpIntakePressure = 10000,
                        PumpDischargePressure = 11000,
                        GaugePressure = 12000,
                        Oil = 5000,
                        Gas = 500,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                        Frequency = 20,
                        MotorVolts = 250,
                        MotorCurrent = 48,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());

                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    //get the newly added (latest) well test data
                    var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair);

                    var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                    //check the starting nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.Length == 3);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Layer 1") != null);

                    //check the solution nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.Length == 3);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "New Casing_2") != null);
                }

                #endregion ESP

                #region WaterInjection

                else if (wellType == WellTypeId.WInj)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        GaugePressure = 12000,
                        Oil = 2000,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    //get the newly added (latest) well test data
                    var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair);

                    var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                    //check the starting nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.Length == 2);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Wellhead Gauge") != null);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Noth Sea") != null);

                    //check the solution nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.Length == 2);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Wellhead Gauge") != null);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Casing") != null);
                }

                #endregion WaterInjection

                #region GasInjection

                //else if (wellType == WellTypeId.GInj)
                //{
                //    //add new wellTestData
                //    WellTestDTO testDataDTO = new WellTestDTO()
                //    {
                //        WellId = well.Id,
                //        SPTCodeDescription = "RepresentativeTest",
                //        AverageTubingPressure = 1600,
                //        AverageTubingTemperature = 65,
                //        GaugePressure = 12000,
                //        Oil = 1000,
                //        Water = 500,
                //        Gas = 2000,
                //        GasInjectionRate = 1200,
                //        ProductivityIndex = 5.3m,
                //        ChokeSize = 50,
                //        FlowLinePressure = 50,
                //    };

                //    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                //    // add wellTest with new non RRL properties
                //    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                //    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                //    //get the newly added (latest) well test data
                //    var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                //    Assert.IsNotNull(latestValidTestDataPair);

                //    var analysisInput = WellTestDataService.GetAnalysisInputData(latestValidTestDataPair.Value.Id.ToString());

                //    //check the starting nodes have 3 node element and the name of each node
                //    Assert.IsTrue(analysisInput.ModelData.StartNodes.Length == 2);
                //    Assert.IsTrue(analysisInput.ModelData.StartNodes.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                //    //Assert.IsTrue(analysisInput.ModelData.StartNodes.FirstOrDefault(en => en.Name == "Gauge Carrier") != null);
                //    Assert.IsTrue(analysisInput.ModelData.StartNodes.FirstOrDefault(en => en.Name == "Layer 1") != null);

                //    //check the solution nodes have 3 node element and the name of each node
                //    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Length == 2);
                //    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                //    //Assert.IsTrue(analysisInput.ModelData.SolutionNodes.FirstOrDefault(en => en.Name == "Gauge Carrier") != null);
                //    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.FirstOrDefault(en => en.Name == "Casing") != null);
                //}

                #endregion GasInjection

                #region GasLift

                else if (wellType == WellTypeId.GLift)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        AverageCasingPressure = 1000,
                        GasInjectionRate = 1000,
                        FlowLinePressure = 50,
                        SeparatorPressure = 30,
                        GaugePressure = 12000,
                        Oil = (decimal)1497.8,
                        Gas = 500,
                        Water = (decimal)2246.6,
                        ChokeSize = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    //get the newly added (latest) well test data
                    var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair);

                    var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());
                    //check the starting nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.Length == 3);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Gauge Carrier") != null);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Layer 1") != null);

                    //check the solution nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.Length == 3);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Gauge Carrier") != null);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Casing") != null);
                }

                #endregion GasLift

                #region NF

                else if (wellType == WellTypeId.NF)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        GaugePressure = 12000,
                        Oil = 5000,
                        Gas = 500,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    //get the newly added (latest) well test data
                    var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair);

                    var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                    //check the starting nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.Length == 2);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Layer 1") != null);

                    //check the solution nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.Length == 2);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Casing") != null);
                }

                #endregion NF
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void VelocityCurveVerification()
        {
            //GasInjection model in test documents not good for tuning
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO, string>[] models = {
               //Tuple.Create("ESPexample.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } },"ESPWELL_"),
                Tuple.Create("GL_BlackOil.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } },"GLWELL_"),
               // Tuple.Create("GL_BlackOil.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),

            };
            foreach (Tuple<string, WellTypeId, ModelFileOptionDTO, string> modelInfo in models)
            {
                string facilityId = GetFacilityId(modelInfo.Item4, 1);

                string model = modelInfo.Item1;
                WellTypeId wellType = modelInfo.Item2;
                ModelFileOptionDTO options = modelInfo.Item3;

                Trace.WriteLine("Testing model: " + model);
                //Create a new well
                WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), FacilityId = facilityId, DataConnection = GetDefaultCygNetDataConnection(), CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
                var allWells = WellService.GetAllWells().ToList();
                WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                Assert.IsNotNull(well);
                _wellsToRemove.Add(well);

                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                options.Comment = "CASETest Upload " + modelInfo.Item1;
                modelFile.Options = options;
                modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(2);
                modelFile.WellId = well.Id;

                byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                Assert.IsNotNull(fileAsByteArray);
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                Assert.IsNotNull(ModelFileValidationData);
                ModelFileService.AddWellModelFile(modelFile);
                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());

                #region ESP

                if (wellType == WellTypeId.ESP)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "AllocatableTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        PumpIntakePressure = 10000,
                        PumpDischargePressure = 11000,
                        GaugePressure = 12000,
                        Oil = 5000,
                        Gas = 500,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                        Frequency = 20,
                        MotorVolts = 250,
                        MotorCurrent = 48,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());

                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    //get the newly added (latest) well test data
                    var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair);

                    var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                    //check the starting nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.Length == 3);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Layer 1") != null);

                    //check the solution nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.Length == 3);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "New Casing_2") != null);
                }

                #endregion ESP

                #region GasLift

                else if (wellType == WellTypeId.GLift)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 96,
                        AverageTubingTemperature = 100,
                        AverageCasingPressure = 1271,
                        GasInjectionRate = 1200,
                        Oil = (decimal)599.2,
                        Gas = 1020,
                        Water = (decimal)732,
                        TestDuration = 24
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    //get the newly added (latest) well test data
                    var latestValidTestDataPair_US = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair_US);

                    var glGasVelocityCurves = new List<Tuple<double, double, double, double>>
                    {
                        Tuple.Create(23.33, 33.97, 329.05, 329.05),
                        Tuple.Create(21.95,32.91, 1369.09, 1365.21),
                        Tuple.Create(19.1, 25.79, 2291.83, 2278.25),
                        Tuple.Create(16.74, 20.61, 3270.73, 3246.87),
                        Tuple.Create(17.78, 17.61, 4189.7, 3965.31),
                        Tuple.Create(16.47, 15.58, 5084.32, 4611.95),
                        Tuple.Create(15.12, 13.67, 6145.81, 5379.21),
                        Tuple.Create(14.01, 12.17,7118.2, 6080.43),
                        Tuple.Create(12.93, 10.88, 8271.21, 6898.55),
                        Tuple.Create(11.99, 9.78, 9417.87, 7712.18),
                        Tuple.Create(10.15, 4.73, 10503.14, 8524.68),
                        Tuple.Create(9.18, 4.24, 11561.25, 9340.07),
                        Tuple.Create(8.32, 3.58, 12677.54, 10149.69),
                        Tuple.Create(7.69, 3.32,13665.93, 10826.14),
                        Tuple.Create(7.29, 3.15, 14497.75,Convert.ToDouble(11376)),
                        Tuple.Create(6.86, 1.52, Convert.ToDouble(15413), 11967.27)
                    };

                    var glAnalysisInput_US = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair_US.Value.Id.ToString());
                    GasLiftOperatingPointAnalysisResultsAndUnitsDTO glOperatingPointAnalysis = WellTestDataService.PerformGasLiftOperatingPointAnalysis(glAnalysisInput_US);
                    Trace.WriteLine("Verifying GL Operating Point Analysis API response for Well Test when Unit system is in US ");
                    Assert.AreEqual(15413, glOperatingPointAnalysis.GasVelocityCurves.MaximumMD);
                    Assert.AreEqual(11967.27, glOperatingPointAnalysis.GasVelocityCurves.MaximumTVD);
                    Assert.AreEqual(39.84, glOperatingPointAnalysis.GasVelocityCurves.MaximumVelocity);
                    Assert.AreEqual(1918, glOperatingPointAnalysis.MaximumFlowRate);
                    Assert.AreEqual(0, glOperatingPointAnalysis.MaximumGasRate);
                    Assert.AreEqual(863.3, glOperatingPointAnalysis.MaximumOilRate);
                    Assert.AreEqual(5520.94, glOperatingPointAnalysis.MaximumPressure);
                    VelocityCurvePointsValidation(glGasVelocityCurves, glOperatingPointAnalysis.GasVelocityCurves, 5, "US");

                    Trace.WriteLine("Verifying GL Pressure Drop Analysis API response for Well Test when Unit system is in US ");
                    GasLiftPressureDropAnalysisResultsAndUnitsDTO glPressureDropAnalysis = WellTestDataService.PerformGasLiftPressureDrop(glAnalysisInput_US);
                    VelocityCurvePointsValidation(glGasVelocityCurves, glPressureDropAnalysis.GasVelocityCurves, 5, "US");

                    ChangeUnitSystemUserSetting("Metric");
                    var latestValidTestDataPair_Metric = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair_US);
                    var glAnalysisInput_Metric = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair_Metric.Value.Id.ToString());
                    glOperatingPointAnalysis = WellTestDataService.PerformGasLiftOperatingPointAnalysis(glAnalysisInput_Metric);
                    Trace.WriteLine("Verifying GL Operating Point Analysis API response for Well Test when Unit system is in Metric ");
                    VelocityCurvePointsValidation(glGasVelocityCurves, glOperatingPointAnalysis.GasVelocityCurves, 5, "Metric");

                    Trace.WriteLine("Verifying GL Pressure Drop Analysis API response for Well Test when Unit system is in Metric ");
                    glPressureDropAnalysis = WellTestDataService.PerformGasLiftPressureDrop(glAnalysisInput_Metric);
                    VelocityCurvePointsValidation(glGasVelocityCurves, glPressureDropAnalysis.GasVelocityCurves, 5, "Metric");
                }

                #endregion GasLift

                #region NF

                else if (wellType == WellTypeId.NF)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        GaugePressure = 12000,
                        Oil = 5000,
                        Gas = 500,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    //get the newly added (latest) well test data
                    var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair);

                    var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                    //check the starting nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.Length == 2);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.StartNodes.Values.FirstOrDefault(en => en.Name == "Layer 1") != null);

                    //check the solution nodes have 3 node element and the name of each node
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.Length == 2);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Xmas Tree") != null);
                    Assert.IsTrue(analysisInput.ModelData.SolutionNodes.Values.FirstOrDefault(en => en.Name == "Casing") != null);
                }

                #endregion NF
            }
        }


        public void VelocityCurvePointsValidation(List<Tuple<double, double, double, double>> ExpectedGLVelocityCurve, GasVelocityCurvesAndUnitsDTO ActualGLVelocityCurve, int Interval, string Unit = "US")
        {
            GasVelocityCurvePointDTO[] GasVelocityCurvePoints = ActualGLVelocityCurve.GasVelocityCurves.Values;

            GasVelocityCurvePointUnitsDTO units = ActualGLVelocityCurve.GasVelocityCurves.Units;
            Assert.AreEqual(Unit == "US" ? "ft/s" : "m/s", units.GasCriticalVelocity.UnitKey);
            Assert.AreEqual(Unit == "US" ? "ft/s" : "m/s", units.GasInsituVelocity.UnitKey);
            Assert.AreEqual(Unit == "US" ? "ft" : "m", units.MD.UnitKey);
            Assert.AreEqual(Unit == "US" ? "ft" : "m", units.TVD.UnitKey);

            int k = 0;
            int j = 0;
            while (k != ExpectedGLVelocityCurve.Count)
            {
                Assert.AreEqual(ExpectedGLVelocityCurve.ElementAt(k).Item1 * (Unit == "US" ? 1 : 0.3048), GasVelocityCurvePoints[j].GasCriticalVelocity ?? 0, 0.02);
                Trace.WriteLine("Expected GasCriticalVelocity " + ExpectedGLVelocityCurve.ElementAt(k).Item1 * (Unit == "US" ? 1 : 0.05));
                Trace.WriteLine("Actual GasCriticalVelocity " + GasVelocityCurvePoints[j].GasCriticalVelocity);
                Assert.AreEqual(ExpectedGLVelocityCurve.ElementAt(k).Item2 * (Unit == "US" ? 1 : 0.3048), GasVelocityCurvePoints[j].GasInsituVelocity ?? 0, 0.02);
                Trace.WriteLine("Expected GasInsituVelocity " + ExpectedGLVelocityCurve.ElementAt(k).Item2 * (Unit == "US" ? 1 : 0.05));
                Trace.WriteLine("Actual GasInsituVelocity " + GasVelocityCurvePoints[j].GasInsituVelocity);
                Assert.AreEqual(ExpectedGLVelocityCurve.ElementAt(k).Item3 * (Unit == "US" ? 1 : 0.3048), GasVelocityCurvePoints[j].MD, 0.02);
                Trace.WriteLine("Expected MD " + ExpectedGLVelocityCurve.ElementAt(k).Item3 * (Unit == "US" ? 1 : 0.05));
                Trace.WriteLine("Actual MD " + GasVelocityCurvePoints[j].MD);
                Assert.AreEqual(ExpectedGLVelocityCurve.ElementAt(k).Item4 * (Unit == "US" ? 1 : 0.3048), GasVelocityCurvePoints[j].TVD, 0.02);
                Trace.WriteLine("Expected TVD " + ExpectedGLVelocityCurve.ElementAt(k).Item4 * (Unit == "US" ? 1 : 0.05));
                Trace.WriteLine("Actual TVD " + GasVelocityCurvePoints[j].TVD);
                Trace.WriteLine("");

                k = k + 1;
                j = j + Interval;
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WellTestTrend()
        {
            AddWell("RPOC_");
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName));

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add new wellTestData
            for (int i = 0; i < 15; i++)
            {
                //add new wellTestData
                var testDataDTO = new WellTestDTO
                {
                    WellId = well.Id,
                    AverageCasingPressure = 1,
                    AverageFluidAbovePump = 1,
                    AverageTubingPressure = 90,
                    AverageTubingTemperature = 100,
                    Gas = 0,
                    GasGravity = 0,
                    Oil = 83,
                    OilGravity = 25,
                    PumpEfficiency = 0,
                    PumpIntakePressure = 100,
                    PumpingHours = 10,
                    //SPTCode = 1,
                    SPTCodeDescription = WellTestQuality.RepresentativeTest.ToString(),
                    StrokePerMinute = 0,
                    TestDuration = 3,
                    Water = 75,
                    WaterGravity = 1.010M,
                };
                testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i + 10));
                WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            }
            //Get all valid well tests
            WellTestDTO[] addedWelltests = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
            Assert.AreEqual(15, addedWelltests.Count(), "Mismatch in added well tests");

            WellTestTrendDTO[] testTrends = WellTestDataService.GetWellTestTrend(well.Id.ToString());
            Assert.AreEqual(15, testTrends.Count(), "Mismatch between the count of well tests and well test trends data");
            for (int i = 0; i < testTrends.Count(); i++)
            {
                //Assert.AreEqual(addedWelltests[i].SampleDate, testTrends[i].SampleDate);
                Assert.AreEqual(Decimal.Round(addedWelltests[i].Gas.Value).ToString(), (testTrends[i].Gas.HasValue ? Decimal.Round(testTrends[i].Gas.Value) : 0).ToString());
                Assert.AreEqual(Decimal.Round(addedWelltests[i].Oil.Value).ToString(), (testTrends[i].Oil.HasValue ? Decimal.Round(testTrends[i].Oil.Value) : 0).ToString());
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void LFactorTuningGLTest()
        {
            //GasInjection model in test documents not good for tuning
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
            Tuple.Create("GasLift-LFactor1.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } }),
            Tuple.Create("GasLift-LFactor2.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.PIAndLFactor, OptionalUpdate = new long[] {  } }),
            };

            foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
            {
                int i = 1;
                string model = modelInfo.Item1;
                WellTypeId wellType = modelInfo.Item2;
                ModelFileOptionDTO options = modelInfo.Item3;

                Trace.WriteLine("Testing model: " + model);
                //Create a new well
                WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString() + modelInfo.Item3.OptionalUpdate.Length, CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
                var allWells = WellService.GetAllWells().ToList();
                WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString() + modelInfo.Item3.OptionalUpdate.Length));
                Assert.IsNotNull(well);
                _wellsToRemove.Add(well);

                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                options.Comment = "CASETest Upload " + modelInfo.Item1;
                modelFile.Options = options;
                modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i);
                modelFile.WellId = well.Id;

                byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                Assert.IsNotNull(fileAsByteArray);
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                Assert.IsNotNull(ModelFileValidationData);
                ModelFileService.AddWellModelFile(modelFile);
                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());

                #region GasLift

                if (wellType == WellTypeId.GLift)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        AverageCasingPressure = 1000,
                        GasInjectionRate = 1000,
                        FlowLinePressure = 50,
                        SeparatorPressure = 30,
                        GaugePressure = 12000,
                        Oil = (decimal)1497.8,
                        Gas = 500,
                        Water = (decimal)2246.6,
                        ChokeSize = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    //get the newly added (latest) well test data
                    var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair);

                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    // var analysisInput = WellTestDataService.GetAnalysisInputData(latestValidTestDataPair.Value.Id.ToString());
                    Assert.IsNotNull(testDataDTOCheck.LFactor, "L Factor tuning not occurred");
                    if (modelInfo.Item1.Contains("GasLift-LFactor1"))
                    {
                        Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_LFATCOR_TOO_LOW, testDataDTOCheck.Status);  // This should change when we fix single LFac Calibration
                    }
                    if (modelInfo.Item1.Contains("GasLift-LFactor2"))
                    {
                        Assert.AreEqual(WellTestStatus.TUNING_IPR_TUNING_FAILED, testDataDTOCheck.Status);
                    }
                }

                #endregion GasLift

                //TODO other lift types
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void TuneWellTests()
        {
            SystemSettingDTO bypassSurfaceParameterValidationSetting = SettingService.GetSystemSettingByName(SettingServiceStringConstants.BYPASS_SURFACE_PARAMETER_VALIDATION);
            bypassSurfaceParameterValidationSetting.NumericValue = 1;
            SettingService.SaveSystemSetting(bypassSurfaceParameterValidationSetting);
            bypassSurfaceParameterValidationSetting = SettingService.GetSystemSettingByName(bypassSurfaceParameterValidationSetting.Setting.Name);
            Assert.AreEqual(1, bypassSurfaceParameterValidationSetting.NumericValue);
            SetValuesInSystemSettings(SettingServiceStringConstants.TUNE_WELL_TEST_FOR_INVALID_SURFACE_PARAMETERS, "1");
            try
            {
                //GasInjection model in test documents not good for tuning
                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
             Tuple.Create("GasLift-LFactor2.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressureAndLFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } }),
            };
                foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
                {
                    string model = modelInfo.Item1;
                    WellTypeId wellType = modelInfo.Item2;
                    ModelFileOptionDTO options = modelInfo.Item3;

                    Trace.WriteLine("Testing model: " + model);
                    //Create a new well
                    WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddDays(-20), WellType = wellType }) });
                    var allWells = WellService.GetAllWells().ToList();
                    WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                    Assert.IsNotNull(well);
                    _wellsToRemove.Add(well);

                    ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                    options.Comment = "CASETest Upload " + modelInfo.Item1;
                    modelFile.Options = options;
                    modelFile.ApplicableDate = DateTime.Today.AddDays(-15).ToUniversalTime();
                    modelFile.WellId = well.Id;

                    byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                    Assert.IsNotNull(fileAsByteArray);
                    modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                    Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                    ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                    Assert.IsNotNull(ModelFileValidationData);
                    ModelFileService.AddWellModelFile(modelFile);
                    ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                    Assert.IsNotNull(newModelFile);
                    _modelFilesToRemove.Add(newModelFile.Id.ToString());

                    //add new wellTestData 1, 2, 3
                    WellTestDTO testDataDTO1 = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 200,
                        AverageTubingTemperature = 100,
                        AverageCasingPressure = 1000,
                        GasInjectionRate = 1000,
                        FlowLinePressure = 50,
                        SeparatorPressure = 30,
                        GaugePressure = 2100,
                        Oil = (decimal)1497.8,
                        Gas = 750,
                        Water = (decimal)2246.6,
                        ChokeSize = 5,
                    };

                    testDataDTO1.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestAndUnitsDTO WellTestAndUnits = new WellTestAndUnitsDTO();
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO1;
                    WellTestDataService.SaveWellTest(WellTestAndUnits);

                    WellTestDTO testDataDTO2 = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 210,
                        AverageTubingTemperature = 110,
                        AverageCasingPressure = 1010,
                        GasInjectionRate = 1010,
                        FlowLinePressure = 50,
                        SeparatorPressure = 30,
                        GaugePressure = 2200,
                        Oil = (decimal)1397.8,
                        Gas = 755,
                        Water = (decimal)2346.6,
                        ChokeSize = 5,
                    };

                    testDataDTO2.SampleDate = (DateTime.Today.AddDays(-1).ToUniversalTime());
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO2;
                    WellTestDataService.SaveWellTest(WellTestAndUnits);

                    WellTestDTO testDataDTO3 = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 220,
                        AverageTubingTemperature = 120,
                        AverageCasingPressure = 1200,
                        GasInjectionRate = 1200,
                        FlowLinePressure = 50,
                        SeparatorPressure = 30,
                        GaugePressure = 2300,
                        Oil = (decimal)1197.8,
                        Gas = 758,
                        Water = (decimal)2146.6,
                        ChokeSize = 5,
                    };

                    testDataDTO3.SampleDate = (DateTime.Today.AddDays(-2).ToUniversalTime());
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO3;
                    WellTestDataService.SaveWellTest(WellTestAndUnits);

                    WellTestDTO[] allTunedTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                    decimal? l1 = allTunedTests[0].LFactor;
                    decimal? l2 = allTunedTests[1].LFactor;
                    decimal? l3 = allTunedTests[2].LFactor;
                    for (int i = 0; i < allTunedTests.Length; i++)
                    {
                        allTunedTests[i].LFactor = 0;
                        WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, allTunedTests[i]));
                        allTunedTests[i].Status = WellTestStatus.TUNING_NOT_COMPLETE;
                        WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, allTunedTests[i]));
                    }

                    WellTestDataService.TuneWellTests(well.Id.ToString());

                    WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                    Assert.AreEqual(l1, allTunedAgainTests[0].LFactor);
                    Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_RESERVOIR_PRESSURE_TOO_HIGH, allTunedAgainTests[0].Status);
                    Assert.AreEqual(l2, allTunedAgainTests[1].LFactor);
                    Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_RESERVOIR_PRESSURE_TOO_HIGH, allTunedAgainTests[1].Status);
                    Assert.AreEqual(l3, allTunedAgainTests[2].LFactor);
                    Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_LFATCOR_TOO_HIGH, allTunedAgainTests[2].Status);

                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                }
            }
            finally
            {
                bypassSurfaceParameterValidationSetting.NumericValue = 1;
                SettingService.SaveSystemSetting(bypassSurfaceParameterValidationSetting);
                SetValuesInSystemSettings(SettingServiceStringConstants.TUNE_WELL_TEST_FOR_INVALID_SURFACE_PARAMETERS, "0");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void TuneESPWellTestTest()
        {
            // This is the path to the  ESP example well model in the codebase.
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP,
                new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.ReservoirPressure,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.CalculateChokeD_Factor
                    }
                });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = "ESPTestWell3" + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            WellDTO newWell = WellService.GetWellByName("ESPTestWell3" + wellType.ToString());
            Assert.IsNotNull(newWell);
            _wellsToRemove.Add(newWell);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO();

            options.Comment = "Testing 1 - 2 - 3 ..." + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(2);
            modelFile.WellId = newWell.Id;

            byte[] fileAsByteArray = GetByteArray(path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File is not an ESP model file.");
            ModelFileValidationDataDTO modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(modelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            WellTestDTO testDTO = new WellTestDTO
            {
                WellId = newWell.Id,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 100,
                AverageTubingTemperature = 101,
                GaugePressure = 104,
                Oil = 108,
                Gas = 109,
                Water = 110,
                ChokeSize = 107,
                FlowLinePressure = 105,
                SeparatorPressure = 106,
                Frequency = 60,
                MotorVolts = 450,
                MotorCurrent = 55,
                SampleDate = DateTime.Today.ToUniversalTime()
            };

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(newWell.Id.ToString()).Units;
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDTO));

            WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(newWell.Id.ToString());
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void SetManualPIOnTheFlyTest()
        {
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO>[] models =
            {
                Tuple.Create("GasLift_ProductionTestData.wflx", WellTypeId.GLift, new ModelFileOptionDTO { CalibrationMethod = CalibrationMethodId.PI, OptionalUpdate = new[] {(long) OptionalUpdates.UpdateWCT_WGR, (long) OptionalUpdates.CalculateChokeD_Factor}}),
            };

            foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
            {
                var model = modelInfo.Item1;
                var wellType = modelInfo.Item2;
                var options = modelInfo.Item3;

                Trace.WriteLine("Testing model: " + model);

                //Create a new well
                WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO { Name = DefaultWellName + wellType, CommissionDate = DateTime.Today.AddDays(-30), WellType = wellType }) });
                var wells = WellService.GetAllWells().ToList();
                var well = wells.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                Assert.IsNotNull(well);
                _wellsToRemove.Add(well);

                var modelFile = new ModelFileBase64DTO();
                options.Comment = "CASETest Upload " + modelInfo.Item1;
                modelFile.Options = options;
                modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(2);
                modelFile.WellId = well.Id;

                byte[] fileAsByteArray = GetByteArray(path, modelInfo.Item1);
                Assert.IsNotNull(fileAsByteArray);
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");

                var modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                Assert.IsNotNull(modelFileValidationData);
                ModelFileService.AddWellModelFile(modelFile);

                var newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());

                //add new welltest data
                var test = new WellTestDTO
                {
                    WellId = well.Id,
                    SPTCodeDescription = "RepresentativeTest",
                    AverageTubingPressure = 200,
                    AverageTubingTemperature = 100,
                    AverageCasingPressure = 1000,
                    GasInjectionRate = 1000,
                    Oil = (decimal)1497.8,
                    Gas = 1750,
                    Water = (decimal)2246.6,
                    GasGravity = 0.92m,
                    WaterGravity = 1.0216m,
                    SampleDate = (DateTime.Today.ToUniversalTime()),
                };

                // add wellTest with new non RRL properties
                var units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, test));

                //get the newly added (latest) well test data
                var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                Assert.IsNotNull(latestValidTestDataPair);

                Assert.AreEqual(3.1401, Convert.ToDouble(latestValidTestDataPair.Value.ProductivityIndex), 0.005);
            }
        }

        /// <summary>
        /// This method is intended to test the results of an ESP analysis against a known set of outputs obtained using the same inputs, but
        /// executed from the client. The known set of outputs make up the first parameter of an Assert (we have to assume that they are correct),
        /// while the results from the test make up the second parameter.
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ESPWellAndPumpPerformanceCurveTests()
        {
            // This is the path to the  ESP example well model in the codebase.
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP,
                new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.LFactor,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.CalculateChokeD_Factor
                    }
                });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = "ESPTestWell3" + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            WellDTO newWell = WellService.GetWellByName("ESPTestWell3" + wellType.ToString());
            Assert.IsNotNull(newWell);
            _wellsToRemove.Add(newWell);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO();

            options.Comment = "Testing 1 - 2 - 3 ..." + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = newWell.Id;

            byte[] fileAsByteArray = GetByteArray(path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File is not an ESP model file.");
            ModelFileValidationDataDTO modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(modelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());
            // NOTE: If you change anything in the following well test, it is very likely that this integration test will fail
            //       because the comparisons we do after the analysis assume that this well test was used for the analysis.
            WellTestDTO testDTO = new WellTestDTO
            {
                WellId = newWell.Id,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 100,
                AverageTubingTemperature = 101,
                AverageCasingPressure = 0,
                GaugePressure = 104,
                Oil = 108,
                Gas = 109,
                Water = 110,
                ChokeSize = 107,
                FlowLinePressure = 105,
                SeparatorPressure = 106,
                Frequency = 60,
                MotorVolts = 450,
                MotorCurrent = 55,
                SampleDate = DateTime.Today.ToUniversalTime()
            };

            // Add the well test record to the database.
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(newWell.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDTO));

            // Get it back out and use it to load the analysis inputs (?)
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(newWell.Id.ToString());
            NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available in the analysis input");

            Assert.IsNotNull(analysisInput.ModelData.SolutionNode, "Solution node is not available in the model data");
            Assert.IsNotNull(analysisInput.ModelData.StartNode, "Start node is not available in the modal data");
            Assert.AreNotEqual(analysisInput.ModelData.SolutionNode.Value.Name, analysisInput.ModelData.StartNode.Value.Name, "Start and solution node cannot be the same");
            Assert.AreEqual(3, analysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of solution nodes are available in analysis input modal data");
            Assert.AreEqual(3, analysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of atart nodes are available in analysis input modal data");

            Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ProductivityIndex, "Productivity index is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageCasingPressure ?? 0, 3), (decimal)Math.Round(analysisInput.TestData.Value.CasingHeadPressure, 3), "Mismatch between the provided average casing pressure value and the analysis input test value");
            Assert.AreEqual((latestValidTestDataPair.Value.GaugePressure.HasValue ? Math.Round(latestValidTestDataPair.Value.GaugePressure.Value, 3) : 0m), (decimal)Math.Round(analysisInput.TestData.Value.DownholeGaugePressure, 3), "Mismatch between the provided gauge pressure value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.GOR.Value, 3), analysisInput.TestData.Value.GasOilRatio.HasValue ? (decimal)Math.Round(analysisInput.TestData.Value.GasOilRatio.Value, 3) : 0m, "Mismatch between the provided GOR value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.Gas.Value, 3), (decimal)Math.Round(analysisInput.TestData.Value.GasRate, 3), "Mismatch between the provided gas value and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)Math.Round(analysisInput.TestData.Value.OilRate), "Mismatch between the provided oil and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Id, analysisInput.TestData.Value.Id, "Mismatch between the provided ID and analysis input test ID");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.WaterCut.Value), (decimal)Math.Round(analysisInput.TestData.Value.WaterCut), "Mismatch between the provided water cut value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingPressure.Value), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadPressure), "Mismatch between the provided average tubing pressure value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingTemperature ?? 0.0m), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadTemperature), "Mismatch between the provided average tubing temperature value and analysis input test value");

            // Run the ESP analysis
            ESPAnalysisResultsAndUnitsDTO analysisResult = WellTestDataService.PerformESPAnalysis(analysisInput);
            Assert.IsNotNull(analysisResult, "ESP Analyis failed to return results");

            //                                                  ********************* WELL PERFORMANCE *********************

            Assert.IsFalse(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].IsInjectionWell, "Well is an injection well. Cannot continue");
            Assert.IsFalse(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].IsLiquid, "Well is liquid. Cannot continue");

            Assert.AreEqual(2818.135, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].MaximumGasProduced, 2), 0.05, "Mismatch in expected well performance curve 'maximum gas produced' and ESP analysis value");
            Assert.AreEqual(5636.270, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].MaximumLiquidProduced, 2), 0.05, "Mismatch in expected well performance curve 'maximum liquid produced' and ESP analysis value");
            Assert.AreEqual(2792.281, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].MaximumOilProduced, 2), 0.05, "Mismatch in expected well performance curve 'maximum oil produced' and ESP analysis value");
            Assert.AreEqual(3167.04, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].MaximumWellHeadPressure, 2), 0.05, "Mismatch in expected well performance curve 'maximum well head pressure' and ESP analysis value");
            Assert.AreEqual(60, Math.Round(Convert.ToDouble(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].OperatingFrequency.Value), 2), 0.05, "Mismatch in expected well performance curve 'frequency' and ESP analysis value");

            //                                                ********************* WELL PERFORMANCE CURVE *********************

            // Check the expected point values against the ESP analysis values

            Assert.AreEqual(0, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[0].GasProduced.Value, 2), 0.05, "Mismatch at element 0 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(0, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[0].LiquidProduced.Value, 2), 0.05, "Mismatch at element 0 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(0, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[0].OilProduced.Value, 2), 0.05, "Mismatch at element 0 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(3167.04, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[0].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 0 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(0, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[1].GasProduced.Value, 2), 0.05, "Mismatch at element 1 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(0, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[1].LiquidProduced.Value, 2), 0.05, "Mismatch at element 1 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(0, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[1].OilProduced.Value, 2), 0.05, "Mismatch at element 1 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(3167.04, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[1].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 1 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(231.380, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[2].GasProduced.Value, 2), 0.05, "Mismatch at element 2 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(462.760, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[2].LiquidProduced.Value, 2), 0.05, "Mismatch at element 2 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(229.257, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[2].OilProduced.Value, 2), 0.05, "Mismatch at element 2 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(2921.779, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[2].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 2 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(462.760, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[3].GasProduced.Value, 2), 0.05, "Mismatch at element 3 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(925.520, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[3].LiquidProduced.Value, 2), 0.05, "Mismatch at element 3 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(458.514, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[3].OilProduced.Value, 2), 0.05, "Mismatch at element 3 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(2764.429, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[3].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 3 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(694.140, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[4].GasProduced.Value, 2), 0.05, "Mismatch at element 4 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(1388.280, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[4].LiquidProduced.Value, 2), 0.5, "Mismatch at element 4 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(687.771, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[4].OilProduced.Value, 2), 0.05, "Mismatch at element 4 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(2567.671, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[4].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 4 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(925.520, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[5].GasProduced.Value, 2), 0.05, "Mismatch at element 5 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(1851.1, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[5].LiquidProduced.Value, 2), 0.05, "Mismatch at element 5 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(917.0, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[5].OilProduced.Value, 2), 0.05, "Mismatch at element 5 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(2360.94, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[5].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 5 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(1156.91, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[6].GasProduced.Value, 2), 0.05, "Mismatch at element 6 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(2313.8, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[6].LiquidProduced.Value, 2), 0.05, "Mismatch at element 6 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(1146.3, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[6].OilProduced.Value, 2), 0.05, "Mismatch at element 6 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(2135.28, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[6].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 6 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(1388.29, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[7].GasProduced.Value, 2), 0.05, "Mismatch at element 7 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(2776.6, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[7].LiquidProduced.Value, 2), 0.05, "Mismatch at element 7 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(1375.6, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[7].OilProduced.Value, 2), 0.05, "Mismatch at element 7 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(1893.54, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[7].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 7 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(1619.67, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[8].GasProduced.Value, 2), 0.05, "Mismatch at element 8 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(3239.30, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[8].LiquidProduced.Value, 2), 0.05, "Mismatch at element 8 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(1604.80, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[8].OilProduced.Value, 2), 0.05, "Mismatch at element 8 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(1606.07, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[8].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 8 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(1851.05, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[9].GasProduced.Value, 2), 0.05, "Mismatch at element 9 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(3702.1, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[9].LiquidProduced.Value, 2), 0.05, "Mismatch at element 9 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(1834.1, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[9].OilProduced.Value, 2), 0.05, "Mismatch at element 9 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(1275.11, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[9].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 9 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(2082.43, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[10].GasProduced.Value, 2), 0.05, "Mismatch at element 10 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(4164.9, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[10].LiquidProduced.Value, 2), 0.05, "Mismatch at element 10 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(2063.3, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[10].OilProduced.Value, 2), 0.05, "Mismatch at element 10 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(900.19, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[10].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 10 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(2313.81, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[11].GasProduced.Value, 2), 0.05, "Mismatch at element 11 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(4627.60, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[11].LiquidProduced.Value, 2), 0.05, "Mismatch at element 11 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(2292.60, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[11].OilProduced.Value, 2), 0.05, "Mismatch at element 11 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(483.26, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[11].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 11 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(2545.19, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[12].GasProduced.Value, 2), 0.05, "Mismatch at element 12 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(5090.4, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[12].LiquidProduced.Value, 2), 0.05, "Mismatch at element 12 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(2521.8, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[12].OilProduced.Value, 2), 0.05, "Mismatch at element 12 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(112.65, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[12].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 12 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(2776.58, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[13].GasProduced.Value, 2), 0.05, "Mismatch at element 13 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(5553.2, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[13].LiquidProduced.Value, 2), 0.05, "Mismatch at element 13 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(2751.1, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[13].OilProduced.Value, 2), 0.05, "Mismatch at element 13 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(29.62, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[13].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 13 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            Assert.AreEqual(2818.17, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[14].GasProduced.Value, 2), 0.05, "Mismatch at element 14 in expected well performance curve 'gas produced' and ESP analysis value");
            Assert.AreEqual(5636.30, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[14].LiquidProduced.Value, 2), 0.05, "Mismatch at element 14 in expected well performance curve 'liquid produced' and ESP analysis value");
            Assert.AreEqual(2792.30, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[14].OilProduced.Value, 2), 0.05, "Mismatch at element 14 in expected well performance curve 'oil produced' and ESP analysis value");
            Assert.AreEqual(14.7, Math.Round(analysisResult.WellPerformanceCurves.WellPerformanceCurves[0].WellPerformanceCurve.Values[14].WellHeadPressure ?? 0, 2), 0.05, "Mismatch at element 14 in expected well performance curve 'wellhead pressure' and ESP analysis value");

            //                                                  ********************* PUMP PERFORMANCE *********************

            Assert.AreEqual(3038.37, Math.Round(analysisResult.ESPPerformanceCurves.MaximumDifferentialPressure, 2), 0.05, "Mismatch in expected pump performance curve 'maximum differential pressure' and ESP analysis value");
            Assert.AreEqual(5113.6, Math.Round(analysisResult.ESPPerformanceCurves.MaximumFlowRate, 2), 0.05, "Mismatch in expected pump performance curve 'maximum flow rate' and ESP analysis value");
            Assert.AreEqual(8549.48, Math.Round(analysisResult.ESPPerformanceCurves.MaximumHead, 2), 0.05, "Mismatch in expected pump performance curve 'maximum head' and ESP analysis value");
            Assert.AreEqual(209.32, Math.Round(analysisResult.ESPPerformanceCurves.MaximumHorsePower, 2), 0.05, "Mismatch in expected pump performance curve 'maximum horsepower' and ESP analysis value");
            Assert.AreEqual(6095.3, Math.Round(analysisResult.ESPPerformanceCurves.MaximumInsituFlowRate, 2), 0.05, "Mismatch in expected pump performance curve 'maximum in situ flow rate' and ESP analysis value");
            Assert.AreEqual(0.6711, Math.Round(analysisResult.ESPPerformanceCurves.MaximumPumpEfficiency, 2), 0.05, "Mismatch in expected pump performance curve 'maximum pump efficiency' and ESP analysis value");

            //Assert.AreEqual(3567.7, Math.Round(analysisResult.ESPPerformanceCurves.OperatingRange.Value.BestEfficiencyFlowRate, 2), 0.05, "Mismatch in expected pump performance curve 'best eficiency flow rate' and ESP analysis value");
            Assert.AreEqual(4077.5, Math.Round(analysisResult.ESPPerformanceCurves.OperatingRange.Value.BestEfficiencyInsituFlowRate, 2), 0.05, "Mismatch in expected pump performance curve 'best eficiency in situ flow rate' and ESP analysis value");
            //Assert.AreEqual(4192.3, Math.Round(analysisResult.ESPPerformanceCurves.OperatingRange.Value.MaximumFlowRate, 2), 0.05, "Mismatch in expected pump performance curve 'maximum flow rate' and ESP analysis value");
            Assert.AreEqual(4800.00, Math.Round(analysisResult.ESPPerformanceCurves.OperatingRange.Value.MaximumInsituFlowRate, 2), 0.05, "Mismatch in expected pump performance curve 'maximum in situ flow rate' and ESP analysis value");
            //Assert.AreEqual(2788.1, Math.Round(analysisResult.ESPPerformanceCurves.OperatingRange.Value.MinimumFlowRate, 2), 0.05, "Mismatch in expected pump performance curve 'minimum flow rate' and ESP analysis value");
            Assert.AreEqual(3200.00, Math.Round(analysisResult.ESPPerformanceCurves.OperatingRange.Value.MinimumInsituFlowRate, 2), 0.05, "Mismatch in expected pump performance curve 'minimum in situ flow rate' and ESP analysis value");

            //                                              ********************* PUMP PERFORMANCE CURVE *********************

            Assert.AreEqual(3038.37, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[0].DifferentialPressure, 2), 0.05, "Mismatch at element 0 in expected pump performance curve 'differential pressure' and ESP analysis value");
            Assert.AreEqual(0.18, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[0].Efficiency, 2), 0.05, "Mismatch at element 0 in expected pump performance curve 'efficiency' and ESP analysis value");
            Assert.AreEqual(499.2, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[0].FlowRate, 2), 0.05, "Mismatch at element 0 in expected pump performance curve 'flow rate' and ESP analysis value");
            Assert.AreEqual(8549.48, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[0].Head, 2), 0.05, "Mismatch at element 0 in expected pump performance curve 'head' and ESP analysis value");
            Assert.AreEqual(167.26, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[0].HorsePower, 2), 0.05, "Mismatch at element 0 in expected pump performance curve 'horsepower' and ESP analysis value");
            Assert.AreEqual(592.7, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[0].InsituFlowRate, 2), 0.05, "Mismatch at element 0 in expected pump performance curve 'in situ flow rate' and ESP analysis value");

            Assert.AreEqual(2844.52, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[1].DifferentialPressure, 2), 0.05, "Mismatch at element 1 in expected pump performance curve 'differential pressure' and ESP analysis value");
            Assert.AreEqual(0.42, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[1].Efficiency, 2), 0.05, "Mismatch at element 1 in expected pump performance curve 'efficiency' and ESP analysis value");
            Assert.AreEqual(1397.6, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[1].FlowRate, 2), 0.05, "Mismatch at element 1 in expected pump performance curve 'flow rate' and ESP analysis value");
            Assert.AreEqual(7845.35, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[1].Head, 2), 0.05, "Mismatch at element 1 in expected pump performance curve 'head' and ESP analysis value");
            Assert.AreEqual(185.30, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[1].HorsePower, 2), 0.05, "Mismatch at element 1 in expected pump performance curve 'horsepower' and ESP analysis value");
            Assert.AreEqual(1623.4, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[1].InsituFlowRate, 2), 0.05, "Mismatch at element 1 in expected pump performance curve 'in situ flow rate' and ESP analysis value");

            Assert.AreEqual(2592.51, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[2].DifferentialPressure, 2), 0.05, "Mismatch at element 2 in expected pump performance curve 'differential pressure' and ESP analysis value");
            Assert.AreEqual(0.58, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[2].Efficiency, 2), 0.05, "Mismatch at element 2 in expected pump performance curve 'efficiency' and ESP analysis value");
            Assert.AreEqual(2296.1, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[2].FlowRate, 2), 0.05, "Mismatch at element 2 in expected pump performance curve 'flow rate' and ESP analysis value");
            Assert.AreEqual(7111.15, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[2].Head, 2), 0.05, "Mismatch at element 2 in expected pump performance curve 'head' and ESP analysis value");
            Assert.AreEqual(200.36, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[2].HorsePower, 2), 0.05, "Mismatch at element 2 in expected pump performance curve 'horsepower' and ESP analysis value");
            Assert.AreEqual(2645.1, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[2].InsituFlowRate, 2), 0.05, "Mismatch at element 2 in expected pump performance curve 'in situ flow rate' and ESP analysis value");

            Assert.AreEqual(2244.56, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[3].DifferentialPressure, 2), 0.05, "Mismatch at element 3 in expected pump performance curve 'differential pressure' and ESP analysis value");
            Assert.AreEqual(0.67, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[3].Efficiency, 2), 0.05, "Mismatch at element 3 in expected pump performance curve 'efficiency' and ESP analysis value");
            Assert.AreEqual(3194.6, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[3].FlowRate, 2), 0.05, "Mismatch at element 3 in expected pump performance curve 'flow rate' and ESP analysis value");
            Assert.AreEqual(6141.45, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[3].Head, 2), 0.05, "Mismatch at element 3 in expected pump performance curve 'head' and ESP analysis value");
            Assert.AreEqual(209.32, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[3].HorsePower, 2), 0.05, "Mismatch at element 3 in expected pump performance curve 'horsepower' and ESP analysis value");
            Assert.AreEqual(3658.5, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[3].InsituFlowRate, 2), 0.05, "Mismatch at element 3 in expected pump performance curve 'in situ flow rate' and ESP analysis value");

            Assert.AreEqual(1667.56, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[4].DifferentialPressure, 2), 0.05, "Mismatch at element 4 in expected pump performance curve 'differential pressure' and ESP analysis value");
            Assert.AreEqual(0.65, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[4].Efficiency, 2), 0.05, "Mismatch at element 4 in expected pump performance curve 'efficiency' and ESP analysis value");
            Assert.AreEqual(4093.1, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[4].FlowRate, 2), 0.05, "Mismatch at element 4 in expected pump performance curve 'flow rate' and ESP analysis value");
            Assert.AreEqual(4567.52, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[4].Head, 2), 0.05, "Mismatch at element 4 in expected pump performance curve 'head' and ESP analysis value");
            Assert.AreEqual(206.24, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[4].HorsePower, 2), 0.05, "Mismatch at element 4 in expected pump performance curve 'horsepower' and ESP analysis value");
            Assert.AreEqual(4667.3, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[4].InsituFlowRate, 2), 0.05, "Mismatch at element 4 in expected pump performance curve 'in situ flow rate' and ESP analysis value");

            Assert.AreEqual(523.09, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[5].DifferentialPressure, 2), 0.05, "Mismatch at element 5 in expected pump performance curve 'differential pressure' and ESP analysis value");
            Assert.AreEqual(0.30, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[5].Efficiency, 2), 0.05, "Mismatch at element 5 in expected pump performance curve 'efficiency' and ESP analysis value");
            Assert.AreEqual(4991.5, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[5].FlowRate, 2), 0.05, "Mismatch at element 5 in expected pump performance curve 'flow rate' and ESP analysis value");
            Assert.AreEqual(1469.57, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[5].Head, 2), 0.05, "Mismatch at element 5 in expected pump performance curve 'head' and ESP analysis value");
            Assert.AreEqual(174.13, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[5].HorsePower, 2), 0.05, "Mismatch at element 5 in expected pump performance curve 'horsepower' and ESP analysis value");
            Assert.AreEqual(5868.3, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[5].InsituFlowRate, 2), 0.05, "Mismatch at element 5 in expected pump performance curve 'in situ flow rate' and ESP analysis value");

            Assert.AreEqual(277.37, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[6].DifferentialPressure, 2), 0.05, "Mismatch at element 6 in expected pump performance curve 'differential pressure' and ESP analysis value");
            Assert.AreEqual(0.17, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[6].Efficiency, 2), 0.05, "Mismatch at element 6 in expected pump performance curve 'efficiency' and ESP analysis value");
            Assert.AreEqual(5113.6, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[6].FlowRate, 2), 0.05, "Mismatch at element 6 in expected pump performance curve 'flow rate' and ESP analysis value");
            Assert.AreEqual(789.64, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[6].Head, 2), 0.05, "Mismatch at element 6 in expected pump performance curve 'head' and ESP analysis value");
            Assert.AreEqual(164.59, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[6].HorsePower, 2), 0.05, "Mismatch at element 6 in expected pump performance curve 'horsepower' and ESP analysis value");
            Assert.AreEqual(6095.3, Math.Round(analysisResult.ESPPerformanceCurves.PumpCurve.Values[6].InsituFlowRate, 2), 0.05, "Mismatch at element 6 in expected pump performance curve 'in situ flow rate' and ESP analysis value");

            //                                                  ********************* WELL CURVE *********************

            //zero head point are no long valid anymore
            //Assert.AreEqual(0.0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[0].DifferentialPressure ?? 0, 2), 0.05, "Mismatch at element 0 in expected well curve 'differential pressure' and ESP analysis value");
            //Assert.AreEqual(499.2, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[0].FlowRate, 2), 0.05, "Mismatch at element 0 in expected well curve 'flow rate' and ESP analysis value");
            //Assert.AreEqual(0.0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[0].Head ?? 0, 2), 0.05, "Mismatch at element 0 in expected well curve 'head' and ESP analysis value");
            //Assert.AreEqual(749.8, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[0].InsituFlowRate, 2), 0.05, "Mismatch at element 0 in expected well curve 'in situ flow rate' and ESP analysis value");

            //Assert.AreEqual(0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[1].DifferentialPressure ?? 0, 2), 0.05, "Mismatch at element 1 in expected well curve 'differential pressure' and ESP analysis value");
            //Assert.AreEqual(1397.63, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[1].FlowRate, 2), 0.05, "Mismatch at element 1 in expected well curve 'flow rate' and ESP analysis value");
            //Assert.AreEqual(0.0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[1].Head ?? 0, 2), 0.05, "Mismatch at element 1 in expected well curve 'head' and ESP analysis value");
            //Assert.AreEqual(2051.4, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[1].InsituFlowRate, 2), 0.05, "Mismatch at element 1 in expected well curve 'in situ flow rate' and ESP analysis value");

            //Assert.AreEqual(0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[2].DifferentialPressure ?? 0, 2), 0.05, "Mismatch at element 2 in expected well curve 'differential pressure' and ESP analysis value");
            //Assert.AreEqual(2296.1, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[2].FlowRate, 2), 0.05, "Mismatch at element 2 in expected well curve 'flow rate' and ESP analysis value");
            //Assert.AreEqual(0.0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[2].Head ?? 0, 2), 0.05, "Mismatch at element 2 in expected well curve 'head' and ESP analysis value");
            //Assert.AreEqual(3316.3, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[2].InsituFlowRate, 2), 0.05, "Mismatch at element 2 in expected well curve 'in situ flow rate' and ESP analysis value");

            //Assert.AreEqual(0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[3].DifferentialPressure ?? 0, 2), 0.05, "Mismatch at element 3 in expected well curve 'differential pressure' and ESP analysis value");
            //Assert.AreEqual(3194.6, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[3].FlowRate, 2), 0.05, "Mismatch at element 3 in expected well curve 'flow rate' and ESP analysis value");
            //Assert.AreEqual(0.0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[3].Head ?? 0, 2), 0.05, "Mismatch at element 3 in expected well curve 'head' and ESP analysis value");
            //Assert.AreEqual(4408.0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[3].InsituFlowRate, 2), 0.05, "Mismatch at element 3 in expected well curve 'in situ flow rate' and ESP analysis value");

            //Assert.AreEqual(0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[4].DifferentialPressure ?? 0, 2), 0.05, "Mismatch at element 4 in expected well curve 'differential pressure' and ESP analysis value");
            //Assert.AreEqual(4093.1, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[4].FlowRate, 2), 0.05, "Mismatch at element 4 in expected well curve 'flow rate' and ESP analysis value");
            //Assert.AreEqual(0.0, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[4].Head ?? 0, 2), 0.05, "Mismatch at element 4 in expected well curve 'head' and ESP analysis value");
            //Assert.AreEqual(5276.6, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[4].InsituFlowRate, 2), 0.05, "Mismatch at element 4 in expected well curve 'in situ flow rate' and ESP analysis value");

            Assert.AreEqual(241.53, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[0].DifferentialPressure ?? 0, 2), 0.05, "Mismatch at element 5 in expected well curve 'differential pressure' and ESP analysis value");
            Assert.AreEqual(4991.5, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[0].FlowRate, 2), 0.05, "Mismatch at element 5 in expected well curve 'flow rate' and ESP analysis value");
            Assert.AreEqual(688.29, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[0].Head ?? 0, 2), 0.05, "Mismatch at element 5 in expected well curve 'head' and ESP analysis value");
            Assert.AreEqual(6002.4, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[0].InsituFlowRate, 2), 0.05, "Mismatch at element 5 in expected well curve 'in situ flow rate' and ESP analysis value");

            Assert.AreEqual(277.77, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[1].DifferentialPressure ?? 0, 2), 0.05, "Mismatch at element 6 in expected well curve 'differential pressure' and ESP analysis value");
            Assert.AreEqual(5113.6, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[1].FlowRate, 2), 0.05, "Mismatch at element 6 in expected well curve 'flow rate' and ESP analysis value");
            Assert.AreEqual(790.77, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[1].Head ?? 0, 2), 0.05, "Mismatch at element 6 in expected well curve 'head' and ESP analysis value");
            Assert.AreEqual(6094.9, Math.Round(analysisResult.ESPPerformanceCurves.WellCurve.Values[1].InsituFlowRate, 2), 0.05, "Mismatch at element 6 in expected well curve 'in situ flow rate' and ESP analysis value");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ESPGassinessCurveTests()
        {
            // This is the path to the  ESP example well model in the codebase.
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP,
                new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.LFactor,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.CalculateChokeD_Factor
                    }
                });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = "ESPTestWell3" + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            WellDTO newWell = WellService.GetWellByName("ESPTestWell3" + wellType.ToString());
            Assert.IsNotNull(newWell);
            _wellsToRemove.Add(newWell);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO();

            options.Comment = "Testing 1 - 2 - 3 ..." + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = newWell.Id;

            byte[] fileAsByteArray = GetByteArray(path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File is not an ESP model file.");
            ModelFileValidationDataDTO modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(modelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            // NOTE: If you change anything in the following well test, it is very likely that this integration test will fail
            //       because the comparisons we do after the analysis assume that this well test was used for the analysis.
            WellTestDTO testDTO = new WellTestDTO
            {
                WellId = newWell.Id,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 100,
                AverageTubingTemperature = 101,
                AverageCasingPressure = 0,
                GaugePressure = 104,
                Oil = 108,
                Gas = 109,
                Water = 110,
                ChokeSize = 107,
                FlowLinePressure = 105,
                SeparatorPressure = 106,
                Frequency = 60,
                MotorVolts = 450,
                MotorCurrent = 55,
                SampleDate = DateTime.Today.ToUniversalTime()
            };

            // Add the well test record to the database.
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(newWell.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDTO));

            // Get it back out and use it to load the analysis inputs (?)
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(newWell.Id.ToString());
            NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.TestData.Value.ChokeSize, "ChokeSize is not available in the analysis input");
            Assert.IsNotNull(analysisInput.TestData.Value.LiquidAoF, "LiquidAoF is not defined in the TestData");
            Assert.IsNull(analysisInput.TestData.Value.GasAoF, "GasAoF is available for fluid type well");

            Assert.IsNotNull(analysisInput.ModelData.SolutionNode, "Solution node is not available in the model data");
            Assert.IsNotNull(analysisInput.ModelData.StartNode, "Start node is not available in the modal data");
            Assert.AreNotEqual(analysisInput.ModelData.SolutionNode.Value.Name, analysisInput.ModelData.StartNode.Value.Name, "Start and solution node cannot be the same");
            Assert.AreEqual(3, analysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of solution nodes are available in analysis input modal data");
            Assert.AreEqual(3, analysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of atart nodes are available in analysis input modal data");

            Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ProductivityIndex, "Productivity index is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageCasingPressure ?? 0, 3), (decimal)Math.Round(analysisInput.TestData.Value.CasingHeadPressure, 3), "Mismatch between the provided average casing pressure value and the analysis input test value");
            Assert.AreEqual((latestValidTestDataPair.Value.GaugePressure.HasValue ? Math.Round(latestValidTestDataPair.Value.GaugePressure.Value, 3) : 0m), (decimal)Math.Round(analysisInput.TestData.Value.DownholeGaugePressure, 3), "Mismatch between the provided gauge pressure value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.GOR.Value, 3), analysisInput.TestData.Value.GasOilRatio.HasValue ? (decimal)Math.Round(analysisInput.TestData.Value.GasOilRatio.Value, 3) : 0m, "Mismatch between the provided GOR value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.Gas.Value, 3), (decimal)Math.Round(analysisInput.TestData.Value.GasRate, 3), "Mismatch between the provided gas value and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)Math.Round(analysisInput.TestData.Value.OilRate), "Mismatch between the provided oil and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Id, analysisInput.TestData.Value.Id, "Mismatch between the provided ID and analysis input test ID");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.WaterCut.Value), (decimal)Math.Round(analysisInput.TestData.Value.WaterCut), "Mismatch between the provided water cut value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingPressure.Value), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadPressure), "Mismatch between the provided average tubing pressure value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingTemperature ?? 0.0m), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadTemperature), "Mismatch between the provided average tubing temperature value and analysis input test value");

            // Run the ESP analysis
            ESPAnalysisResultsAndUnitsDTO espAnalysisResult = WellTestDataService.PerformESPAnalysis(analysisInput);

            Assert.IsNotNull(espAnalysisResult.PressureDropResults.GassinessCurves, "Unable to get gassiness curves after ESP Analysis");
            Assert.IsNotNull(espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve, "Unable to get upper gassiness curve after ESP Analysis");
            Assert.IsNotNull(espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve, "Unable to get lower gassiness curve after ESP Analysis");
            Assert.IsNotNull(espAnalysisResult.PressureDropResults.GassinessCurves.PumpIntakeGassiness, "Unable to get pump intake gassiness after ESP Analysis");
            Assert.IsTrue(espAnalysisResult.PressureDropResults.GassinessCurves.MaximumPressure >= 0, "Gassiness curve maximum pressure must be >= 0");
            Assert.IsTrue(espAnalysisResult.PressureDropResults.GassinessCurves.MaximumVaporLiquidRatio >= 0, "Gassiness maximum vapor liquied ratio must be >= 0");


            // Lower gassiness curve: test the length and the first 5 and the last 5 points as representative

            Assert.IsTrue(espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values.Length == 61, "Invalid lower gassines curve length: Expected = 61 Actual = " + espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values.Length.ToString());

            Assert.AreEqual(0, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[0].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [0] Mismatch");
            Assert.AreEqual(0, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[0].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [0] Mismatch");

            Assert.AreEqual(0.005, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[1].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [1] Mismatch");
            Assert.AreEqual(32.47, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[1].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [1] Mismatch");

            Assert.AreEqual(0.01, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[2].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [2] Mismatch");
            Assert.AreEqual(50.21, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[2].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [2] Mismatch");

            Assert.AreEqual(0.015, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[3].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [3] Mismatch");
            Assert.AreEqual(64.8, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[3].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [3] Mismatch");

            Assert.AreEqual(0.02, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[4].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [4] Mismatch");
            Assert.AreEqual(77.66, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[4].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [4] Mismatch");

            Assert.AreEqual(0.91, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[56].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [56] Mismatch");
            Assert.AreEqual(857.52, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[56].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [56] Mismatch");

            Assert.AreEqual(0.9325, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[57].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [56] Mismatch");
            Assert.AreEqual(870.8, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[57].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [56] Mismatch");

            Assert.AreEqual(0.955, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[58].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [56] Mismatch");
            Assert.AreEqual(883.96, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[58].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [56] Mismatch");

            Assert.AreEqual(0.9775, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[59].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [56] Mismatch");
            Assert.AreEqual(897, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[59].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [56] Mismatch");

            Assert.AreEqual(1, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[60].InsituVaporLiquidRatio, 0.001, "Lower curve InsituVaporLiquidRatio [56] Mismatch");
            Assert.AreEqual(909.94, espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve.Values[60].PumpIntakePressure, 0.05, "Lower curve PumpIntakePressure [56] Mismatch");

            // Upper gassiness curve: test the first 5 and the last 5 points as representative

            Assert.IsTrue(espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values.Length == 39, "Invalid upper gassiness curve length: Expected = 39 Actual = " + espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values.Length.ToString());

            Assert.AreEqual(0, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[0].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [0] Mismatch");
            Assert.AreEqual(0, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[0].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [0] Mismatch");

            Assert.AreEqual(0.01, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[1].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [1] Mismatch");
            Assert.AreEqual(32.47, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[1].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [1] Mismatch");

            Assert.AreEqual(0.02, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[2].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [2] Mismatch");
            Assert.AreEqual(50.21, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[2].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [2] Mismatch");

            Assert.AreEqual(0.03, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[3].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [3] Mismatch");
            Assert.AreEqual(64.8, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[3].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [3] Mismatch");

            Assert.AreEqual(0.04, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[4].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [4] Mismatch");
            Assert.AreEqual(77.66, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[4].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [4] Mismatch");

            Assert.AreEqual(0.83, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[34].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [34] Mismatch");
            Assert.AreEqual(523.27, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[34].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [34] Mismatch");

            Assert.AreEqual(0.875, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[35].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [35] Mismatch");
            Assert.AreEqual(540.94, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[35].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [35] Mismatch");

            Assert.AreEqual(0.92, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[36].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [36] Mismatch");
            Assert.AreEqual(558.28, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[36].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [36] Mismatch");

            Assert.AreEqual(0.965, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[37].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [37] Mismatch");
            Assert.AreEqual(575.31, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[37].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [37] Mismatch");

            Assert.AreEqual(1, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[38].InsituVaporLiquidRatio, 0.001, "Upper curve InsituVaporLiquidRatio [38] Mismatch");
            Assert.AreEqual(588.35, espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve.Values[38].PumpIntakePressure, 0.05, "Upper curve PumpIntakePressure [38] Mismatch");

            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            // -------------- Get well analysis data in US units --------------
            Assert.AreEqual("STB/d", analysisInput.TestData.Units.LiquidAoF.UnitKey, "Incorrect US units for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.Precision);

            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            NodalAnalysisInputAndUnitsDTO analysisInput_metric = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());
            Assert.AreEqual("sm3/d", analysisInput_metric.TestData.Units.LiquidAoF.UnitKey, "Incorrect metric units for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(3, (int)analysisInput_metric.TestData.Units.LiquidAoF.Precision, "Incorrect metric units precision for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.Precision);

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ESPPumpPerformanceCurveTests()
        {
            // This is the path to the  ESP example well model in the codebase.
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP,
                new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.LFactor,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.CalculateChokeD_Factor
                    }
                });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = "ESPTestWell3" + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            WellDTO newWell = WellService.GetWellByName("ESPTestWell3" + wellType.ToString());
            Assert.IsNotNull(newWell);
            _wellsToRemove.Add(newWell);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO();

            options.Comment = "Testing 1 - 2 - 3 ..." + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = newWell.Id;

            byte[] fileAsByteArray = GetByteArray(path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File is not an ESP model file.");
            ModelFileValidationDataDTO modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(modelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            /// Add VSD frequenices to ESP Well
            /// 
            SettingDTO setting = SettingService.GetSettingByName(SettingServiceStringConstants.WELL_FREQUENCY);


            WellSettingDTO wellsettingdto = new WellSettingDTO
            {
                SettingId = setting.Id,
                WellId = newWell.Id,
                Setting = new SettingDTO { SettingCategory = SettingCategory.PerformanceCurve, SettingType = SettingType.Well, Key = "Well Frequencies", Name = "Well Frequencies", Description = "Well Frequencies", SettingValueType = SettingValueType.DecimalNumberArray },
                NumericArrayValue = new double[] { 50.0, 55.0, 60.0, 65.0 }
            };
            SettingService.SaveWellSetting(wellsettingdto);

            // NOTE: If you change anything in the following well test, it is very likely that this integration test will fail
            //       because the comparisons we do after the analysis assume that this well test was used for the analysis.
            WellTestDTO testDTO = new WellTestDTO
            {
                WellId = newWell.Id,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 100,
                AverageTubingTemperature = 101,
                AverageCasingPressure = 0,
                GaugePressure = 104,
                Oil = 108,
                Gas = 109,
                Water = 110,
                ChokeSize = 107,
                FlowLinePressure = 105,
                SeparatorPressure = 106,
                Frequency = 60,
                MotorVolts = 450,
                MotorCurrent = 55,
                SampleDate = DateTime.Today.ToUniversalTime()
            };

            // Add the well test record to the database.
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(newWell.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDTO));

            // Get it back out and use it to load the analysis inputs (?)
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(newWell.Id.ToString());
            NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.TestData.Value.ChokeSize, "ChokeSize is not available in the analysis input");

            Assert.IsNotNull(analysisInput.ModelData.SolutionNode, "Solution node is not available in the model data");
            Assert.IsNotNull(analysisInput.ModelData.StartNode, "Start node is not available in the modal data");
            Assert.AreNotEqual(analysisInput.ModelData.SolutionNode.Value.Name, analysisInput.ModelData.StartNode.Value.Name, "Start and solution node cannot be the same");
            Assert.AreEqual(3, analysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of solution nodes are available in analysis input modal data");
            Assert.AreEqual(3, analysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of atart nodes are available in analysis input modal data");

            Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ProductivityIndex, "Productivity index is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageCasingPressure ?? 0, 3), (decimal)Math.Round(analysisInput.TestData.Value.CasingHeadPressure, 3), "Mismatch between the provided average casing pressure value and the analysis input test value");
            Assert.AreEqual((latestValidTestDataPair.Value.GaugePressure.HasValue ? Math.Round(latestValidTestDataPair.Value.GaugePressure.Value, 3) : 0m), (decimal)Math.Round(analysisInput.TestData.Value.DownholeGaugePressure, 3), "Mismatch between the provided gauge pressure value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.GOR.Value, 3), analysisInput.TestData.Value.GasOilRatio.HasValue ? (decimal)Math.Round(analysisInput.TestData.Value.GasOilRatio.Value, 3) : 0m, "Mismatch between the provided GOR value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.Gas.Value, 3), (decimal)Math.Round(analysisInput.TestData.Value.GasRate, 3), "Mismatch between the provided gas value and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)Math.Round(analysisInput.TestData.Value.OilRate), "Mismatch between the provided oil and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Id, analysisInput.TestData.Value.Id, "Mismatch between the provided ID and analysis input test ID");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.WaterCut.Value), (decimal)Math.Round(analysisInput.TestData.Value.WaterCut), "Mismatch between the provided water cut value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingPressure.Value), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadPressure), "Mismatch between the provided average tubing pressure value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingTemperature ?? 0.0m), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadTemperature), "Mismatch between the provided average tubing temperature value and analysis input test value");

            // Run the ESP analysis
            ESPAnalysisResultsAndUnitsDTO analysisResult = WellTestDataService.PerformESPAnalysis(analysisInput);
            // ESPVSDPerformanceCurvesAndUnitsDTO GenerateESPPumpPerformanceCurves(NodalAnalysisInputAndUnitsDTO analysisInput);
            //
            ESPVSDPerformanceCurvesAndUnitsDTO vsdperformancedto = WellTestDataService.GenerateESPPumpPerformanceCurves(analysisInput);

            Assert.IsNotNull(vsdperformancedto, "VSD PErformance Curve DTO was null");


            //********************* WELL PERFORMANCE *********************
            //****Verify Base Operating Range Values
            Assert.AreEqual(4077.5, vsdperformancedto.BaseOperatingRange.Value.BestEfficiencyInsituFlowRate, 0.5, "BestEfficiencyInsituFlowRate Mismatch");
            Assert.AreEqual(4800, vsdperformancedto.BaseOperatingRange.Value.MaximumInsituFlowRate, 0.5, "MaximumInsituFlowRate Mismatch");
            Assert.AreEqual(3200, vsdperformancedto.BaseOperatingRange.Value.MinimumInsituFlowRate, 0.5, "MaximumInsituFlowRate Mismatch");

            //****Verify Base Operating Frequency for 60 Hz , ie For Given Well Test without Performance  Frequencies Used

            Assert.AreEqual(60, vsdperformancedto.BasePumpCurve.OperatingFrequency.Value, "Base Operating Frequency Mismatch");
            #region Pump Curve 
            //Verify Head for Base Frequencies
            Assert.AreEqual(8549.48, vsdperformancedto.BasePumpCurve.PumpCurve.Values[0].Head, 0.5, "Head [0] Mismatch");
            Assert.AreEqual(7845.35, vsdperformancedto.BasePumpCurve.PumpCurve.Values[1].Head, 0.5, "Head [1] Mismatch");
            Assert.AreEqual(7111.15, vsdperformancedto.BasePumpCurve.PumpCurve.Values[2].Head, 0.5, "Head [2] Mismatch");
            Assert.AreEqual(6141.45, vsdperformancedto.BasePumpCurve.PumpCurve.Values[3].Head, 0.5, "Head [3] Mismatch");
            //Verify In Situ Flow rates for Base Frequencies
            Assert.AreEqual(592.7, vsdperformancedto.BasePumpCurve.PumpCurve.Values[0].InsituFlowRate, 0.5, "InsituFlowRate [0] Mismatch");
            Assert.AreEqual(1623.4, vsdperformancedto.BasePumpCurve.PumpCurve.Values[1].InsituFlowRate, 0.5, "InsituFlowRate [1] Mismatch");
            Assert.AreEqual(2645.1, vsdperformancedto.BasePumpCurve.PumpCurve.Values[2].InsituFlowRate, 0.5, "InsituFlowRate [2] Mismatch");
            Assert.AreEqual(3658.5, vsdperformancedto.BasePumpCurve.PumpCurve.Values[3].InsituFlowRate, 0.5, "InsituFlowRate [3] Mismatch");

            //Verify Horse Power  for Base Frequencies
            Assert.AreEqual(167.26, vsdperformancedto.BasePumpCurve.PumpCurve.Values[0].HorsePower, 0.5, "HorsePower [0] Mismatch");
            Assert.AreEqual(185.3, vsdperformancedto.BasePumpCurve.PumpCurve.Values[1].HorsePower, 0.5, "HorsePower [1] Mismatch");
            Assert.AreEqual(200.36, vsdperformancedto.BasePumpCurve.PumpCurve.Values[2].HorsePower, 0.5, "HorsePower [2] Mismatch");
            Assert.AreEqual(209.32, vsdperformancedto.BasePumpCurve.PumpCurve.Values[3].HorsePower, 0.5, "HorsePower [3] Mismatch");

            //Verify Efficiency   for Base Frequencies

            Assert.AreEqual(0.1838, vsdperformancedto.BasePumpCurve.PumpCurve.Values[0].Efficiency, 0.5, "Efficiency [0] Mismatch");
            Assert.AreEqual(0.4254, vsdperformancedto.BasePumpCurve.PumpCurve.Values[1].Efficiency, 0.5, "Efficiency [1] Mismatch");
            Assert.AreEqual(0.5847, vsdperformancedto.BasePumpCurve.PumpCurve.Values[2].Efficiency, 0.5, "Efficiency [2] Mismatch");
            Assert.AreEqual(0.6711, vsdperformancedto.BasePumpCurve.PumpCurve.Values[3].Efficiency, 0.5, "Efficiency [3] Mismatch");
            #endregion


            //Verify VSD Curves for each Frequency

            #region VSDCURVES
            Assert.AreEqual(50, vsdperformancedto.VSDPumpCurves[0].OperatingFrequency.Value, "Frequucny [0] Mismatch");
            Assert.AreEqual(55, vsdperformancedto.VSDPumpCurves[1].OperatingFrequency.Value, "Frequucny [1] Mismatch");
            Assert.AreEqual(60, vsdperformancedto.VSDPumpCurves[2].OperatingFrequency.Value, "Frequucny [2] Mismatch");
            Assert.AreEqual(65, vsdperformancedto.VSDPumpCurves[3].OperatingFrequency.Value, "Frequucny [3] Mismatch");

            Dictionary<string, double[]> dicifrearray = new Dictionary<string, double[]>();
            //Veify the First and Last Values for Pump Curve for all Frequency
            // 50 Hz 
            double[] Frequency0InSituRate = new double[] { 587.8, 5224.7 };
            dicifrearray.Add("Frequency0InSituRate", Frequency0InSituRate);
            double[] Frequency0Head = new double[] { 5883.86, 196.35 };
            dicifrearray.Add("Frequency0Head", Frequency0Head);
            double[] Frequency0Efficiency = new double[] { 0.2147, 0.0662 };
            dicifrearray.Add("Frequency0Efficiency", Frequency0Efficiency);
            double[] Frequency0Power = new double[] { 98.51, 92.23 };
            dicifrearray.Add("Frequency0Power", Frequency0Power);
            // 55 Hz 
            double[] Frequency1InSituRate = new double[] { 589.9, 5658.6 };
            double[] Frequency1Head = new double[] { 7154.77, 479.73 };
            double[] Frequency1Efficiency = new double[] { 0.1979, 0.1295 };
            double[] Frequency1Power = new double[] { 129.98, 125.06 };

            dicifrearray.Add("Frequency1InSituRate", Frequency1InSituRate);
            dicifrearray.Add("Frequency1Head", Frequency1Head);
            dicifrearray.Add("Frequency1Efficiency", Frequency1Efficiency);
            dicifrearray.Add("Frequency1Power", Frequency1Power);
            // 60 Hz 

            double[] Frequency2InSituRate = new double[] { 592.7, 6095.3 };
            double[] Frequency2Head = new double[] { 8549.48, 789.64 };
            double[] Frequency2Efficiency = new double[] { 0.1838, 0.1748 };
            double[] Frequency2Power = new double[] { 167.26, 164.59 };

            dicifrearray.Add("Frequency2InSituRate", Frequency2InSituRate);
            dicifrearray.Add("Frequency2Head", Frequency2Head);
            dicifrearray.Add("Frequency2Efficiency", Frequency2Efficiency);
            dicifrearray.Add("Frequency2Power", Frequency2Power);
            // 65 Hz 
            double[] Frequency3InSituRate = new double[] { 596, 6532.5 };
            double[] Frequency3Head = new double[] { 10066.78, 1122.26 };
            double[] Frequency3Efficiency = new double[] { 0.1718, 0.2079 };
            double[] Frequency3Power = new double[] { 210.69, 211.42 };

            dicifrearray.Add("Frequency3InSituRate", Frequency3InSituRate);
            dicifrearray.Add("Frequency3Head", Frequency3Head);
            dicifrearray.Add("Frequency3Efficiency", Frequency3Efficiency);
            dicifrearray.Add("Frequency3Power", Frequency3Power);

            for (int i = 0; i < 4; i++)
            {
                string FrequencyInSituRate = "Frequency" + i + "InSituRate";
                string FrequencyHead = "Frequency" + i + "Head";
                string FrequencyEfficiency = "Frequency" + i + "Efficiency";
                string FrequencyPower = "Frequency" + i + "Power";
                int lastvalue = vsdperformancedto.VSDPumpCurves[i].PumpCurve.Values.Length - 1;
                // InSitu Rate For all Frequencies 
                Assert.AreEqual(dicifrearray[FrequencyInSituRate][0], vsdperformancedto.VSDPumpCurves[i].PumpCurve.Values[0].InsituFlowRate, 0.5, "Mistmatch for first Value of  " + FrequencyInSituRate);
                Assert.AreEqual(dicifrearray[FrequencyInSituRate][1], vsdperformancedto.VSDPumpCurves[i].PumpCurve.Values[lastvalue].InsituFlowRate, 0.5, "Mistmatch for last  Value of  " + FrequencyInSituRate);

                Assert.AreEqual(dicifrearray[FrequencyHead][0], vsdperformancedto.VSDPumpCurves[i].PumpCurve.Values[0].Head, 0.5, "Mistmatch for first Value of  " + FrequencyHead);
                Assert.AreEqual(dicifrearray[FrequencyHead][1], vsdperformancedto.VSDPumpCurves[i].PumpCurve.Values[lastvalue].Head, 0.5, "Mistmatch for last  Value of  " + FrequencyHead);

                Assert.AreEqual(dicifrearray[FrequencyEfficiency][0], vsdperformancedto.VSDPumpCurves[i].PumpCurve.Values[0].Efficiency, 0.5, "Mistmatch for first Value of  " + FrequencyEfficiency);
                Assert.AreEqual(dicifrearray[FrequencyEfficiency][1], vsdperformancedto.VSDPumpCurves[i].PumpCurve.Values[lastvalue].Efficiency, 0.5, "Mistmatch for last  Value of  " + FrequencyEfficiency);

                Assert.AreEqual(dicifrearray[FrequencyPower][0], vsdperformancedto.VSDPumpCurves[i].PumpCurve.Values[0].HorsePower, 0.5, "Mistmatch for first Value of  " + FrequencyPower);
                Assert.AreEqual(dicifrearray[FrequencyPower][1], vsdperformancedto.VSDPumpCurves[i].PumpCurve.Values[lastvalue].HorsePower, 0.5, "Mistmatch for last  Value of  " + FrequencyPower);

            }


            #endregion





        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void NFWellDryGasFluidType()
        {
            var modelFileName = "Dry Gas - IPR Auto Tuning.wflx";
            WellTypeId wellType = WellTypeId.NF;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("NFWWELL_", wellType, WellFluidType.DryGas, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 1820,
                Water = 610,
                ChokeSize = 32,
                FlowLinePressure = 600,
                SeparatorPressure = 600,
                TestDuration = 12,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };

            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testData));

            WellTestAndUnitsDTO validWellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(validWellTest, "Added WellTest is not valid");
            Assert.AreEqual(0, validWellTest.Value.Oil, "Actual Oil Rate should be 0 for Dry Gas Fluid Type");
            Assert.AreEqual(testData.CalibrationMethod, validWellTest.Value.CalibrationMethod, "Mismatch found in Calibration Method");
            Assert.AreEqual(testData.AverageTubingPressure, validWellTest.Value.AverageTubingPressure, "Mismatch found in AverageTubingPressure");
            Assert.AreEqual(testData.AverageTubingTemperature, validWellTest.Value.AverageTubingTemperature, "Mismatch found in AverageTubingTemperature");
            Assert.AreEqual(testData.Gas, validWellTest.Value.Gas, "Mismatch found in Gas");
            Assert.AreEqual(testData.Water, validWellTest.Value.Water, "Mismatch found in Water");
            Assert.AreEqual(testData.ChokeSize, validWellTest.Value.ChokeSize, "Mismatch found in ChokeSize");
            Assert.AreEqual(testData.FlowLinePressure, validWellTest.Value.FlowLinePressure, "Mismatch found in FlowLinePressure");
            Assert.AreEqual(testData.SeparatorPressure, validWellTest.Value.SeparatorPressure, "Mismatch found in SeparatorPressure");
            Assert.AreEqual(testData.TestDuration, validWellTest.Value.TestDuration, "Mismatch found in TestDuration");

        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void NFWellCondensateFluidType()
        {
            var modelFileName = "Condensate Gas - IPR Auto Tuning.wflx";
            var wellType = WellTypeId.NF;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("NFWWELL_", wellType, WellFluidType.Condensate, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 4000,
                AverageTubingTemperature = 100,
                Gas = 35520,
                Water = 5327.6m,
                Oil = 5327.6m,
                ChokeSize = 32,
                FlowLinePressure = 4000,
                SeparatorPressure = 4000,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };

            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testData));

            WellTestAndUnitsDTO validWellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(validWellTest, "Added WellTest is not valid");
            Assert.AreEqual(testData.Oil, validWellTest.Value.Oil, "Actual Oil Rate should be 0 for Dry Gas Fluid Type");
            Assert.AreEqual(testData.CalibrationMethod, validWellTest.Value.CalibrationMethod, "Mismatch found in Calibration Method");
            Assert.AreEqual(testData.AverageTubingPressure, validWellTest.Value.AverageTubingPressure, "Mismatch found in AverageTubingPressure");
            Assert.AreEqual(testData.AverageTubingTemperature, validWellTest.Value.AverageTubingTemperature, "Mismatch found in AverageTubingTemperature");
            Assert.AreEqual(testData.Gas, validWellTest.Value.Gas, "Mismatch found in Gas");
            Assert.AreEqual(testData.Water, validWellTest.Value.Water, "Mismatch found in Water");
            Assert.AreEqual(testData.ChokeSize, validWellTest.Value.ChokeSize, "Mismatch found in ChokeSize");
            Assert.AreEqual(testData.FlowLinePressure, validWellTest.Value.FlowLinePressure, "Mismatch found in FlowLinePressure");
            Assert.AreEqual(testData.SeparatorPressure, validWellTest.Value.SeparatorPressure, "Mismatch found in SeparatorPressure");
            Assert.AreEqual(testData.TestDuration, validWellTest.Value.TestDuration, "Mismatch found in TestDuration");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void NaturalFlowingWellAnalysisTest()
        {
            //pick up the right model file
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            var model = Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF,
                new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.PI,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.CalculateChokeD_Factor
                    }
                });

            var modelFileName = model.Item1;
            var wellType = model.Item2;
            var options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);
            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            var well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            var modelFile = new ModelFileBase64DTO();

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            var modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(modelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            var newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            var test = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 100,
                AverageTubingTemperature = 80,
                AverageCasingPressure = 0,
                GaugePressure = 2000,
                Oil = 1000,
                Gas = 500,
                Water = 200,
                ChokeSize = 50,
                FlowLinePressure = 50,
                SeparatorPressure = 400,
                SampleDate = DateTime.Today.ToUniversalTime()
            };

            var units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, test));

            //get the newly added (latest) well test data
            var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());

            //Validating Analysis input
            var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get Analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available for the obtained Analysis input");

            //Validating ChokeSize and AOF inputs
            Assert.IsNotNull(analysisInput.TestData.Value.ChokeSize, "ChokeSize is not defined in the TestData");
            Assert.IsNotNull(analysisInput.TestData.Value.LiquidAoF, "LiquidAoF is not defined in the TestData");
            Assert.IsNull(analysisInput.TestData.Value.GasAoF, "GasAoF is available for fluid type well");

            Assert.IsNotNull(analysisInput.ModelData.SolutionNode, "Solution node is not available on modeldata");
            Assert.IsNotNull(analysisInput.ModelData.StartNode, "Start node is not available on modal data");
            Assert.AreNotEqual(analysisInput.ModelData.SolutionNode.Value.Name, analysisInput.ModelData.StartNode.Value.Name, "Start and Solution node cannot be same");
            Assert.AreEqual(2, analysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of Solution nodes are available on Analysis input modal data");
            Assert.AreEqual(2, analysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of Start nodes are available on Analysis input modal data");

            Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ProductivityIndex, "ProductivityIndex is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "ReservoirPressure is not defined in the calibration data");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageCasingPressure ?? 0), (decimal)Math.Round(analysisInput.TestData.Value.CasingHeadPressure), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual((latestValidTestDataPair.Value.GaugePressure.HasValue ? Math.Round(latestValidTestDataPair.Value.GaugePressure.Value) : 0m), (decimal)Math.Round(analysisInput.TestData.Value.DownholeGaugePressure), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(latestValidTestDataPair.Value.GOR, (analysisInput.TestData.Value.GasOilRatio.HasValue ? (decimal)Math.Round(analysisInput.TestData.Value.GasOilRatio.Value) : 0m), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(latestValidTestDataPair.Value.Gas, (decimal)Math.Round(analysisInput.TestData.Value.GasRate), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)Math.Round(analysisInput.TestData.Value.OilRate), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(latestValidTestDataPair.Value.Id, analysisInput.TestData.Value.Id, "Mismatch between the Provide test data and Analysis input test data");

            //Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.WaterCut).ToString(), Math.Round(analysisInput.TestData.WaterCut).ToString(), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingPressure.Value), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadPressure), "Mismatch between the Provide test data and Analysis input test data");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingTemperature ?? 0.0m), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadTemperature), "Mismatch between the Provide test data and Analysis input test data");

            //Validating the NF Analysis result
            var analysisResult = WellTestDataService.PerformAnalysis(analysisInput);
            Assert.IsNotNull(analysisResult.OperatingPointResults, "Unable to get Operating point results after NF Analysis");
            Assert.IsNotNull(analysisResult.OperatingPointResults.FlowCurves, "Unable to get Flow curves after NF Analysis");
            Assert.IsNotNull(analysisResult.OperatingPointResults.OperatingPoint, "Unable to get Operating point after NF Analysis");
            Assert.IsNotNull(analysisResult.OperatingPointResults.OperatingPoint.Value.GasRate);
            Assert.IsNotNull(analysisResult.OperatingPointResults.OperatingPoint.Value.OilRate);
            Assert.IsNotNull(analysisResult.OperatingPointResults.OperatingPoint.Value.WaterRate);
            //Assert.AreEqual(latestValidTestDataPair.Value.GOR.ToString(), Math.Round(analysisResult.OperatingPointResults.OperatingPoint.ProducedGOR).ToString());
            //Assert.AreEqual(((latestValidTestDataPair.Value.WaterCut) / 100).ToString(), Math.Round(analysisResult.OperatingPointResults.OperatingPoint.WaterCut, 1).ToString());

            Assert.IsNotNull(analysisResult.PressureDropResults, "Unable to get Pressure drop results after NF Analysis");
            Assert.IsNotNull(analysisResult.PressureDropResults.SolutionPoint, "Unable to get Solution point results after NF Analysis");
            Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.Oil), analysisResult.PressureDropResults.SolutionPoint.Value.OilRate, 0.5);
            Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.GOR), Math.Round(analysisResult.PressureDropResults.SolutionPoint.Value.ProducedGOR), 0.5);
            //Assert.AreEqual(Math.Round(analysisResult.OperatingPointResults.OperatingPoint.Temperature), Math.Round(analysisResult.PressureDropResults.SolutionPoint.Temperature));
            Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.WaterCut), analysisResult.PressureDropResults.SolutionPoint.Value.WaterCut, 0.05);
            Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.Water), analysisResult.PressureDropResults.SolutionPoint.Value.WaterRate, 0.5);

            Assert.IsNotNull(analysisResult.PressureDropResults.GradientCurves, "Unable to get gradient curves after NF Analysis");
            Assert.IsNotNull(analysisResult.PressureDropResults.GradientCurves.GradientCurves, "Unable to get gradient curve points after NF Analysis");
            Assert.AreEqual(Convert.ToDouble(analysisInput.ModelData.SolutionNode.Value.MD), Math.Round(analysisResult.PressureDropResults.GradientCurves.MaximumMD), 0.5);

            Assert.IsNotNull(analysisResult.WellPerformanceCurve, "Unable to get WellPerformanceCurve after NF Analysis");
            Assert.IsNotNull(analysisResult.WellPerformanceCurve.WellPerformanceCurve, "Unable to get WellPerformanceCurve after NF Analysis");

            Assert.AreEqual(1063.2857, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[0].WellHeadPressure ?? 0, 0.5);
            Assert.AreEqual(0.0, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[0].LiquidProduced.Value, 0.005);
            Assert.AreEqual(0.0, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[0].OilProduced.Value, 0.005);

            Assert.AreEqual(1063.2855, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[1].WellHeadPressure ?? 0, 0.5);
            Assert.AreEqual(0.001, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[1].LiquidProduced.Value, 0.005);
            Assert.AreEqual(0.0008, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[1].OilProduced.Value, 0.005);

            Assert.AreEqual(965.8066, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[2].WellHeadPressure ?? 0, 0.5);
            Assert.AreEqual(234.4698, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[2].LiquidProduced.Value, 0.5);
            Assert.AreEqual(195.3837, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[2].OilProduced.Value, 0.5);

            Assert.AreEqual(913.3837, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[3].WellHeadPressure ?? 0, 0.5);
            Assert.AreEqual(468.9387, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[3].LiquidProduced.Value, 0.5);
            Assert.AreEqual(390.7666, analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[3].OilProduced.Value, 0.5);


            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            // -------------- Get well analysis data in US units --------------
            Assert.AreEqual("1/64in", analysisInput.TestData.Units.ChokeSize.UnitKey, "Incorrect US units for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.UnitKey);
            Assert.AreEqual("STB/d", analysisInput.TestData.Units.LiquidAoF.UnitKey, "Incorrect US units for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.Precision);




            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");

            NodalAnalysisInputAndUnitsDTO analysisInput_metric = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            Assert.AreEqual("mm", analysisInput_metric.TestData.Units.ChokeSize.UnitKey, "Incorrect metric units for Chokesize:" + analysisInput_metric.TestData.Units.ChokeSize.UnitKey);
            Assert.AreEqual("sm3/d", analysisInput_metric.TestData.Units.LiquidAoF.UnitKey, "Incorrect metric units for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(3, (int)analysisInput_metric.TestData.Units.LiquidAoF.Precision, "Incorrect metric units precision for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.Precision);

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void CreateEngineeredWellTestTest()
        {
            //pick up the right model file
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("GL-01-Base.wflx", WellTypeId.GLift, new ModelFileOptionDTO() { CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            //add new wellTestData
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 0,
                SPTCodeDescription = "AllocatableTest",
                TestDuration = 3,
                Water = 1900,
                WaterGravity = (decimal)1.0239,
                //LFactor = 1,
                //ReservoirPressure = 5250,
                //ProductivityIndex = (decimal)1.36,
                GaugePressure = (decimal)1610
            };

            testDataDTO.SampleDate = DateTime.Today.ToUniversalTime();
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            var latestTestData = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestTestData.Id.ToString());

            WellTestDataService.CreateEngineeredWellTest(analysisInput);

            var welltests = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
            Assert.AreEqual(welltests.Values.Length, 2);
            var engineeredWellTest = welltests.Values.OrderByDescending(en => en.SampleDate).First();

            Assert.AreEqual(testDataDTO.WellId, engineeredWellTest.WellId);
            Assert.AreEqual(testDataDTO.AverageCasingPressure, engineeredWellTest.AverageCasingPressure);
            Assert.AreEqual(testDataDTO.AverageTubingPressure, engineeredWellTest.AverageTubingPressure);
            Assert.AreEqual(engineeredWellTest.SPTCode, (int)WellTestQuality.RepresentativeTest);
            Assert.AreEqual(engineeredWellTest.SPTCodeDescription, Enum.GetName(typeof(Enums.WellTestQuality), engineeredWellTest.SPTCode));
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateEngineeredWellTestTest()
        {
            //pick up the right model file
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("GL-01-Base.wflx", WellTypeId.GLift, new ModelFileOptionDTO() { CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            //add new wellTestData
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 9,
                SPTCodeDescription = "RejectedTest",
                TestDuration = 3,
                Water = 1900,
                WaterGravity = (decimal)1.0239,
                //LFactor = 1,
                //ReservoirPressure = 5250,
                //ProductivityIndex = (decimal)1.36,
                GaugePressure = (decimal)1610
            };

            testDataDTO.SampleDate = DateTime.Today.ToUniversalTime();
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            var latestTestData = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestTestData.Id.ToString());

            WellTestDataService.UpdateEngineeredWellTest(analysisInput);

            var welltests = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
            Assert.AreEqual(welltests.Values.Length, 1);
            var engineeredWellTest = welltests.Values.OrderByDescending(en => en.SampleDate).First();

            Assert.AreEqual(testDataDTO.WellId, engineeredWellTest.WellId);
            Assert.AreEqual(testDataDTO.AverageCasingPressure, engineeredWellTest.AverageCasingPressure);
            Assert.AreEqual(testDataDTO.AverageTubingPressure, engineeredWellTest.AverageTubingPressure);
            Assert.AreEqual(engineeredWellTest.SPTCode, (int)WellTestQuality.RepresentativeTest);
            Assert.AreEqual(engineeredWellTest.SPTCodeDescription, Enum.GetName(typeof(Enums.WellTestQuality), engineeredWellTest.SPTCode));
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetWellTestTrendsNonRRLTest()
        {
            try
            {
                //well
                WellDTO well = SetDefaultFluidType(new WellDTO
                {
                    Name = "GL" + "TestWell",
                    FacilityId = GetFacilityId("GLWELL_", 1),
                    DataConnection = GetDefaultCygNetDataConnection(),
                    CommissionDate = DateTime.Now.AddDays(-10),
                    WellType = WellTypeId.GLift
                });

                WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = well });
                WellDTO addedWell = WellService.GetAllWells().FirstOrDefault(w => w.Name.Equals(well.Name));
                Assert.IsNotNull(addedWell);
                _wellsToRemove.Add(addedWell);

                //assembly, model
                ModelFileOptionDTO modelOption = new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.ReservoirPressure,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.CalculateChokeD_Factor
                    },
                    Comment = "test"
                };

                string wellIdStr = addedWell.Id.ToString();
                AddNonRRLModelFile(wellIdStr, "GL-01-Base.wflx", WellTypeId.GLift, modelOption);
                //update assembly information
                addedWell = WellService.GetWell(wellIdStr);

                var wellTestQuantities = WellTestDataService.GetWellTestQuantities(addedWell.WellType.ToString());

                var wtQty = Convert.ToInt16(wellTestQuantities.FirstOrDefault()).ToString();

                //no point
                var trend = WellTestDataService.GetWellTestTrendByDateRange(
                    addedWell.Id.ToString(),
                    Convert.ToString(wtQty),//.ToString(),
                    DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime().AddDays(-31)),
                    DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime()));
                Assert.AreEqual(0, trend.PointValues?.Length);

                //welltest 1
                WellTestDTO testDataDTO = new WellTestDTO
                {
                    WellId = addedWell.Id,
                    AverageCasingPressure = 2200m,
                    AverageTubingPressure = 600,
                    AverageTubingTemperature = 100,
                    Gas = 2204m,
                    GasGravity = 0.6722m,
                    GasInjectionRate = 3000,
                    Oil = 1900,
                    OilGravity = 46.2415m,
                    Water = 1900,
                    WaterGravity = 1.0239m,
                    GaugePressure = 1610,
                    FlowLinePressure = 600,
                    SeparatorPressure = 600,
                    ChokeSize = 48,
                    SPTCode = 2,
                    SPTCodeDescription = "RepresentativeTest",
                    SampleDate = addedWell.CommissionDate.Value.ToUniversalTime().AddDays(1)
                };

                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(addedWell.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                //welltest 2
                testDataDTO.SampleDate = addedWell.CommissionDate.Value.ToUniversalTime().AddDays(2);
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                //no point
                trend = WellTestDataService.GetWellTestTrendByDateRange(
                    addedWell.Id.ToString(),
                    Convert.ToString(wtQty),
                    DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime().AddDays(-61)),
                    DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime().AddDays(-30)));
                Assert.AreEqual(0, trend.PointValues.Length);

                //two points
                trend = WellTestDataService.GetWellTestTrendByDateRange(
                    addedWell.Id.ToString(),
                    Convert.ToString(wtQty),
                    DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime().AddDays(-31)),
                    DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime()));
                Assert.AreEqual(2, trend.PointValues.Length);

                Assert.AreEqual(testDataDTO.SampleDate, trend.PointValues[1].Timestamp);
                Assert.AreEqual(testDataDTO.Oil, Convert.ToDecimal(trend.PointValues[1].Value));
                //Assert.AreEqual(testDataDTO.Water, trend.Values[1].Water);
                //Assert.AreEqual(testDataDTO.GasInjectionRate, trend.Values[1].GasInjectionRate);
            }
            catch (Exception ex)
            {
                Assert.Fail(ex.ToString());
            }
        }

        private void AddNonRRLModelFile(string wellId, string fileName, WellTypeId wellType, ModelFileOptionDTO modelOption)
        {
            WellDTO well = WellService.GetWell(wellId);

            //add model file for well test data
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            ModelFileBase64DTO modelFile = new ModelFileBase64DTO()
            {
                Options = modelOption,
                ApplicableDate = well.CommissionDate.Value.AddMinutes(1).ToUniversalTime(),
                WellId = well.Id
            };

            byte[] fileAsByteArray = GetByteArray(Path, fileName);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);

            //add modelfile
            ModelFileService.AddWellModelFile(modelFile);

            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(wellId);
            Assert.IsNotNull(newModelFile);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AWBForESP()
        {
            //Get the file from TestDocuments folder
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO() { CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { (long)OptionalUpdates.UpdateGOR_CGR, ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;
            Trace.WriteLine("Testing model: " + modelFileName);

            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            //Upload Well FIO File
            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            #region ESPAWB

            if (wellType == WellTypeId.ESP)
            {
                //add new wellTestData
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = well.Id,
                    SPTCodeDescription = "AllocatableTest",
                    AverageTubingPressure = 250,
                    AverageTubingTemperature = 65,
                    AverageCasingPressure = 100,
                    PumpIntakePressure = 1700,
                    PumpDischargePressure = 2200,
                    //GaugePressure = 12000,
                    Oil = 1000,
                    Gas = 500,
                    Water = 1200,
                    ChokeSize = 50,
                    FlowLinePressure = 150,
                    SeparatorPressure = 100,
                    Frequency = 20,
                    MotorVolts = 250,
                    MotorCurrent = 48,
                };

                testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                // add wellTest with new non RRL properties
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                Assert.IsNotNull(testDataDTOCheck);
                Assert.AreEqual("AllocatableTest", testDataDTOCheck.SPTCodeDescription);
                Assert.AreEqual(250, testDataDTOCheck.AverageTubingPressure);
                Assert.AreEqual(65, testDataDTOCheck.AverageTubingTemperature);
                Assert.AreEqual(100, testDataDTOCheck.AverageCasingPressure);
                Assert.AreEqual(1700, testDataDTOCheck.PumpIntakePressure);
                Assert.AreEqual(2200, testDataDTOCheck.PumpDischargePressure);
                //Assert.AreEqual(12000, testDataDTOCheck.GaugePressure);
                Assert.AreEqual(1000, testDataDTOCheck.Oil);
                Assert.AreEqual(500, testDataDTOCheck.Gas);
                Assert.AreEqual(1200, testDataDTOCheck.Water);
                Assert.AreEqual(50, testDataDTOCheck.ChokeSize);
                Assert.AreEqual(150, testDataDTOCheck.FlowLinePressure);
                Assert.AreEqual(100, testDataDTOCheck.SeparatorPressure);
                Assert.AreEqual(20, testDataDTOCheck.Frequency);
                Assert.AreEqual(250, testDataDTOCheck.MotorVolts);
                Assert.AreEqual(48, testDataDTOCheck.MotorCurrent);
                //Assert.AreEqual(WellTestStatus.IPR_TUNING_FAILED, testDataDTOCheck.Status);
                //Assert.AreEqual(WellTestStatus.TUNING_IPR_TUNING_ONLY_FAILED, testDataDTOCheck.Status);

                //get the newly added (latest) well test data
                WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                Assert.IsNotNull(latestValidTestDataPair);

                //Validating Analysis Workbench for ESP
                NodalAnalysisInputAndUnitsDTO espAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                //pip, pdp, freq from test
                ESPAnalysisInputDTO espData = espAnalysisInput.ModelData.ESPData.Value;

                espData.PumpIntakePressure = Math.Max(14.7, Convert.ToDouble(latestValidTestDataPair.Value.PumpIntakePressure));
                Assert.AreEqual(Math.Max(14.7, Convert.ToDouble(latestValidTestDataPair.Value.PumpIntakePressure)), espData.PumpIntakePressure, "Mismatch between the Provide test data and Analysis input test data");

                espData.PumpDischargePressure = Math.Max(14.7, Convert.ToDouble(latestValidTestDataPair.Value.PumpDischargePressure));
                Assert.AreEqual(Math.Max(14.7, Convert.ToDouble(latestValidTestDataPair.Value.PumpDischargePressure)), espData.PumpDischargePressure, "Mismatch between the Provide test data and Analysis input test data");

                double opFreq = Convert.ToDouble(latestValidTestDataPair.Value.Frequency);
                if (opFreq >= 0 && opFreq <= 120)
                    espData.OperatingFrequency = opFreq;

                Assert.IsTrue(espData.OperatingFrequency >= 0 && espData.OperatingFrequency <= 120, "The OperatingFrequency should greater than or equal to zero and less than or equal one twenty ");
                Assert.IsNotNull(espData.MotorAmps, "Motor Amps is not available on ESP modal data");
                Assert.IsNotNull(espData.MotorVolts, "Motor Volts is not available on ESP modal data");

                Assert.IsNotNull(espAnalysisInput, "Failed to get Analysis input with the provided test data");
                Assert.IsNotNull(espAnalysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
                Assert.IsNotNull(espAnalysisInput.ModelData, "Model data is not available for the obtained Analysis input");
                Assert.IsNotNull(espAnalysisInput.TestData, "Test data is not available for the obtained Analysis input");
                Assert.IsNotNull(espAnalysisInput.ModelData.SolutionNode, "Solution node is not available on modeldata");
                Assert.IsNotNull(espAnalysisInput.ModelData.StartNode, "Start node is not available on modal data");
                Assert.AreNotEqual(espAnalysisInput.ModelData.SolutionNode.Value.Name, espAnalysisInput.ModelData.StartNode.Value.Name, "Start and Solution node cannot be same");
                Assert.AreEqual(3, espAnalysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of Solution nodes are available on Analysis input modal data");
                Assert.AreEqual(3, espAnalysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of Start nodes are available on Analysis input modal data");

                Assert.IsNotNull(espAnalysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
                Assert.IsNotNull(espAnalysisInput.CalibrationData.Value.ProductivityIndex, "ProductivityIndex is not defined in the calibration data");
                Assert.IsNotNull(espAnalysisInput.CalibrationData.Value.ReservoirPressure, "ReservoirPressure is not defined in the calibration data");

                Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageCasingPressure ?? 0), (decimal)Math.Round(espAnalysisInput.TestData.Value.CasingHeadPressure), "Mismatch between the Provide test data and Analysis input test data");
                Assert.AreEqual((latestValidTestDataPair.Value.GaugePressure.HasValue ? Math.Round(latestValidTestDataPair.Value.GaugePressure.Value) : 0m), (decimal)Math.Round(espAnalysisInput.TestData.Value.DownholeGaugePressure), "Mismatch between the Provide test data and Analysis input test data");
                Assert.AreEqual(latestValidTestDataPair.Value.GOR, (decimal)(espAnalysisInput.TestData.Value.GasOilRatio.HasValue ? Math.Round(espAnalysisInput.TestData.Value.GasOilRatio.Value) : 0), "Mismatch between the Provide test data and Analysis input test data");
                Assert.AreEqual(latestValidTestDataPair.Value.Gas, (decimal)Math.Round(espAnalysisInput.TestData.Value.GasRate), "Mismatch between the Provide test data and Analysis input test data");
                Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)Math.Round(espAnalysisInput.TestData.Value.OilRate), "Mismatch between the Provide test data and Analysis input test data");
                Assert.AreEqual(latestValidTestDataPair.Value.Id, espAnalysisInput.TestData.Value.Id, "Mismatch between the Provide test data and Analysis input test data");

                Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingPressure.Value).ToString(), Math.Round(espAnalysisInput.TestData.Value.WellHeadPressure).ToString(), "Mismatch between the Provide test data and Analysis input test data");
                Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingTemperature ?? 0.0m).ToString(), Math.Round(espAnalysisInput.TestData.Value.WellHeadTemperature).ToString(), "Mismatch between the Provide test data and Analysis input test data");

                //Validating the ESP  Analysis Workbench result
                ESPAnalysisResultsAndUnitsDTO espAnalysisResult = WellTestDataService.PerformESPAnalysis(espAnalysisInput);
                Assert.IsNotNull(espAnalysisResult.OperatingPointResults, "Unable to get Operating point results after GL Analysis");
                Assert.IsNotNull(espAnalysisResult.OperatingPointResults.FlowCurves, "Unable to get Flow curves after ESP Analysis");
                Assert.IsNotNull(espAnalysisResult.OperatingPointResults.OperatingPoint, "Unable to get Operating point after ESP Analysis");
                Assert.IsNotNull(espAnalysisResult.OperatingPointResults.OperatingPoint.Value.GasRate);
                Assert.IsNotNull(espAnalysisResult.OperatingPointResults.OperatingPoint.Value.OilRate);

                Assert.IsNotNull(espAnalysisResult.OperatingPointResults.OperatingPoint.Value.WaterRate);

                Assert.IsNotNull(espAnalysisResult.PressureDropResults, "Unable to get Pressure drop results after ESP Analysis");
                Assert.IsNotNull(espAnalysisResult.PressureDropResults.SolutionPoint, "Unable to get Solution point results after ESP Analysis");

                Assert.IsNotNull(espAnalysisResult.PressureDropResults.GassinessCurves, "Unable to get gassiness curves after ESP Analysis");
                Assert.IsNotNull(espAnalysisResult.PressureDropResults.GassinessCurves.UpperGassinessCurve, "Unable to get upper gassiness curve after ESP Analysis");
                Assert.IsNotNull(espAnalysisResult.PressureDropResults.GassinessCurves.LowerGassinessCurve, "Unable to get lower gassiness curve after ESP Analysis");
                Assert.IsNotNull(espAnalysisResult.PressureDropResults.GassinessCurves.PumpIntakeGassiness, "Unable to get pump intake gassiness after ESP Analysis");
                Assert.IsTrue(espAnalysisResult.PressureDropResults.GassinessCurves.MaximumPressure >= 0, "Gassiness curve maximum pressure must be >= 0");
                Assert.IsTrue(espAnalysisResult.PressureDropResults.GassinessCurves.MaximumVaporLiquidRatio >= 0, "Gassiness maximum vapor liquied ratio must be >= 0");

                Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)espAnalysisResult.PressureDropResults.SolutionPoint.Value.OilRate);

                Assert.IsNotNull(latestValidTestDataPair.Value.GOR.ToString());

                //Delete the added well test data
                WellTestDataService.DeleteWellTestData(testDataDTOCheck.Id.ToString());
                testDataDTOCheck = null;
                var TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
                testDataDTOCheck = TestDataArray.FirstOrDefault(a => a.WellId == well.Id);
                Assert.IsNull(testDataDTOCheck);

                //Remove the  model file
                ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                ModelFileService.RemoveModelFile(newModelFile.Id.ToString());

                //Remove the added well
                //WellService.RemoveWell(well.Id.ToString());
                WellConfigurationService.RemoveWellConfig(well.Id.ToString());
                _wellsToRemove.Remove(well);
            }

            #endregion ESPAWB
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AddUpdateRemoveRRLWellTestWithUnitConversion_AllocatableTest()
        {
            AddUpdateRemoveRRLWellTestWithUnitConversion(0, "AllocatableTest", WellTestStatus.TUNING_NOT_COMPLETE, "Needs Tuning");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AddUpdateRemoveRRLWellTestWithUnitConversion_RepresentativeTest()
        {
            AddUpdateRemoveRRLWellTestWithUnitConversion(2, "RepresentativeTest", WellTestStatus.TUNING_NOT_COMPLETE, "Needs Tuning");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AddUpdateRemoveRRLWellTestWithUnitConversion_OilPotentialTest()
        {
            AddUpdateRemoveRRLWellTestWithUnitConversion(1, "OilPotentialTest", WellTestStatus.TUNING_NOT_AVAILABLE, "N/A");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AddUpdateRemoveRRLWellTestWithUnitConversion_RejectedTest()
        {
            AddUpdateRemoveRRLWellTestWithUnitConversion(9, "RejectedTest", WellTestStatus.UNABLE_TO_VALIDATE_OR_TUNE, "Failure");
        }

        private void AddUpdateRemoveRRLWellTestWithUnitConversion(int sptCode, string sptCodeDescription, WellTestStatus expectedStatus, string tuningStatus)
        {
            // Properties on WellTestDTO to ignore when doing a comparison.
            var propertiesToIgnore = new HashSet<string>() { nameof(WellTestDTO.Id), nameof(WellTestDTO.LastChangedUser),
                nameof(WellTestDTO.LastChangedDT), nameof(WellTestDTO.TotalFluid), nameof(WellTestDTO.GOR),
                nameof(WellTestDTO.WaterCut), nameof(WellTestDTO.TestEndDate), nameof(WellTestDTO.GLR), nameof(WellTestDTO.Message)};

            // Add new well for test.
            List<WellDTO> allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            List<WellDTO> allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            SetUnitSystemToMetric();

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            // Add a new well test.
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 102.7m,
                AverageFluidAbovePump = 15.5m,
                AverageTubingPressure = 103.6m,
                AverageTubingTemperature = 20.5m,
                Gas = 100.8m,
                GasGravity = 0.57m,
                Oil = 25.5m,
                OilGravity = 1.15m,
                PumpEfficiency = 40,
                PumpIntakePressure = 115.3m,
                PumpingHours = 10.5m,
                SPTCodeDescription = sptCodeDescription,
                SPTCode = sptCode,
                SPTCodeType = sptCode,
                CalibrationMethod = 0,
                LFactor = 0,
                StrokePerMinute = 11.4m,
                TestDuration = 24.1m,
                Water = 75.4m,
                WaterGravity = 1.009m,
            };
            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(100));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            // Get the added well test data and compare.
            WellTestArrayAndUnitsDTO wellTestCollection = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
            Assert.IsNotNull(wellTestCollection, "Failed to get well tests after add.");
            Assert.AreEqual(1, wellTestCollection.Values.Length, "Expected one well test to be returned after add.");
            //adding welltest without a model file will change the SPT code to "AllocatableTest"

            testDataDTO.SPTCode = (long)(WellTestQuality)Enum.Parse(typeof(WellTestQuality), sptCodeDescription);
            testDataDTO.Status = expectedStatus;
            testDataDTO.TuningStatus = tuningStatus;
            CompareObjectsUsingReflection(testDataDTO, wellTestCollection.Values[0], $"Well test values do not match after add.", propertiesToIgnore, 0.01);

            // Update well test data.
            testDataDTO = wellTestCollection.Values[0];
            testDataDTO.AverageCasingPressure = 150.7m;
            testDataDTO.AverageFluidAbovePump = 60.7m;
            testDataDTO.AverageTubingPressure = 125.4m;
            testDataDTO.AverageTubingTemperature = 37.8m;
            testDataDTO.Gas = 145.6m;
            testDataDTO.GasGravity = 0.61m;
            testDataDTO.Oil = 186.58m;
            testDataDTO.OilGravity = 1.07m;
            testDataDTO.PumpEfficiency = 66.5m;
            testDataDTO.PumpIntakePressure = 175.6m;
            testDataDTO.PumpingHours = 11.4m;
            testDataDTO.SPTCodeDescription = "RejectedTest";
            testDataDTO.SPTCode = 9;
            testDataDTO.SPTCodeType = 9;
            testDataDTO.CalibrationMethod = 0;
            testDataDTO.LFactor = 0;
            testDataDTO.StrokePerMinute = 12.3m;
            testDataDTO.TestDuration = 23.98m;
            testDataDTO.Water = 185.58m;
            testDataDTO.WaterGravity = 1.019m;
            WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            // Get the updated well test data and compare.
            wellTestCollection = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
            Assert.IsNotNull(wellTestCollection, "Failed to get well tests after update.");
            Assert.AreEqual(1, wellTestCollection.Values.Length, "Expected one well test to be returned after update.");
            //adding welltest without a model file will change the SPT code to "NeedsValidation"
            //testDataDTO.SPTCode = (long)WellTestQuality.NeedsValidation;
            //testDataDTO.SPTCodeDescription = "NeedsValidation";
            //testDataDTO.Status = WellTestStatus.TUNING_NOT_AVAILABLE;
            CompareObjectsUsingReflection(testDataDTO, wellTestCollection.Values[0], $"Well test values do not match after update.", propertiesToIgnore, 0.01);

            // Remove well test and ensure it is gone.
            WellTestDataService.DeleteWellTestData(wellTestCollection.Values[0].Id.ToString());
            wellTestCollection = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
            Assert.IsNotNull(wellTestCollection, "Failed to get well tests after removal.");
            Assert.AreEqual(0, wellTestCollection.Values.Length, "Should have retrieved no well tests after removal.");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WellTestUnitsPrecision()
        {
            // Add new well for test.
            List<WellDTO> allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = DateTime.Today, WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            List<WellDTO> allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            var propertiesMissingPrecision = new HashSet<string>();
            foreach (PropertyInfo unitProperty in units.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance).Where(p => p.PropertyType == typeof(UnitValidationAndPrecisionDTO)))
            {
                sbyte? precision = (unitProperty.GetValue(units) as UnitValidationAndPrecisionDTO)?.Precision;
                if (precision == null || !precision.HasValue)
                {
                    propertiesMissingPrecision.Add(unitProperty.Name);
                }
            }
            Assert.AreEqual(0, propertiesMissingPrecision.Count,
                $"Precision is missing a value for {units.GetType().Name} on propert{(propertiesMissingPrecision.Count == 1 ? "y" : "ies")}: {string.Join(", ", propertiesMissingPrecision)}.");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void SPTCodeAndStatusUpdatesForWellTestUpdateTest()
        {
            //pick up the right model file
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("GL-01-Base.wflx", WellTypeId.GLift, new ModelFileOptionDTO() { CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR) } });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(50);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            //add new wellTestData
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 0,
                SPTCodeDescription = "AllocatableTest",
                TestDuration = 3,
                Water = 1900,
                WaterGravity = (decimal)1.0239,
                GaugePressure = (decimal)1610
            };

            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1));
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            //WellTestDataService.WellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

            var latestTestData = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            testDataDTO = latestTestData;
            testDataDTO.SPTCode = (long)WellTestQuality.RepresentativeTest;
            testDataDTO.SPTCodeDescription = WellTestQuality.RepresentativeTest.ToString();

            WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            latestTestData = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            //compare the updated well test with the original one with corresponding changes
            Assert.AreEqual(latestTestData.SPTCode, (long)WellTestQuality.RepresentativeTest);
            Assert.AreEqual(latestTestData.SPTCodeDescription, WellTestQuality.RepresentativeTest.ToString());
            //Due to Adnoc changes, we no longer change tuning status - so this will remain as tuned
            Assert.AreEqual(WellTestStatus.TUNING_SUCCEEDED, latestTestData.Status);

            latestTestData = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            testDataDTO = latestTestData;
            testDataDTO.Oil = 2000.0m;
            WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            latestTestData = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            //compare the updated well test with the original one with corresponding changes
            Assert.AreEqual(latestTestData.SPTCode, (long)WellTestQuality.RepresentativeTest);
            Assert.AreEqual(latestTestData.SPTCodeDescription, "RepresentativeTest");
            //change test value, cause status to be needs tuning
            Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, latestTestData.Status);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void EnteredNeedsValidationWithoutModelFile()
        {
            //First case :All well tests entered by the user should have SPT code "Needs Validation" when there is no WellFlo model imported for the well.
            //add new well for test
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //add new wellTestData
            var testDataDTO = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 30, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCode = 9, SPTCodeDescription = "RejectedTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(100));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            //get the added well test data
            var TestDataCollection = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
            WellTestDTO[] TestDataArray = TestDataCollection.Values;
            string Id = "";
            foreach (WellTestDTO test in TestDataArray)
            {
                Id = Id + test.Id.ToString() + ",";
            }
            string testIds = Id.TrimEnd(',');
            var TestDataArraybyTestIDCollection = WellTestDataService.GetWellTestDataByWellIdAndTestIds(well.Id.ToString(), testIds);
            WellTestDTO[] TestDataArraybyTestID = TestDataArraybyTestIDCollection.Values;
            Assert.AreEqual(TestDataArray.Length, TestDataArraybyTestID.Length);
            WellTestDTO latestTestData = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            //adding welltest without a model file will change the SPT code to "RejectedTest"

            Assert.AreEqual(latestTestData.SPTCode, (long)WellTestQuality.RejectedTest);
            Assert.AreEqual(latestTestData.SPTCodeDescription, WellTestQuality.RejectedTest.ToString());
            Assert.AreEqual(latestTestData.Status, WellTestStatus.UNABLE_TO_VALIDATE_OR_TUNE);

            //delete the added well test data
            WellTestDataService.DeleteWellTestData(latestTestData.Id.ToString());
            latestTestData = null;
            TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
            latestTestData = TestDataArray.FirstOrDefault(a => a.WellId == well.Id);
            Assert.IsNull(latestTestData);

            //remove the added well
            //WellService.RemoveWell(well.Id.ToString());
            WellConfigurationService.RemoveWellConfig(well.Id.ToString());
            _wellsToRemove.Remove(well);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void EnteredAllocatbaleTestForOneModelFileDeleted()
        {
            //Second case: Adding and Deleted one model file for all well test
            //Create well
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //Create model file 30 Days Old
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);
            ModelFileDTO model_30DaysOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());

            //add wellTest 20 Days Old
            var wellTest_20DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_20DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(20));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_20DaysOld));

            //add wellTest 10 Days Old
            var wellTest_10DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_10DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(10));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_10DaysOld));

            //add wellTest 5 Days Old
            var wellTest_5DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_5DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(5));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_5DaysOld));

            //add wellTest Today
            var wellTest_Today = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_Today.SampleDate = (DateTime.Today.ToUniversalTime());
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_Today));

            //Call UpdateWellTestsForDeletedModelFile for First Model
            bool isSuccess = WellTestDataService.UpdateWellTestsForDeletedModelFile(model_30DaysOld.Id.ToString());
            Assert.IsTrue(isSuccess, "Update well test for deleted model file failed");

            //Call GetWellTestsForDeletedModelFile for First Model
            WellTestDTO[] wellTestResults_30DayModel = WellTestDataService.GetWellTestsForDeletedModelFile(model_30DaysOld.Id.ToString());
            Assert.IsNotNull(wellTestResults_30DayModel);
            Assert.AreEqual(4, wellTestResults_30DayModel.Length);

            //Check to make sure each is set has Needs validation
            foreach (WellTestDTO test in wellTestResults_30DayModel)
            {
                Assert.AreEqual(Enums.WellTestStatus.TUNING_NOT_COMPLETE, test.Status);
                Assert.AreEqual((long)WellTestQuality.AllocatableTest, test.SPTCode);
                Assert.AreEqual("AllocatableTest", test.SPTCodeDescription);
            }

            //delete the added well test data
            foreach (WellTestDTO test in wellTestResults_30DayModel)
            {
                WellTestDataService.DeleteWellTestData(test.Id.ToString());
            }

            //remove the added well
            //WellService.RemoveWell(well.Id.ToString());
            WellConfigurationService.RemoveWellConfig(well.Id.ToString());
            _wellsToRemove.Remove(well);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void EnteredAllocatableTestForMultipleModelFileDeleted()
        {
            //Second case: Adding multiple model file and only deleted one for all well test
            //Create well
            var allWellsBefore = WellService.GetAllWells().ToList();
            var toAdd = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName, FacilityId = "CASETEST", IntervalAPI = "IntervalAPI", SubAssemblyAPI = "SubAssemblyAPI", AssemblyAPI = "AssemblyAPI", CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.RRL });
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = toAdd });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells.FirstOrDefault(w => allWellsBefore.FirstOrDefault(wb => wb.Id == w.Id) == null);
            _wellsToRemove.Add(well);

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            //Create model file 30 Days Old
            var modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-30));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);
            ModelFileDTO model_30DaysOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());

            //Create model file 1 Day old
            modelFile = new ModelFileDTO();
            modelFile.WellId = well.Id;
            modelFile.ApplicableDate = Truncate(DateTime.UtcNow.AddDays(-1));
            modelFile.Contents = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04 };
            ModelFileService.AddModelFile(modelFile);
            ModelFileDTO model_1DayOld = ModelFileService.GetCurrentModelFile(well.Id.ToString());

            //add wellTest 20 Days Old
            var wellTest_20DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_20DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(20));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_20DaysOld));

            //add wellTest 10 Days Old
            var wellTest_10DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_10DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(10));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_10DaysOld));

            //add wellTest 5 Days Old
            var wellTest_5DaysOld = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_5DaysOld.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(5));
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_5DaysOld));

            //add wellTest Today
            var wellTest_Today = new WellTestDTO { WellId = well.Id, AverageCasingPressure = 1, AverageFluidAbovePump = 1, AverageTubingPressure = 90, AverageTubingTemperature = 100, Gas = 0, GasGravity = 0, Oil = 83, OilGravity = 0, PumpEfficiency = 0, PumpIntakePressure = 100, PumpingHours = 10, SPTCodeDescription = "AllocatableTest", StrokePerMinute = 0, TestDuration = 3, Water = 75, WaterGravity = 0 };
            wellTest_Today.SampleDate = (DateTime.Today.ToUniversalTime());
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, wellTest_Today));

            //Call UpdateWellTestsForDeletedModelFile for First Model
            bool isSuccess = WellTestDataService.UpdateWellTestsForDeletedModelFile(model_30DaysOld.Id.ToString());
            Assert.IsTrue(isSuccess, "Update well test for deleted model file failed");

            //Call GetWellTestsForDeletedModelFile for First Model
            WellTestDTO[] wellTestResults_30DayModel = WellTestDataService.GetWellTestsForDeletedModelFile(model_30DaysOld.Id.ToString());
            Assert.IsNotNull(wellTestResults_30DayModel);
            Assert.AreEqual(3, wellTestResults_30DayModel.Length);

            //Check to make sure each is set has Needs validation
            foreach (WellTestDTO test in wellTestResults_30DayModel)
            {
                Assert.AreEqual(Enums.WellTestStatus.TUNING_NOT_COMPLETE, test.Status);
                Assert.AreEqual((long)WellTestQuality.AllocatableTest, test.SPTCode);
                Assert.AreEqual("AllocatableTest", test.SPTCodeDescription);
            }

            //delete the added well test data
            foreach (WellTestDTO test in wellTestResults_30DayModel)
            {
                WellTestDataService.DeleteWellTestData(test.Id.ToString());
            }

            //remove the added well
            //WellService.RemoveWell(well.Id.ToString());
            WellConfigurationService.RemoveWellConfig(well.Id.ToString());
            _wellsToRemove.Remove(well);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void DeleteWellTestAssociatedWithWellDailyAverageRecord()
        {
            GlWellWithTestData();
            WellDTO well = WellService.GetWellByName(DefaultWellName + WellTypeId.GLift.ToString());
            Assert.IsNotNull(well, "Failed to get added well.");
            AssemblyDTO assembly = WellboreComponentService.GetAssemblyByWellId(well.Id.ToString());
            Assert.IsNotNull(assembly, "Failed to get well assembly.");
            WellTestAndUnitsDTO wellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(wellTest, "Failed to get well test.");
            var dailyAverage = new WellDailyAverageValueDTO()
            {
                ChokeDiameter = (double?)wellTest.Value.ChokeSize,
                CHP = (double)(wellTest.Value.AverageCasingPressure ?? 0),
                DHPG = (double?)wellTest.Value.GaugePressure,
                Duration = null,
                EndDateTime = wellTest.Value.SampleDate.AddDays(1),
                StartDateTime = wellTest.Value.SampleDate,
                WellId = well.Id,
                WellTestId = wellTest.Value.Id,
            };
            bool result = SurveillanceService.AddUpdateWellDailyAverageData(dailyAverage);
            Assert.IsTrue(result, "Adding daily average record failed.");
            result = SurveillanceService.AddUpdateWellDailyAverageData(dailyAverage);
            Assert.IsTrue(result, "Adding second daily average record failed.");
            WellTestDataService.DeleteWellTestData(wellTest.Value.Id.ToString());
            WellTestAndUnitsDTO wellTestShouldNotExist = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNull(wellTestShouldNotExist, "Failed to delete well test.");
        }

        #region Validate Surface Well Test Parameters

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ValidateWellTestParameters_GL()
        {
            SystemSettingDTO bypassSurfaceParameterValidationSetting = SettingService.GetSystemSettingByName(SettingServiceStringConstants.BYPASS_SURFACE_PARAMETER_VALIDATION);
            try
            {
                WellDTO wellGL = AddNonRRLWell("GLWELL_0001", WellTypeId.GLift);
                _wellsToRemove.Add(wellGL);

                SystemSettingDTO chokeSizesettingValue = SettingService.GetSystemSettingByName(SettingServiceStringConstants.CHOKE_SIZE_TOLERANCE_LIMIT);
                SystemSettingDTO bypassTuningsettingValue = SettingService.GetSystemSettingByName(SettingServiceStringConstants.BYPASS_SYSTEM_TUNNING_VALIDATION);

                bypassSurfaceParameterValidationSetting.NumericValue = 0;
                SettingService.SaveSystemSetting(bypassSurfaceParameterValidationSetting);
                bypassSurfaceParameterValidationSetting = SettingService.GetSystemSettingByName(bypassSurfaceParameterValidationSetting.Setting.Name);
                Assert.AreEqual(0, bypassSurfaceParameterValidationSetting.NumericValue);
                AssemblyDTO assemblyID = WellboreComponentService.GetAssemblyByWellId(wellGL.Id.ToString());
                WellTestAndUnitsDTO historicaltestData = WellTestDataService.GetLatestValidWellTestByWellId(wellGL.Id.ToString());
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = wellGL.Id,
                    SPTCodeDescription = "RepresentativeTest",
                    AverageTubingPressure = 110,
                    AverageTubingTemperature = 100,
                    AverageCasingPressure = 1250,
                    GasInjectionRate = 1000,
                    FlowLinePressure = 50,
                    SeparatorPressure = 30,
                    GaugePressure = 12000,
                    Oil = (decimal)495,
                    Gas = 1842,
                    Water = (decimal)100,
                    ChokeSize = 50,
                };
                testDataDTO.SampleDate = wellGL.CommissionDate.Value.AddDays(3).ToUniversalTime();
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(wellGL.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                WellTestAndUnitsDTO latestValidtestData = WellTestDataService.GetLatestValidWellTestByWellId(wellGL.Id.ToString());
                if (historicaltestData.Value.ChokeSize >= ((int)latestValidtestData.Value.ChokeSize - (int)chokeSizesettingValue.NumericValue) &&
                    historicaltestData.Value.ChokeSize <= ((int)latestValidtestData.Value.ChokeSize + (int)chokeSizesettingValue.NumericValue))

                {
                    Assert.AreEqual(WellTestStatus.WITHIN_ACCEPTANCE_LIMITS, latestValidtestData.Value.SurfaceParameterValidationStatus);
                }
                testDataDTO = new WellTestDTO()
                {
                    WellId = wellGL.Id,
                    SPTCodeDescription = "RepresentativeTest",
                    AverageTubingPressure = 150,
                    AverageTubingTemperature = 100,
                    AverageCasingPressure = 1250,
                    GasInjectionRate = 1000,
                    FlowLinePressure = 50,
                    SeparatorPressure = 30,
                    GaugePressure = 12000,
                    Oil = (decimal)560,
                    Gas = 1890,
                    Water = (decimal)100,
                    ChokeSize = 55,
                };
                testDataDTO.SampleDate = wellGL.CommissionDate.Value.AddDays(4).ToUniversalTime();
                units = WellTestDataService.GetWellTestDefaults(wellGL.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                latestValidtestData = WellTestDataService.GetLatestValidWellTestByWellId(wellGL.Id.ToString());
                if (historicaltestData.Value.ChokeSize >= ((int)latestValidtestData.Value.ChokeSize - (int)chokeSizesettingValue.NumericValue) &&
                    historicaltestData.Value.ChokeSize <= ((int)latestValidtestData.Value.ChokeSize + (int)chokeSizesettingValue.NumericValue))
                {
                    Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_WELLHEAD_PRESSURE_HIGH, latestValidtestData.Value.SurfaceParameterValidationStatus);
                    if (bypassTuningsettingValue.NumericValue == 1)
                    {
                        Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_CONTINUE_TUNING, latestValidtestData.Value.Status);
                    }
                    else if (bypassTuningsettingValue.NumericValue == 0)
                    {
                        Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, latestValidtestData.Value.Status);
                    }
                }
            }
            finally
            {
                bypassSurfaceParameterValidationSetting.NumericValue = 1;
                SettingService.SaveSystemSetting(bypassSurfaceParameterValidationSetting);
                RemoveWell("GLWELL_0001");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ValidateWellTestParameters_ESP()
        {
            SystemSettingDTO bypassSurfaceParameterValidationSetting = SettingService.GetSystemSettingByName(SettingServiceStringConstants.BYPASS_SURFACE_PARAMETER_VALIDATION);
            try
            {
                WellDTO wellESP = AddNonRRLWell("ESPWELL_0001", WellTypeId.ESP);
                SystemSettingDTO chokeSizesettingValue = SettingService.GetSystemSettingByName(SettingServiceStringConstants.CHOKE_SIZE_TOLERANCE_LIMIT);
                SystemSettingDTO bypassTuningsettingValue = SettingService.GetSystemSettingByName(SettingServiceStringConstants.BYPASS_SYSTEM_TUNNING_VALIDATION);
                bypassSurfaceParameterValidationSetting.NumericValue = 0;
                SettingService.SaveSystemSetting(bypassSurfaceParameterValidationSetting);
                bypassSurfaceParameterValidationSetting = SettingService.GetSystemSettingByName(bypassSurfaceParameterValidationSetting.Setting.Name);
                Assert.AreEqual(0, bypassSurfaceParameterValidationSetting.NumericValue);
                AssemblyDTO assemblyID = WellboreComponentService.GetAssemblyByWellId(wellESP.Id.ToString());
                WellTestAndUnitsDTO historicaltestData = WellTestDataService.GetLatestValidWellTestByWellId(wellESP.Id.ToString());
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = wellESP.Id,
                    SPTCodeDescription = "AllocatableTest",
                    AverageTubingPressure = 200,
                    AverageTubingTemperature = 100,
                    PumpIntakePressure = 1412.25m,
                    PumpDischargePressure = 3067.59m,
                    GaugePressure = 2900,
                    Oil = 2397.5m,
                    Gas = 3596.2m,
                    Water = 8000,
                    ChokeSize = 50,
                    FlowLinePressure = 50,
                    SeparatorPressure = 10000,
                    Frequency = 20,
                };
                testDataDTO.SampleDate = wellESP.CommissionDate.Value.AddDays(3).ToUniversalTime();
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(wellESP.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                WellTestAndUnitsDTO latestValidtestData = WellTestDataService.GetLatestValidWellTestByWellId(wellESP.Id.ToString());
                if (historicaltestData.Value.ChokeSize >= ((int)latestValidtestData.Value.ChokeSize - (int)chokeSizesettingValue.NumericValue) &&
                    historicaltestData.Value.ChokeSize <= ((int)latestValidtestData.Value.ChokeSize + (int)chokeSizesettingValue.NumericValue))
                {
                    Assert.AreEqual(WellTestStatus.WITHIN_ACCEPTANCE_LIMITS, latestValidtestData.Value.SurfaceParameterValidationStatus);
                }
                testDataDTO = new WellTestDTO()
                {
                    WellId = wellESP.Id,
                    SPTCodeDescription = "AllocatableTest",
                    AverageTubingPressure = 250,
                    AverageTubingTemperature = 100,
                    PumpIntakePressure = 1412.25m,
                    PumpDischargePressure = 3067.59m,
                    GaugePressure = 2900,
                    Oil = 2397.5m,
                    Gas = 3596.2m,
                    Water = 8000,
                    ChokeSize = 50,
                    FlowLinePressure = 50,
                    SeparatorPressure = 10000,
                    Frequency = 20,
                };
                testDataDTO.SampleDate = wellESP.CommissionDate.Value.AddDays(4).ToUniversalTime();
                units = WellTestDataService.GetWellTestDefaults(wellESP.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                latestValidtestData = WellTestDataService.GetLatestValidWellTestByWellId(wellESP.Id.ToString());
                if (historicaltestData.Value.ChokeSize >= ((int)latestValidtestData.Value.ChokeSize - (int)chokeSizesettingValue.NumericValue) &&
                    historicaltestData.Value.ChokeSize <= ((int)latestValidtestData.Value.ChokeSize + (int)chokeSizesettingValue.NumericValue))
                {
                    Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_WELLHEAD_PRESSURE_HIGH, latestValidtestData.Value.SurfaceParameterValidationStatus);
                    if (bypassTuningsettingValue.NumericValue == 1)
                    {
                        Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_CONTINUE_TUNING, latestValidtestData.Value.Status);
                    }
                    else if (bypassTuningsettingValue.NumericValue == 0)
                    {
                        Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, latestValidtestData.Value.Status);
                    }
                }
            }
            finally
            {
                bypassSurfaceParameterValidationSetting.NumericValue = 1;
                SettingService.SaveSystemSetting(bypassSurfaceParameterValidationSetting);
                RemoveWell("ESPWELL_0001");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ValidateWellTestParameters_NF()
        {
            SystemSettingDTO bypassSurfaceParameterValidationSetting = SettingService.GetSystemSettingByName(SettingServiceStringConstants.BYPASS_SURFACE_PARAMETER_VALIDATION);
            try
            {
                WellDTO wellNF = AddNonRRLWell("NFWWELL_0001", WellTypeId.NF);

                SystemSettingDTO chokeSizesettingValue = SettingService.GetSystemSettingByName(SettingServiceStringConstants.CHOKE_SIZE_TOLERANCE_LIMIT);
                SystemSettingDTO bypassTuningsettingValue = SettingService.GetSystemSettingByName(SettingServiceStringConstants.BYPASS_SYSTEM_TUNNING_VALIDATION);

                bypassSurfaceParameterValidationSetting.NumericValue = 0;
                SettingService.SaveSystemSetting(bypassSurfaceParameterValidationSetting);
                bypassSurfaceParameterValidationSetting = SettingService.GetSystemSettingByName(bypassSurfaceParameterValidationSetting.Setting.Name);
                Assert.AreEqual(0, bypassSurfaceParameterValidationSetting.NumericValue);
                AssemblyDTO assemblyID = WellboreComponentService.GetAssemblyByWellId(wellNF.Id.ToString());
                WellTestAndUnitsDTO historicaltestData = WellTestDataService.GetLatestValidWellTestByWellId(wellNF.Id.ToString());
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = wellNF.Id,
                    SPTCodeDescription = "RepresentativeTest",
                    AverageTubingPressure = 164.7m,
                    AverageTubingTemperature = 100,
                    GaugePressure = 5800,
                    Oil = 1769.5m,
                    Gas = 880,
                    Water = 589.8m,
                    ChokeSize = 50,
                    FlowLinePressure = 50,
                    SeparatorPressure = 10000,
                };
                testDataDTO.SampleDate = wellNF.CommissionDate.Value.AddDays(3).ToUniversalTime();
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(wellNF.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                WellTestAndUnitsDTO latestValidtestData = WellTestDataService.GetLatestValidWellTestByWellId(wellNF.Id.ToString());
                if (historicaltestData.Value.ChokeSize >= ((int)latestValidtestData.Value.ChokeSize - (int)chokeSizesettingValue.NumericValue) &&
                    historicaltestData.Value.ChokeSize <= ((int)latestValidtestData.Value.ChokeSize + (int)chokeSizesettingValue.NumericValue))
                {
                    Assert.AreEqual(WellTestStatus.WITHIN_ACCEPTANCE_LIMITS, latestValidtestData.Value.SurfaceParameterValidationStatus);
                }
                testDataDTO = new WellTestDTO()
                {
                    WellId = wellNF.Id,
                    SPTCodeDescription = "RepresentativeTest",
                    AverageTubingPressure = 200.7m,
                    AverageTubingTemperature = 100,
                    GaugePressure = 5800,
                    Oil = 1769.5m,
                    Gas = 880,
                    Water = 589.8m,
                    ChokeSize = 50,
                    FlowLinePressure = 50,
                    SeparatorPressure = 10000,
                };
                testDataDTO.SampleDate = wellNF.CommissionDate.Value.AddDays(4).ToUniversalTime();
                units = WellTestDataService.GetWellTestDefaults(wellNF.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                latestValidtestData = WellTestDataService.GetLatestValidWellTestByWellId(wellNF.Id.ToString());
                if (historicaltestData.Value.ChokeSize >= ((int)latestValidtestData.Value.ChokeSize - (int)chokeSizesettingValue.NumericValue) &&
                    historicaltestData.Value.ChokeSize <= ((int)latestValidtestData.Value.ChokeSize + (int)chokeSizesettingValue.NumericValue))
                {
                    Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_WELLHEAD_PRESSURE_HIGH, latestValidtestData.Value.SurfaceParameterValidationStatus);
                    if (bypassTuningsettingValue.NumericValue == 1)
                    {
                        Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_CONTINUE_TUNING, latestValidtestData.Value.Status);
                    }
                    else if (bypassTuningsettingValue.NumericValue == 0)
                    {
                        Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, latestValidtestData.Value.Status);
                    }
                }
            }
            finally
            {
                bypassSurfaceParameterValidationSetting.NumericValue = 1;
                SettingService.SaveSystemSetting(bypassSurfaceParameterValidationSetting);
                RemoveWell("NFWWELL_0001");
            }
        }

        #endregion Validate Surface Well Test Parameters

        //FRWM-309:Add Columns for L Factor, PI, reservoir Pressure and Darcy Coeff for model file data
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ValidateWelltestModelFileColumnValues()
        {
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            try
            {
                Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
                Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.UpdateGOR_CGR) } }),
                Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.PI, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR) } }),
                Tuple.Create("WellfloWaterInjectionExample1.wflx", WellTypeId.WInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.InjectivityIndex, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
                Tuple.Create("WellfloGasLiftExampleTuningTrace.WFLX", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR) } }),
                Tuple.Create("WellfloGasInjectionExample1.wflx", WellTypeId.GInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
                Tuple.Create("PCP-Multiphase.wflx", WellTypeId.PCP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
                };

                foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
                {
                    string model = modelInfo.Item1;
                    WellTypeId wellType = modelInfo.Item2;
                    ModelFileOptionDTO options = modelInfo.Item3;

                    Trace.WriteLine("Testing model: " + model);
                    //Create a new well
                    WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
                    var allWells = WellService.GetAllWells().ToList();
                    WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                    Assert.IsNotNull(well);
                    _wellsToRemove.Add(well);

                    ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                    options.Comment = "CASETest Upload " + modelInfo.Item1;
                    modelFile.Options = options;
                    modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(100);
                    modelFile.WellId = well.Id;

                    byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                    Assert.IsNotNull(fileAsByteArray);
                    modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                    Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                    ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                    Assert.IsNotNull(ModelFileValidationData);
                    ModelFileService.AddWellModelFile(modelFile);
                    ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                    Assert.IsNotNull(newModelFile);
                    _modelFilesToRemove.Add(newModelFile.Id.ToString());

                    WellTestDTO testDataDTO = new WellTestDTO();

                    // Set system to US units
                    ChangeUnitSystem("US");
                    ChangeUnitSystemUserSetting("US");

                    #region ESP

                    if (wellType == WellTypeId.ESP)
                    {
                        //add new wellTestData
                        testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCodeDescription = "RepresentativeTest",
                            AverageTubingPressure = 100,
                            AverageTubingTemperature = 101,
                            GaugePressure = 104,
                            Oil = 108,
                            Gas = 109,
                            Water = 110,
                            ChokeSize = 107,
                            FlowLinePressure = 105,
                            SeparatorPressure = 106,
                            Frequency = 60,
                            MotorVolts = 450,
                            MotorCurrent = 55,
                            SampleDate = DateTime.Today.ToUniversalTime() //WellTest-1 Date time
                        };

                    }

                    #endregion ESP

                    #region WaterInjection

                    else if (wellType == WellTypeId.WInj)
                    {
                        //add new wellTestData
                        testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCode = 2,
                            SPTCodeDescription = "RepresentativeTest",
                            AverageTubingPressure = 5000,
                            AverageTubingTemperature = 65,
                            PumpIntakePressure = 10000,
                            PumpDischargePressure = 11000,
                            GaugePressure = 12000,
                            Water = 8000,
                            ChokeSize = 50,
                            FlowLinePressure = 50,
                        };

                    }
                    #endregion WaterInjection

                    #region GasLift
                    else if (wellType == WellTypeId.GLift)
                    {
                        //add new wellTestData
                        testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCode = 2,
                            SPTCodeDescription = "RepresentativeTest",
                            AverageTubingPressure = 5000,
                            AverageTubingTemperature = 65,
                            AverageCasingPressure = 1000,
                            GasInjectionRate = 1000,
                            FlowLinePressure = 50,
                            SeparatorPressure = 30,
                            GaugePressure = 12000,
                            Oil = (decimal)1497.8,
                            Gas = 500,
                            Water = (decimal)2246.6,
                            ChokeSize = 50,
                        };
                    }

                    #endregion GasLift

                    #region NF
                    else if (wellType == WellTypeId.NF)
                    {
                        //add new wellTestData
                        testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCode = 2,
                            SPTCodeDescription = "RepresentativeTest",
                            AverageTubingPressure = 5000,
                            AverageTubingTemperature = 65,
                            GaugePressure = 12000,
                            Oil = 5000,
                            Gas = 500,
                            Water = 8000,
                            ChokeSize = 50,
                            FlowLinePressure = 50,
                            SeparatorPressure = 10000,
                        };

                    }
                    #endregion NF

                    #region GasInjection

                    else if (wellType == WellTypeId.GInj)
                    {
                        //add new wellTestData
                        testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCodeDescription = "RepresentativeTest",
                            AverageTubingPressure = 1600,
                            AverageTubingTemperature = 65,
                            GaugePressure = 12000,
                            Oil = 1000,
                            Water = 500,
                            Gas = 2000,
                            GasInjectionRate = 1200,
                            ProductivityIndex = 5.3m,
                            ChokeSize = 50,
                            FlowLinePressure = 50,
                        };
                    }
                    #endregion GasInjection

                    #region PCP

                    else if (wellType == WellTypeId.PCP)
                    {
                        testDataDTO = new WellTestDTO
                        {
                            WellId = well.Id,
                            TestDuration = 12,
                            SPTCodeDescription = "Allocatable Test",
                            TuningStatus = "Needs Tuning",
                            AverageTubingPressure = 100,
                            AverageTubingTemperature = 107,
                            AverageCasingPressure = 186,
                            PumpIntakePressure = 189,
                            PumpDischargePressure = 1800,
                            PolishedRodTorque = (decimal)494.16,
                            PumpTorque = 360,
                            PumpSpeed = 300,
                            MotorVolts = 230,
                            MotorCurrent = 145,
                            FlowLinePressure = 452,
                            SeparatorPressure = 84,
                            GOR = 1000,
                            Oil = 343,
                            Gas = 34,
                            ChokeSize = 32,
                            Water = 85,
                            SampleDate = DateTime.Today.ToUniversalTime()
                        };
                    }
                    #endregion PCP

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestAndUnitsDTO WellTestAndUnits = new WellTestAndUnitsDTO();
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO;
                    WellTestDataService.SaveWellTest(WellTestAndUnits);

                    //get the newly added (latest) well test data
                    var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestValidTestDataPair);

                    //Extract the Model LFactor, Model PI, Model Reservoir Pressure and Model Dary Coeff from welltest table
                    decimal? dModelLfactor = latestValidTestDataPair.Value.ModelLFactor;
                    decimal? dModelPI = latestValidTestDataPair.Value.ModelProductivityIndex;
                    decimal? dModelReservoirPressure = latestValidTestDataPair.Value.ModelReservoirPressure;
                    decimal? dModelDarcyFlowCoeff = latestValidTestDataPair.Value.ModelDarcyFlowCoefficient;

                    //Extract the Model LFactor, Model PI, Model Reservoir Pressure and Model Darcy Flow Coeff from Model file
                    var modelconfigdata = WellConfigurationService.GetWellConfigUoM(well.Id.ToString());
                    double Expected_Reservoir_Pressure = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                    double Expected_PI = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                    double Expected_Darcy_Coeff = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().DarcyCoef;

                    Assert.AreEqual(1, Convert.ToDouble(dModelLfactor), 0.005);
                    Assert.AreEqual(Expected_PI, Convert.ToDouble(dModelPI), 0.005);
                    Assert.AreEqual(Expected_Reservoir_Pressure, Convert.ToDouble(dModelReservoirPressure), 0.005);
                    Assert.AreEqual(Expected_Darcy_Coeff, Convert.ToDouble(dModelDarcyFlowCoeff), 0.005);

                    //Delete the attached model file
                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());

                    var latestWellTestData = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
                    Assert.IsNotNull(latestWellTestData);
                    dModelLfactor = latestWellTestData.ModelLFactor;
                    dModelPI = latestWellTestData.ModelProductivityIndex;
                    dModelReservoirPressure = latestWellTestData.ModelReservoirPressure;
                    dModelDarcyFlowCoeff = latestWellTestData.ModelDarcyFlowCoefficient;

                    Assert.IsNull(dModelLfactor);
                    Assert.IsNull(dModelPI);
                    Assert.IsNull(dModelReservoirPressure);
                    Assert.IsNull(dModelDarcyFlowCoeff);
                }
            }
            catch (Exception e)
            {
                Trace.WriteLine("Error in ValidateWelltestModelFileColumnValues Test " + e.Message);
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UnitsCheckforGasLiftAWB()
        {
            SettingType settingType = SettingType.System;
            SettingDTO systemSettings = SettingService.GetSettingsByType(settingType.ToString()).FirstOrDefault(x => x.Name == SettingServiceStringConstants.UNIT_SYSTEM); //"Choke Size Tolerance Limit");
            SystemSettingDTO settingValue = SettingService.GetSystemSettingByName(systemSettings.Name);
            try
            {
                WellDTO wellGL = AddNonRRLWell("GLWELL_0001", WellTypeId.GLift);
                //US
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                AssemblyDTO assembly = WellboreComponentService.GetAssemblyByWellId(wellGL.Id.ToString());
                string assemblyId = assembly.Id.ToString();
                WellTestHeaderDTO[] wellTestHeaders = WellTestDataService.GetValidWellTestHeadersByWellId(wellGL.Id.ToString());
                string testId = wellTestHeaders.FirstOrDefault().Id.ToString();
                NodalAnalysisInputAndUnitsDTO us_input = WellTestDataService.GetAnalysisInputDataAndUnits(testId);
                GasLiftPressureDropAnalysisResultsAndUnitsDTO us_GlPressureDropAnalysis = WellTestDataService.PerformGasLiftPressureDrop(us_input);
                GasLiftOperatingPointAnalysisResultsAndUnitsDTO us_OperatingpointAnalysis = WellTestDataService.PerformGasLiftOperatingPointAnalysis(us_input);
                GasLiftWellPerformanceCurvesAndUnitsDTO us_GasLitPerformanceCurves = WellTestDataService.GenerateGasLiftPerformanceCurves(us_input);

                //Metric
                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                NodalAnalysisInputAndUnitsDTO metric_input = WellTestDataService.GetAnalysisInputDataAndUnits(testId);
                GasLiftPressureDropAnalysisResultsAndUnitsDTO metric_GlPressureDropAnalysis = WellTestDataService.PerformGasLiftPressureDrop(metric_input);
                GasLiftOperatingPointAnalysisResultsAndUnitsDTO metric_OperatingpointAnalysis = WellTestDataService.PerformGasLiftOperatingPointAnalysis(metric_input);
                GasLiftWellPerformanceCurvesAndUnitsDTO metric_GasLitPerformanceCurves = WellTestDataService.GenerateGasLiftPerformanceCurves(metric_input);

                #region Validation Check for the Analysis Input - US

                //Calibration Data
                CalibrationInputUnitsDTO us_calibrationUnits = us_input.CalibrationData.Units;
                //LFactor
                Assert.AreEqual(4, (int)us_calibrationUnits.LFactor.Precision);
                Assert.AreEqual(0.1, us_calibrationUnits.LFactor.Min);
                Assert.AreEqual(2, us_calibrationUnits.LFactor.Max);
                Assert.AreEqual("fraction", us_calibrationUnits.LFactor.UnitKey);
                //Productivity Index
                Assert.AreEqual(4, (int)us_calibrationUnits.ProductivityIndex.Precision);
                Assert.AreEqual(0.0001, us_calibrationUnits.ProductivityIndex.Min);
                Assert.AreEqual(1000000, us_calibrationUnits.ProductivityIndex.Max);
                Assert.AreEqual("STB/d/psi", us_calibrationUnits.ProductivityIndex.UnitKey);
                //Resorvior Pressure
                Assert.AreEqual(2, (int)us_calibrationUnits.ReservoirPressure.Precision);
                Assert.AreEqual(14.7, us_calibrationUnits.ReservoirPressure.Min);
                Assert.AreEqual(25000, us_calibrationUnits.ReservoirPressure.Max);
                Assert.AreEqual("psia", us_calibrationUnits.ReservoirPressure.UnitKey);

                //Model Data - Gas Lift Data
                GasLiftInputUnitsDTO us_GLdataunits = us_input.ModelData.GasLiftData.Units;
                //Deepest Active Mandrel Depth
                Assert.AreEqual(2, (int)us_GLdataunits.DeepestActiveMandrelDepth.Precision);
                Assert.AreEqual("ft", us_GLdataunits.DeepestActiveMandrelDepth.UnitKey);
                //Gas Injection Depth
                Assert.AreEqual(2, (int)us_GLdataunits.GasInjectionDepth.Precision);
                Assert.AreEqual("ft", us_GLdataunits.GasInjectionDepth.UnitKey);
                //Gas Injection Rate
                Assert.AreEqual(2, (int)us_GLdataunits.GasInjectionRate.Precision);
                Assert.AreEqual(0, us_GLdataunits.GasInjectionRate.Min);
                Assert.AreEqual(20000, us_GLdataunits.GasInjectionRate.Max);
                Assert.AreEqual("Mscf/d", us_GLdataunits.GasInjectionRate.UnitKey);
                //Valve Depths
                Assert.AreEqual(2, (int)us_GLdataunits.ValveDepths.Precision);
                Assert.AreEqual("ft", us_GLdataunits.ValveDepths.UnitKey);

                //Model Data - Layer Data
                LayerInputUnitsDTO us_LayerUnits = us_input.ModelData.LayerData.Units;
                //Layer MD
                Assert.AreEqual(2, (int)us_LayerUnits.LayerMD.Precision);
                Assert.AreEqual("ft", us_LayerUnits.LayerMD.UnitKey);
                //Layer Saturation Pressure
                Assert.AreEqual(2, (int)us_LayerUnits.LayerSaturationPressure.Precision);
                Assert.AreEqual("psia", us_LayerUnits.LayerSaturationPressure.UnitKey);
                //Layer TVD
                Assert.AreEqual(2, (int)us_LayerUnits.LayerTVD.Precision);
                Assert.AreEqual("ft", us_LayerUnits.LayerTVD.UnitKey);

                //Model Data - Solution Node
                AnalysisNodeUnitsDTO us_solNode = us_input.ModelData.SolutionNode.Units;
                Assert.AreEqual("ft", us_solNode.MD);

                //Model Data - Solution Nodes
                AnalysisNodeUnitsDTO us_solNodes = us_input.ModelData.SolutionNodes.Units;
                Assert.AreEqual("ft", us_solNodes.MD);

                //Model Data - Start Node
                AnalysisNodeUnitsDTO us_stNode = us_input.ModelData.StartNode.Units;
                Assert.AreEqual("ft", us_stNode.MD);

                //Model Data - Start Nodes
                AnalysisNodeUnitsDTO us_stNodes = us_input.ModelData.StartNodes.Units;
                Assert.AreEqual("ft", us_stNodes.MD);

                //Test Data
                GeneralTestInputUnitsDTO us_testInputs = us_input.TestData.Units;
                //Casing Head Pressure
                Assert.AreEqual(2, (int)us_testInputs.CasingHeadPressure.Precision);
                Assert.AreEqual(14.7, us_testInputs.CasingHeadPressure.Min);
                Assert.AreEqual(25000, us_testInputs.CasingHeadPressure.Max);
                Assert.AreEqual("psia", us_testInputs.CasingHeadPressure.UnitKey);
                //Downhole Gauge Pressure
                Assert.AreEqual(2, (int)us_testInputs.DownholeGaugePressure.Precision);
                Assert.AreEqual(14.7, us_testInputs.DownholeGaugePressure.Min);
                Assert.AreEqual(25000, us_testInputs.DownholeGaugePressure.Max);
                Assert.AreEqual("psia", us_testInputs.DownholeGaugePressure.UnitKey);
                //Flowing Bottomhole Pressure
                Assert.AreEqual(2, (int)us_testInputs.FlowingBottomholePressure.Precision);
                Assert.AreEqual(14.7, us_testInputs.FlowingBottomholePressure.Min);
                Assert.AreEqual(25000, us_testInputs.FlowingBottomholePressure.Max);
                Assert.AreEqual("psia", us_testInputs.FlowingBottomholePressure.UnitKey);
                //Gas Oil Ratio
                Assert.AreEqual(4, (int)us_testInputs.GasOilRatio.Precision);
                Assert.AreEqual("scf/STB", us_testInputs.GasOilRatio.UnitKey);
                //Gas Rate
                Assert.AreEqual(2, (int)us_testInputs.GasRate.Precision);
                Assert.AreEqual(0, us_testInputs.GasRate.Min);
                Assert.AreEqual(50000, us_testInputs.GasRate.Max);
                Assert.AreEqual("Mscf/d", us_testInputs.GasRate.UnitKey);
                //Oil Rate
                Assert.AreEqual(1, (int)us_testInputs.OilRate.Precision);
                Assert.AreEqual(0, us_testInputs.OilRate.Min);
                Assert.AreEqual(10000, us_testInputs.OilRate.Max);
                Assert.AreEqual("STB/d", us_testInputs.OilRate.UnitKey);
                //Total Gas Rate
                Assert.AreEqual(2, (int)us_testInputs.TotalGasRate.Precision);
                Assert.AreEqual(0, us_testInputs.TotalGasRate.Min);
                Assert.AreEqual(50000, us_testInputs.TotalGasRate.Max);
                Assert.AreEqual("Mscf/d", us_testInputs.TotalGasRate.UnitKey);
                //Water Cut
                Assert.AreEqual(4, (int)us_testInputs.WaterCut.Precision);
                Assert.AreEqual("fraction", us_testInputs.WaterCut.UnitKey);
                //Water Rate
                Assert.AreEqual(1, (int)us_testInputs.WaterRate.Precision);
                Assert.AreEqual(0, us_testInputs.WaterRate.Min);
                Assert.AreEqual(10000, us_testInputs.WaterRate.Max);
                Assert.AreEqual("STB/d", us_testInputs.WaterRate.UnitKey);
                //Well Head Pressure
                Assert.AreEqual(2, (int)us_testInputs.WellHeadPressure.Precision);
                Assert.AreEqual(14.7, us_testInputs.WellHeadPressure.Min);
                Assert.AreEqual(15000, us_testInputs.WellHeadPressure.Max);
                Assert.AreEqual("psia", us_testInputs.WellHeadPressure.UnitKey);
                //WellHeadTemperature
                Assert.AreEqual(1, (int)us_testInputs.WellHeadTemperature.Precision);
                Assert.AreEqual(0, us_testInputs.WellHeadTemperature.Min);
                Assert.AreEqual(1000, us_testInputs.WellHeadTemperature.Max);
                Assert.AreEqual("F", us_testInputs.WellHeadTemperature.UnitKey);

                #endregion Validation Check for the Analysis Input - US

                #region Validation Check for the Analysis Input - Metric

                //Calibration Data
                CalibrationInputUnitsDTO metric_calibrationUnits = metric_input.CalibrationData.Units;
                CalibrationInputDTO us_calibrationValue = us_input.CalibrationData.Value;
                CalibrationInputDTO metric_calibrationValue = metric_input.CalibrationData.Value;
                //LFactor
                Assert.AreEqual(4, (int)metric_calibrationUnits.LFactor.Precision);
                Assert.AreEqual(0.1, metric_calibrationUnits.LFactor.Min);
                Assert.AreEqual(2, metric_calibrationUnits.LFactor.Max);
                Assert.AreEqual("fraction", metric_calibrationUnits.LFactor.UnitKey);
                //Productivity Index
                Assert.AreEqual(4, (int)metric_calibrationUnits.ProductivityIndex.Precision);
                Assert.AreEqual(UnitConversion("STB/d/psi", us_calibrationUnits.ProductivityIndex.Min), metric_calibrationUnits.ProductivityIndex.Min);
                Assert.AreEqual(UnitConversion("STB/d/psi", us_calibrationUnits.ProductivityIndex.Max), metric_calibrationUnits.ProductivityIndex.Max);
                Assert.AreEqual("sm3/d/kPa", metric_calibrationUnits.ProductivityIndex.UnitKey);
                Assert.AreEqual(UnitConversion("STB/d/psi", us_calibrationValue.ProductivityIndex), metric_calibrationValue.ProductivityIndex);
                //Resorvior Pressure
                Assert.AreEqual(1, (int)metric_calibrationUnits.ReservoirPressure.Precision);
                Assert.AreEqual(UnitsConversion("psia", us_calibrationUnits.ReservoirPressure.Min), metric_calibrationUnits.ReservoirPressure.Min);
                Assert.AreEqual(UnitsConversion("psia", us_calibrationUnits.ReservoirPressure.Max), metric_calibrationUnits.ReservoirPressure.Max);
                Assert.AreEqual("kPa", metric_calibrationUnits.ReservoirPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_calibrationValue.ReservoirPressure), metric_calibrationValue.ReservoirPressure);

                //Model Data - Gas Lift Data
                GasLiftInputUnitsDTO metric_GLdataunits = metric_input.ModelData.GasLiftData.Units;
                GasLiftInputDTO us_GLdataValue = us_input.ModelData.GasLiftData.Value;
                GasLiftInputDTO metric_GLdataValue = metric_input.ModelData.GasLiftData.Value;
                //Deepest Active Mandrel Depth
                Assert.AreEqual(3, (int)metric_GLdataunits.DeepestActiveMandrelDepth.Precision);
                Assert.AreEqual("m", metric_GLdataunits.DeepestActiveMandrelDepth.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GLdataValue.DeepestActiveMandrelDepth), metric_GLdataValue.DeepestActiveMandrelDepth);
                //Gas Injection Depth
                Assert.AreEqual(3, (int)metric_GLdataunits.GasInjectionDepth.Precision);
                Assert.AreEqual("m", metric_GLdataunits.GasInjectionDepth.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GLdataValue.GasInjectionDepth), metric_GLdataValue.GasInjectionDepth);
                //Gas Injection Rate
                Assert.AreEqual(3, (int)metric_GLdataunits.GasInjectionRate.Precision);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_GLdataunits.GasInjectionRate.Min), metric_GLdataunits.GasInjectionRate.Min);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_GLdataunits.GasInjectionRate.Max), metric_GLdataunits.GasInjectionRate.Max);
                Assert.AreEqual("sm3/d", metric_GLdataunits.GasInjectionRate.UnitKey);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_GLdataValue.GasInjectionRate), metric_GLdataValue.GasInjectionRate);
                //Valve Depths
                Assert.AreEqual(3, (int)metric_GLdataunits.ValveDepths.Precision);
                Assert.AreEqual("m", metric_GLdataunits.ValveDepths.UnitKey);
                Assert.AreEqual(us_GLdataValue.ValveDepths.Count(), metric_GLdataValue.ValveDepths.Count());
                for (int i = 0; i < metric_GLdataValue.ValveDepths.Count(); i++)
                {
                    Assert.AreEqual(UnitsConversion("ft", us_GLdataValue.ValveDepths[i]), metric_GLdataValue.ValveDepths[i]);
                }
                //Model Data - Layer Data
                LayerInputUnitsDTO metric_LayerUnits = metric_input.ModelData.LayerData.Units;
                LayerInputDTO us_LayerValue = us_input.ModelData.LayerData.Value;
                LayerInputDTO metric_LayerValue = metric_input.ModelData.LayerData.Value;
                //Layer MD
                Assert.AreEqual(3, (int)metric_LayerUnits.LayerMD.Precision);
                Assert.AreEqual("m", metric_LayerUnits.LayerMD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_LayerValue.LayerMD), metric_LayerValue.LayerMD);
                //Layer Saturation Pressure
                Assert.AreEqual(1, (int)metric_LayerUnits.LayerSaturationPressure.Precision);
                Assert.AreEqual("kPa", metric_LayerUnits.LayerSaturationPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_LayerValue.LayerSaturationPressure), metric_LayerValue.LayerSaturationPressure);
                //Layer TVD
                Assert.AreEqual(3, (int)metric_LayerUnits.LayerTVD.Precision);
                Assert.AreEqual("m", metric_LayerUnits.LayerTVD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_LayerValue.LayerTVD), metric_LayerValue.LayerTVD);
                //Model Data - Solution Node
                AnalysisNodeUnitsDTO metric_solNode = metric_input.ModelData.SolutionNode.Units;
                AnalysisNodeDTO us_solNodeValue = us_input.ModelData.SolutionNode.Value;
                AnalysisNodeDTO metric_solNodeValue = metric_input.ModelData.SolutionNode.Value;
                Assert.AreEqual("m", metric_solNode.MD);
                Assert.AreEqual(Math.Round(UnitsConversion("ft", us_solNodeValue.MD).Value, 3, MidpointRounding.ToEven), metric_solNodeValue.MD);
                //Model Data - Solution Nodes
                AnalysisNodeUnitsDTO metric_solNodes = metric_input.ModelData.SolutionNodes.Units;
                AnalysisNodeDTO[] us_solNodeValues = us_input.ModelData.SolutionNodes.Values;
                AnalysisNodeDTO[] metric_solNodeValues = metric_input.ModelData.SolutionNodes.Values;
                Assert.AreEqual("m", metric_solNodes.MD);
                Assert.AreEqual(us_solNodeValues.Count(), metric_solNodeValues.Count());
                for (int i = 0; i < us_solNodeValues.Count(); i++)
                {
                    Assert.AreEqual(Math.Round(UnitsConversion("ft", us_solNodeValues[i].MD).Value, 3, MidpointRounding.ToEven), metric_solNodeValues[i].MD);
                }
                //Model Data - Start Node
                AnalysisNodeUnitsDTO metric_stNode = metric_input.ModelData.StartNode.Units;
                AnalysisNodeDTO us_stNodeValue = us_input.ModelData.StartNode.Value;
                AnalysisNodeDTO metric_stNodeValue = metric_input.ModelData.StartNode.Value;
                Assert.AreEqual("m", metric_stNode.MD);
                Assert.AreEqual(Math.Round(UnitsConversion("ft", us_stNodeValue.MD).Value, 3, MidpointRounding.ToEven), metric_stNodeValue.MD);
                //Model Data - Start Nodes
                AnalysisNodeUnitsDTO metric_stNodes = metric_input.ModelData.StartNodes.Units;
                Assert.AreEqual("m", metric_stNodes.MD);
                AnalysisNodeDTO[] us_stNodesValues = us_input.ModelData.StartNodes.Values;
                AnalysisNodeDTO[] metric_stNodesValues = metric_input.ModelData.StartNodes.Values;
                Assert.AreEqual("m", metric_solNodes.MD);
                Assert.AreEqual(us_stNodesValues.Count(), metric_stNodesValues.Count());
                for (int i = 0; i < us_solNodeValues.Count(); i++)
                {
                    Assert.AreEqual(Math.Round(UnitsConversion("ft", us_stNodesValues[i].MD).Value, 3, MidpointRounding.ToEven), metric_stNodesValues[i].MD);
                }
                //Test Data
                GeneralTestInputUnitsDTO metric_testInputs = metric_input.TestData.Units;
                GeneralTestInputDTO us_testValue = us_input.TestData.Value;
                GeneralTestInputDTO metric_testValue = metric_input.TestData.Value;
                //Casing Head Pressure
                Assert.AreEqual(1, (int)metric_testInputs.CasingHeadPressure.Precision);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.CasingHeadPressure.Min), metric_testInputs.CasingHeadPressure.Min);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.CasingHeadPressure.Max), metric_testInputs.CasingHeadPressure.Max);
                Assert.AreEqual("kPa", metric_testInputs.CasingHeadPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_testValue.CasingHeadPressure), metric_testValue.CasingHeadPressure);
                //Downhole Gauge Pressure
                Assert.AreEqual(1, (int)metric_testInputs.DownholeGaugePressure.Precision);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.DownholeGaugePressure.Min), metric_testInputs.DownholeGaugePressure.Min);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.DownholeGaugePressure.Max), metric_testInputs.DownholeGaugePressure.Max);
                Assert.AreEqual("kPa", metric_testInputs.DownholeGaugePressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_testValue.DownholeGaugePressure), metric_testValue.DownholeGaugePressure);
                //Flowing Bottomhole Pressure
                Assert.AreEqual(1, (int)metric_testInputs.FlowingBottomholePressure.Precision);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.FlowingBottomholePressure.Min), metric_testInputs.FlowingBottomholePressure.Min);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.FlowingBottomholePressure.Max), metric_testInputs.FlowingBottomholePressure.Max);
                Assert.AreEqual("kPa", metric_testInputs.FlowingBottomholePressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_testValue.FlowingBottomholePressure), metric_testValue.FlowingBottomholePressure);
                //Gas Oil Ratio
                Assert.AreEqual(5, (int)metric_testInputs.GasOilRatio.Precision);
                Assert.AreEqual("sm3/sm3", metric_testInputs.GasOilRatio.UnitKey);
                //Gas Rate
                Assert.AreEqual(3, (int)metric_testInputs.GasRate.Precision);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testInputs.GasRate.Min), metric_testInputs.GasRate.Min);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testInputs.GasRate.Max), metric_testInputs.GasRate.Max);
                Assert.AreEqual("sm3/d", metric_testInputs.GasRate.UnitKey);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testValue.GasRate), metric_testValue.GasRate);
                //Oil Rate
                Assert.AreEqual(3, (int)metric_testInputs.OilRate.Precision);
                Assert.AreEqual(UnitsConversion("STB/d", us_testInputs.OilRate.Min), metric_testInputs.OilRate.Min);
                Assert.AreEqual(UnitsConversion("STB/d", us_testInputs.OilRate.Max), metric_testInputs.OilRate.Max);
                Assert.AreEqual("sm3/d", metric_testInputs.OilRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_testValue.OilRate), metric_testValue.OilRate);
                //Total Gas Rate
                Assert.AreEqual(3, (int)metric_testInputs.TotalGasRate.Precision);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testInputs.TotalGasRate.Min), metric_testInputs.TotalGasRate.Min);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testInputs.TotalGasRate.Max), metric_testInputs.TotalGasRate.Max);
                Assert.AreEqual("sm3/d", metric_testInputs.TotalGasRate.UnitKey);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testValue.TotalGasRate), metric_testValue.TotalGasRate);
                //Water Cut
                Assert.AreEqual(4, (int)metric_testInputs.WaterCut.Precision);
                Assert.AreEqual("fraction", metric_testInputs.WaterCut.UnitKey);
                //Water Rate
                Assert.AreEqual(3, (int)metric_testInputs.WaterRate.Precision);
                Assert.AreEqual(UnitsConversion("STB/d", us_testInputs.WaterRate.Min), metric_testInputs.WaterRate.Min);
                Assert.AreEqual(UnitsConversion("STB/d", us_testInputs.WaterRate.Max), metric_testInputs.WaterRate.Max);
                Assert.AreEqual("sm3/d", metric_testInputs.WaterRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_testValue.WaterRate), metric_testValue.WaterRate);
                //Well Head Pressure
                Assert.AreEqual(1, (int)metric_testInputs.WellHeadPressure.Precision);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.WellHeadPressure.Min), metric_testInputs.WellHeadPressure.Min);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.WellHeadPressure.Max), metric_testInputs.WellHeadPressure.Max);
                Assert.AreEqual("kPa", metric_testInputs.WellHeadPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_testValue.WellHeadPressure), metric_testValue.WellHeadPressure);
                //WellHeadTemperature
                Assert.AreEqual(1, (int)metric_testInputs.WellHeadTemperature.Precision);
                Assert.AreEqual(UnitsConversion("F", us_testInputs.WellHeadTemperature.Min), metric_testInputs.WellHeadTemperature.Min);
                Assert.AreEqual(UnitsConversion("F", us_testInputs.WellHeadTemperature.Max), metric_testInputs.WellHeadTemperature.Max);
                Assert.AreEqual("C", metric_testInputs.WellHeadTemperature.UnitKey);
                Assert.AreEqual(UnitsConversion("F", us_testValue.WellHeadTemperature), metric_testValue.WellHeadTemperature);

                #endregion Validation Check for the Analysis Input - Metric

                #region Validation Check for the Pressure Drop Analysis - US

                //Validating Gas Lift Pressure Drop Analysis
                //Gradient Curves - US
                GradientCurvesAndUnitsDTO us_GradientCurves = us_GlPressureDropAnalysis.GradientCurves;
                Assert.AreEqual("psia", us_GradientCurves.GradientCurves.Units.CasingPressure.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.GradientCurves.Units.MD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.GradientCurves.Units.TVD.UnitKey);
                Assert.AreEqual("F", us_GradientCurves.GradientCurves.Units.Temperature.UnitKey);
                Assert.AreEqual("psia", us_GradientCurves.GradientCurves.Units.TubingPressure.UnitKey);
                //Depth Lines - US
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.DownholeGaugeMD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.DownholeGaugeTVD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.InjectionMD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.InjectionTVD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.LayerMD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.LayerTVD.UnitKey);
                //Valve Curves - US
                Assert.AreEqual("psia", us_GradientCurves.ValveCurves.Units.CasingPressureToOpen);
                Assert.AreEqual("ft", us_GradientCurves.ValveCurves.Units.MD);
                Assert.AreEqual("ft", us_GradientCurves.ValveCurves.Units.TVD);
                Assert.AreEqual("psia", us_GradientCurves.ValveCurves.Units.TubingPressureToOpen);
                //Solution Point - US
                GasLiftSolutionPointAndUnitsDTO us_SolutionPoint = us_GlPressureDropAnalysis.SolutionPoint;
                Assert.AreEqual("psia", us_SolutionPoint.Units.BottomholePressure.UnitKey);
                Assert.AreEqual("psia", us_SolutionPoint.Units.BubblePointPressure.UnitKey);
                Assert.AreEqual("Mscf/d", us_SolutionPoint.Units.GasRate.UnitKey);
                Assert.AreEqual("STB/d", us_SolutionPoint.Units.IPRFlowRate.UnitKey);
                Assert.AreEqual("Mscf/d", us_SolutionPoint.Units.InjectionGasRate);
                Assert.AreEqual("ft", us_SolutionPoint.Units.InjectionMD);
                Assert.AreEqual("ft", us_SolutionPoint.Units.InjectionTVD);
                Assert.AreEqual("STB/d", us_SolutionPoint.Units.LiquidRate.UnitKey);
                Assert.AreEqual("STB/d", us_SolutionPoint.Units.OilRate.UnitKey);
                Assert.AreEqual("psia", us_SolutionPoint.Units.Pressure.UnitKey);
                Assert.AreEqual("scf/STB", us_SolutionPoint.Units.ProducedGLR.UnitKey);
                Assert.AreEqual("scf/STB", us_SolutionPoint.Units.ProducedGOR.UnitKey);
                Assert.AreEqual("F", us_SolutionPoint.Units.Temperature.UnitKey);
                Assert.AreEqual("fraction", us_SolutionPoint.Units.WaterCut.UnitKey);
                Assert.AreEqual("STB/d", us_SolutionPoint.Units.WaterRate.UnitKey);
                //Valve Diagnostics - US
                GasLiftValveDiagnosticArrayAndUnitsDTO us_ValveDiagnostics = us_GlPressureDropAnalysis.ValveDiagnostics;
                Assert.AreEqual("psia", us_ValveDiagnostics.Units.CasingPressure.UnitKey);
                Assert.AreEqual("psia", us_ValveDiagnostics.Units.CasingPressureToOpen.UnitKey);
                Assert.AreEqual("Mscf/d", us_ValveDiagnostics.Units.InjectionGasRate.UnitKey);
                Assert.AreEqual("ft", us_ValveDiagnostics.Units.MD.UnitKey);
                Assert.AreEqual("psia", us_ValveDiagnostics.Units.PTRO.UnitKey);
                Assert.AreEqual("1/64in", us_ValveDiagnostics.Units.PortSize.UnitKey);
                Assert.AreEqual("fraction", us_ValveDiagnostics.Units.TBRatio.UnitKey);
                Assert.AreEqual("ft", us_ValveDiagnostics.Units.TVD.UnitKey);
                Assert.AreEqual("F", us_ValveDiagnostics.Units.Temperature.UnitKey);
                Assert.AreEqual("psia", us_ValveDiagnostics.Units.TubingPressure.UnitKey);
                Assert.AreEqual("psia", us_ValveDiagnostics.Units.TubingPressureToOpen.UnitKey);

                #endregion Validation Check for the Pressure Drop Analysis - US

                #region Validation Check for the Pressure Drop Analysis - Metric

                //Gradient Curves - Metric
                GradientCurvesAndUnitsDTO metric_GradientCurves = metric_GlPressureDropAnalysis.GradientCurves;
                Assert.AreEqual("kPa", metric_GradientCurves.GradientCurves.Units.CasingPressure.UnitKey);
                Assert.AreEqual("m", metric_GradientCurves.GradientCurves.Units.MD.UnitKey);
                Assert.AreEqual("m", metric_GradientCurves.GradientCurves.Units.TVD.UnitKey);
                Assert.AreEqual("C", metric_GradientCurves.GradientCurves.Units.Temperature.UnitKey);
                Assert.AreEqual("kPa", metric_GradientCurves.GradientCurves.Units.TubingPressure.UnitKey);
                Assert.AreEqual(us_GradientCurves.GradientCurves.Values.Count(), metric_GradientCurves.GradientCurves.Values.Count());
                for (int i = 0; i < us_GradientCurves.GradientCurves.Values.Count(); i++)
                {
                    Assert.AreEqual(Math.Round(UnitsConversion("psia", us_GradientCurves.GradientCurves.Values[i].CasingPressure).Value, 2, MidpointRounding.ToEven), metric_GradientCurves.GradientCurves.Values[i].CasingPressure, 0.2);
                    Assert.AreEqual(Math.Round(UnitsConversion("ft", us_GradientCurves.GradientCurves.Values[i].MD).Value, 2, MidpointRounding.ToEven), metric_GradientCurves.GradientCurves.Values[i].MD, 0.2);
                    Assert.AreEqual(Math.Round(UnitsConversion("ft", us_GradientCurves.GradientCurves.Values[i].TVD).Value, 2, MidpointRounding.ToEven), metric_GradientCurves.GradientCurves.Values[i].TVD, 0.2);
                    Assert.AreEqual(Math.Round(UnitsConversion("F", us_GradientCurves.GradientCurves.Values[i].Temperature).Value, 1), metric_GradientCurves.GradientCurves.Values[i].Temperature, 0.2);
                    Assert.AreEqual(Math.Round(UnitsConversion("psia", us_GradientCurves.GradientCurves.Values[i].TubingPressure).Value, 2, MidpointRounding.ToEven), metric_GradientCurves.GradientCurves.Values[i].TubingPressure, 0.2);
                }
                //Depth Lines - Metric
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.DownholeGaugeMD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.DownholeGaugeMD ?? 0).Value, metric_GradientCurves.DepthLines.Value.DownholeGaugeMD ?? 0, 0.2);
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.DownholeGaugeTVD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.DownholeGaugeTVD ?? 0).Value, metric_GradientCurves.DepthLines.Value.DownholeGaugeTVD ?? 0, 0.2);
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.InjectionMD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.InjectionMD).Value, metric_GradientCurves.DepthLines.Value.InjectionMD, 0.2);
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.InjectionTVD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.InjectionTVD).Value, metric_GradientCurves.DepthLines.Value.InjectionTVD, 0.2);
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.LayerMD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.LayerMD).Value, metric_GradientCurves.DepthLines.Value.LayerMD, 0.2);
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.LayerTVD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.LayerTVD).Value, metric_GradientCurves.DepthLines.Value.LayerTVD, 0.2);
                //Valve Curves - Metric
                Assert.AreEqual("kPa", metric_GradientCurves.ValveCurves.Units.CasingPressureToOpen);
                Assert.AreEqual("m", metric_GradientCurves.ValveCurves.Units.MD);
                Assert.AreEqual("m", metric_GradientCurves.ValveCurves.Units.TVD);
                Assert.AreEqual("kPa", metric_GradientCurves.ValveCurves.Units.TubingPressureToOpen);
                Assert.AreEqual(us_GradientCurves.ValveCurves.Values.Count(), metric_GradientCurves.ValveCurves.Values.Count());
                for (int i = 0; i < us_GradientCurves.ValveCurves.Values.Count(); i++)
                {
                    Assert.AreEqual(UnitsConversion("psia", us_GradientCurves.ValveCurves.Values[i].CasingPressureToOpen).Value, metric_GradientCurves.ValveCurves.Values[i].CasingPressureToOpen, 0.2);
                    Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.ValveCurves.Values[i].MD).Value, metric_GradientCurves.ValveCurves.Values[i].MD, 0.2);
                    Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.ValveCurves.Values[i].TVD).Value, metric_GradientCurves.ValveCurves.Values[i].TVD, 0.2);
                    Assert.AreEqual(UnitsConversion("psia", us_GradientCurves.ValveCurves.Values[i].TubingPressureToOpen).Value, metric_GradientCurves.ValveCurves.Values[i].TubingPressureToOpen, 0.2);
                }
                //Solution Point - Metric
                GasLiftSolutionPointAndUnitsDTO metric_SolutionPoint = metric_GlPressureDropAnalysis.SolutionPoint;
                Assert.AreEqual("kPa", metric_SolutionPoint.Units.BottomholePressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_SolutionPoint.Value.BottomholePressure).Value, metric_SolutionPoint.Value.BottomholePressure.Value, 0.2);
                Assert.AreEqual("kPa", metric_SolutionPoint.Units.BubblePointPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_SolutionPoint.Value.BubblePointPressure).Value, metric_SolutionPoint.Value.BubblePointPressure.Value, 0.2);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.GasRate.UnitKey);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_SolutionPoint.Value.GasRate).Value, metric_SolutionPoint.Value.GasRate, 0.2);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.IPRFlowRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_SolutionPoint.Value.IPRFlowRate).Value, metric_SolutionPoint.Value.IPRFlowRate.Value, 0.2);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.InjectionGasRate);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_SolutionPoint.Value.InjectionGasRate).Value, metric_SolutionPoint.Value.InjectionGasRate, 0.2);
                Assert.AreEqual("m", metric_SolutionPoint.Units.InjectionMD);
                Assert.AreEqual(UnitsConversion("ft", us_SolutionPoint.Value.InjectionMD).Value, metric_SolutionPoint.Value.InjectionMD, 0.2);
                Assert.AreEqual("m", metric_SolutionPoint.Units.InjectionTVD);
                Assert.AreEqual(UnitsConversion("ft", us_SolutionPoint.Value.InjectionTVD).Value, metric_SolutionPoint.Value.InjectionTVD, 0.2);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.LiquidRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_SolutionPoint.Value.LiquidRate).Value, metric_SolutionPoint.Value.LiquidRate, 0.2);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.OilRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_SolutionPoint.Value.OilRate).Value, metric_SolutionPoint.Value.OilRate, 0.2);
                Assert.AreEqual("kPa", metric_SolutionPoint.Units.Pressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_SolutionPoint.Value.Pressure).Value, metric_SolutionPoint.Value.Pressure, 0.2);
                Assert.AreEqual("sm3/sm3", metric_SolutionPoint.Units.ProducedGLR.UnitKey);
                Assert.AreEqual(UnitsConversion("scf/STB", us_SolutionPoint.Value.ProducedGLR).Value, metric_SolutionPoint.Value.ProducedGLR, 0.2);
                Assert.AreEqual("sm3/sm3", metric_SolutionPoint.Units.ProducedGOR.UnitKey);
                Assert.AreEqual(UnitsConversion("scf/STB", us_SolutionPoint.Value.ProducedGOR).Value, metric_SolutionPoint.Value.ProducedGOR, 0.2);
                Assert.AreEqual("C", metric_SolutionPoint.Units.Temperature.UnitKey);
                Assert.AreEqual(UnitsConversion("F", us_SolutionPoint.Value.Temperature).Value, metric_SolutionPoint.Value.Temperature, 0.2);
                Assert.AreEqual("fraction", metric_SolutionPoint.Units.WaterCut.UnitKey);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.WaterRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_SolutionPoint.Value.WaterRate).Value, metric_SolutionPoint.Value.WaterRate, 0.2);
                //Valve Diagnostics - Metric
                GasLiftValveDiagnosticArrayAndUnitsDTO metric_ValveDiagnostics = metric_GlPressureDropAnalysis.ValveDiagnostics;
                Assert.AreEqual("kPa", metric_ValveDiagnostics.Units.CasingPressure.UnitKey);
                Assert.AreEqual("kPa", metric_ValveDiagnostics.Units.CasingPressureToOpen.UnitKey);
                Assert.AreEqual("sm3/d", metric_ValveDiagnostics.Units.InjectionGasRate.UnitKey);
                Assert.AreEqual("m", metric_ValveDiagnostics.Units.MD.UnitKey);
                Assert.AreEqual("kPa", metric_ValveDiagnostics.Units.PTRO.UnitKey);
                Assert.AreEqual("mm", metric_ValveDiagnostics.Units.PortSize.UnitKey);
                Assert.AreEqual("fraction", metric_ValveDiagnostics.Units.TBRatio.UnitKey);
                Assert.AreEqual("m", metric_ValveDiagnostics.Units.TVD.UnitKey);
                Assert.AreEqual("C", metric_ValveDiagnostics.Units.Temperature.UnitKey);
                Assert.AreEqual("kPa", metric_ValveDiagnostics.Units.TubingPressure.UnitKey);
                Assert.AreEqual("kPa", metric_ValveDiagnostics.Units.TubingPressureToOpen.UnitKey);
                Assert.AreEqual(us_ValveDiagnostics.Values.Count(), metric_ValveDiagnostics.Values.Count());
                for (int i = 0; i < us_ValveDiagnostics.Values.Count(); i++)
                {
                    Assert.AreEqual(UnitsConversion("psia", us_ValveDiagnostics.Values[i].CasingPressure).Value, metric_ValveDiagnostics.Values[i].CasingPressure, 0.2);
                    Assert.AreEqual(UnitsConversion("psia", us_ValveDiagnostics.Values[i].CasingPressureToOpen).Value, metric_ValveDiagnostics.Values[i].CasingPressureToOpen, 0.2);
                    Assert.AreEqual(UnitsConversion("Mscf/d", us_ValveDiagnostics.Values[i].InjectionGasRate).Value, metric_ValveDiagnostics.Values[i].InjectionGasRate, 0.2);
                    Assert.AreEqual(UnitsConversion("ft", us_ValveDiagnostics.Values[i].MD).Value, metric_ValveDiagnostics.Values[i].MD, 0.2);
                    Assert.AreEqual(UnitsConversion("psia", us_ValveDiagnostics.Values[i].PTRO).Value, metric_ValveDiagnostics.Values[i].PTRO, 0.2);
                    Assert.AreEqual(UnitsConversion("1/64in", us_ValveDiagnostics.Values[i].PortSize).Value, metric_ValveDiagnostics.Values[i].PortSize, 0.2);
                    Assert.AreEqual(UnitsConversion("ft", us_ValveDiagnostics.Values[i].TVD).Value, metric_ValveDiagnostics.Values[i].TVD, 0.2);
                    Assert.AreEqual(UnitsConversion("F", us_ValveDiagnostics.Values[i].Temperature).Value, metric_ValveDiagnostics.Values[i].Temperature, 0.2);
                    Assert.AreEqual(UnitsConversion("psia", us_ValveDiagnostics.Values[i].TubingPressure).Value, metric_ValveDiagnostics.Values[i].TubingPressure, 0.2);
                    Assert.AreEqual(UnitsConversion("psia", us_ValveDiagnostics.Values[i].TubingPressureToOpen).Value, metric_ValveDiagnostics.Values[i].TubingPressureToOpen, 0.2);
                }

                #endregion Validation Check for the Pressure Drop Analysis - Metric

                #region Validation Check for Operating Point Analysis - US

                //Operating Point Analysis-US
                GasLiftSolutionPointAndUnitsDTO us_OperatingPoint = us_OperatingpointAnalysis.OperatingPoint;
                FlowCurveDataPointArrayAndUnitsDTO us_FlowCurves = us_OperatingpointAnalysis.FlowCurves;
                //Operating Point-US
                Assert.AreEqual("psia", us_OperatingPoint.Units.BottomholePressure.UnitKey);
                Assert.AreEqual("psia", us_OperatingPoint.Units.BubblePointPressure.UnitKey);
                Assert.AreEqual("Mscf/d", us_OperatingPoint.Units.GasRate.UnitKey);
                Assert.AreEqual("STB/d", us_OperatingPoint.Units.IPRFlowRate.UnitKey);
                Assert.AreEqual("Mscf/d", us_OperatingPoint.Units.InjectionGasRate);
                Assert.AreEqual("ft", us_OperatingPoint.Units.InjectionMD);
                Assert.AreEqual("ft", us_OperatingPoint.Units.InjectionTVD);
                Assert.AreEqual("STB/d", us_OperatingPoint.Units.LiquidRate.UnitKey);
                Assert.AreEqual("STB/d", us_OperatingPoint.Units.OilRate.UnitKey);
                Assert.AreEqual("psia", us_OperatingPoint.Units.Pressure.UnitKey);
                Assert.AreEqual("scf/STB", us_OperatingPoint.Units.ProducedGLR.UnitKey);
                Assert.AreEqual("scf/STB", us_OperatingPoint.Units.ProducedGOR.UnitKey);
                Assert.AreEqual("F", us_OperatingPoint.Units.Temperature.UnitKey);
                Assert.AreEqual("fraction", us_OperatingPoint.Units.WaterCut.UnitKey);
                Assert.AreEqual("STB/d", us_OperatingPoint.Units.WaterRate.UnitKey);
                //Flow Curves-US
                Assert.AreEqual("psia", us_FlowCurves.Units.InflowPressure.UnitKey);
                Assert.AreEqual("STB/d", us_FlowCurves.Units.OilRate.UnitKey);
                Assert.AreEqual("psia", us_FlowCurves.Units.OutflowPressure.UnitKey);
                Assert.AreEqual("STB/d", us_FlowCurves.Units.Rate.UnitKey);

                #endregion Validation Check for Operating Point Analysis - US

                #region Validation Check for Operating Point Analysis - Metric

                //Operating Point Analysis-Metric
                GasLiftSolutionPointAndUnitsDTO metric_OperatingPoint = metric_OperatingpointAnalysis.OperatingPoint;
                FlowCurveDataPointArrayAndUnitsDTO metric_FlowCurves = metric_OperatingpointAnalysis.FlowCurves;
                //Operating Point-Metric
                Assert.AreEqual("kPa", metric_OperatingPoint.Units.BottomholePressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_OperatingPoint.Value.BottomholePressure).Value, metric_OperatingPoint.Value.BottomholePressure.Value, 0.2);
                Assert.AreEqual("kPa", metric_OperatingPoint.Units.BubblePointPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_OperatingPoint.Value.BubblePointPressure).Value, metric_OperatingPoint.Value.BubblePointPressure.Value, 0.2);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.GasRate.UnitKey);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_OperatingPoint.Value.GasRate).Value, metric_OperatingPoint.Value.GasRate, 0.2);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.IPRFlowRate.UnitKey);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.InjectionGasRate);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_OperatingPoint.Value.InjectionGasRate).Value, metric_OperatingPoint.Value.InjectionGasRate, 0.2);
                Assert.AreEqual("m", metric_OperatingPoint.Units.InjectionMD);
                Assert.AreEqual(UnitsConversion("ft", us_OperatingPoint.Value.InjectionMD).Value, metric_OperatingPoint.Value.InjectionMD, 0.2);
                Assert.AreEqual("m", metric_OperatingPoint.Units.InjectionTVD);
                Assert.AreEqual(UnitsConversion("ft", us_OperatingPoint.Value.InjectionTVD).Value, metric_OperatingPoint.Value.InjectionTVD, 0.2);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.LiquidRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_OperatingPoint.Value.LiquidRate).Value, metric_OperatingPoint.Value.LiquidRate, 0.2);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.OilRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_OperatingPoint.Value.OilRate).Value, metric_OperatingPoint.Value.OilRate, 0.2);
                Assert.AreEqual("kPa", metric_OperatingPoint.Units.Pressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_OperatingPoint.Value.Pressure).Value, metric_OperatingPoint.Value.Pressure, 0.2);
                Assert.AreEqual("sm3/sm3", metric_OperatingPoint.Units.ProducedGLR.UnitKey);
                Assert.AreEqual(UnitsConversion("scf/STB", us_OperatingPoint.Value.ProducedGLR).Value, metric_OperatingPoint.Value.ProducedGLR, 0.2);
                Assert.AreEqual("sm3/sm3", metric_OperatingPoint.Units.ProducedGOR.UnitKey);
                Assert.AreEqual(UnitsConversion("scf/STB", us_OperatingPoint.Value.ProducedGOR).Value, metric_OperatingPoint.Value.ProducedGOR, 0.2);
                Assert.AreEqual("C", metric_OperatingPoint.Units.Temperature.UnitKey);
                Assert.AreEqual(UnitsConversion("F", us_OperatingPoint.Value.Temperature).Value, metric_OperatingPoint.Value.Temperature, 0.2);
                Assert.AreEqual("fraction", metric_OperatingPoint.Units.WaterCut.UnitKey);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.WaterRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_OperatingPoint.Value.WaterRate).Value, metric_OperatingPoint.Value.WaterRate, 0.2);

                //Flow Curves-Metric
                Assert.AreEqual("kPa", metric_FlowCurves.Units.InflowPressure.UnitKey);
                Assert.AreEqual("sm3/d", metric_FlowCurves.Units.OilRate.UnitKey);
                Assert.AreEqual("kPa", metric_FlowCurves.Units.OutflowPressure.UnitKey);
                Assert.AreEqual("sm3/d", metric_FlowCurves.Units.Rate.UnitKey);
                Assert.AreEqual(us_FlowCurves.Values.Count(), metric_FlowCurves.Values.Count());
                for (int i = 0; i < metric_FlowCurves.Values.Count(); i++)
                {
                    Assert.AreEqual(UnitsConversion("psia", us_FlowCurves.Values[i].InflowPressure).Value, metric_FlowCurves.Values[i].InflowPressure.Value, 0.2);
                    Assert.AreEqual(UnitsConversion("STB/d", us_FlowCurves.Values[i].OilRate).Value, metric_FlowCurves.Values[i].OilRate, 0.2);
                    Assert.AreEqual(UnitsConversion("psia", us_FlowCurves.Values[i].OutflowPressure).Value, metric_FlowCurves.Values[i].OutflowPressure.Value, 0.2);
                    Assert.AreEqual(UnitsConversion("STB/d", us_FlowCurves.Values[i].Rate).Value, metric_FlowCurves.Values[i].Rate, 0.2);
                }

                #endregion Validation Check for Operating Point Analysis - Metric

                #region Validation Check for Performance Curves - US

                //Performance Curve - US
                GasLiftWellPerformanceCurveAndUnitsDTO[] us_PerformanceCureves = us_GasLitPerformanceCurves.WellPerformanceCurves;
                foreach (GasLiftWellPerformanceCurveAndUnitsDTO pc in us_PerformanceCureves)
                {
                    Assert.AreEqual("psia", pc.TubingHeadPressure.UnitKey);
                    GasLiftWellPerformanceCurvePointUnitsDTO pcPoints = pc.WellPerformanceCurve.Units;
                    Assert.AreEqual("Mscf/d", pcPoints.GasInjected);
                    Assert.AreEqual("Mscf/d", pcPoints.GasProduced);
                    Assert.AreEqual("STB/d", pcPoints.LiquidProduced);
                    Assert.AreEqual("STB/d", pcPoints.OilProduced);
                    Assert.AreEqual("STB/d", pcPoints.WaterProduced);
                }

                #endregion Validation Check for Performance Curves - US

                #region Validation Check for Performance Curves - Metric

                //Performance Curve - Metric
                GasLiftWellPerformanceCurveAndUnitsDTO[] metric_PerformanceCureves = metric_GasLitPerformanceCurves.WellPerformanceCurves;
                Assert.AreEqual(UnitsConversion("Mscf/d", us_GasLitPerformanceCurves.MaximumGasInjected).Value, metric_GasLitPerformanceCurves.MaximumGasInjected, 0.2);
                Assert.AreEqual(UnitsConversion("STB/d", us_GasLitPerformanceCurves.MaximumLiquidProduced).Value, metric_GasLitPerformanceCurves.MaximumLiquidProduced, 0.2);
                Assert.AreEqual(UnitsConversion("STB/d", us_GasLitPerformanceCurves.MaximumOilProduced).Value, metric_GasLitPerformanceCurves.MaximumOilProduced, 0.2);
                Assert.AreEqual(us_PerformanceCureves.Count(), metric_PerformanceCureves.Count());
                for (int i = 0; i < us_PerformanceCureves.Count(); i++)
                {
                    Assert.AreEqual("kPa", metric_PerformanceCureves[i].TubingHeadPressure.UnitKey);
                    Assert.AreEqual(UnitsConversion("psia", us_PerformanceCureves[i].TubingHeadPressure.Value).Value, metric_PerformanceCureves[i].TubingHeadPressure.Value.Value, 0.2);
                    GasLiftWellPerformanceCurvePointUnitsDTO metric_PointUnits = metric_PerformanceCureves[i].WellPerformanceCurve.Units;
                    GasLiftWellPerformanceCurvePointDTO[] metric_Points = metric_PerformanceCureves[i].WellPerformanceCurve.Values;
                    GasLiftWellPerformanceCurvePointDTO[] us_Points = us_PerformanceCureves[i].WellPerformanceCurve.Values;
                    Assert.AreEqual(us_Points.Count(), metric_Points.Count());
                    for (int j = 0; j < us_Points.Count(); j++)
                    {
                        Assert.AreEqual("sm3/d", metric_PointUnits.GasInjected);
                        Assert.AreEqual(UnitsConversion("Mscf/d", us_Points[j].GasInjected).Value, metric_Points[j].GasInjected, 0.2);
                        Assert.AreEqual("sm3/d", metric_PointUnits.GasProduced);
                        Assert.AreEqual(UnitsConversion("Mscf/d", us_Points[j].GasProduced).Value, metric_Points[j].GasProduced, 0.2);
                        Assert.AreEqual("sm3/d", metric_PointUnits.LiquidProduced);
                        Assert.AreEqual(UnitsConversion("STB/d", us_Points[j].LiquidProduced).Value, metric_Points[j].LiquidProduced, 0.2);
                        Assert.AreEqual("sm3/d", metric_PointUnits.OilProduced);
                        Assert.AreEqual(UnitsConversion("STB/d", us_Points[j].OilProduced).Value, metric_Points[j].OilProduced, 0.2);
                        Assert.AreEqual("sm3/d", metric_PointUnits.WaterProduced);
                        Assert.AreEqual(UnitsConversion("STB/d", us_Points[j].WaterProduced).Value, metric_Points[j].WaterProduced, 0.2);
                    }
                }

                #endregion Validation Check for Performance Curves - Metric
            }
            finally
            {
                RemoveWell("GLWELL_0001");
                ChangeUnitSystem("US");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UnitsCheckforNFAWB()
        {
            SettingType settingType = SettingType.System;
            SettingDTO systemSettings = SettingService.GetSettingsByType(settingType.ToString()).FirstOrDefault(x => x.Name == SettingServiceStringConstants.UNIT_SYSTEM); //"Choke Size Tolerance Limit");
            SystemSettingDTO settingValue = SettingService.GetSystemSettingByName(systemSettings.Name);
            try
            {
                WellDTO wellNF = AddNonRRLWell("NFWWELL_0001", WellTypeId.NF);
                //US
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                AssemblyDTO assembly = WellboreComponentService.GetAssemblyByWellId(wellNF.Id.ToString());
                string assemblyId = assembly.Id.ToString();
                WellTestHeaderDTO[] wellTestHeaders = WellTestDataService.GetValidWellTestHeadersByWellId(wellNF.Id.ToString());
                string testId = wellTestHeaders.FirstOrDefault().Id.ToString();
                NodalAnalysisInputAndUnitsDTO us_input = WellTestDataService.GetAnalysisInputDataAndUnits(testId);
                AnalysisResultsAndUnitsDTO us_anaysisinput = WellTestDataService.PerformAnalysis(us_input);

                //Metric
                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                NodalAnalysisInputAndUnitsDTO metric_input = WellTestDataService.GetAnalysisInputDataAndUnits(testId);
                AnalysisResultsAndUnitsDTO metric_anaysisinput = WellTestDataService.PerformAnalysis(metric_input);

                #region Validation Check for the Analysis Input - US

                //Calibration Data
                CalibrationInputUnitsDTO us_calibrationUnits = us_input.CalibrationData.Units;
                //LFactor
                Assert.AreEqual(4, (int)us_calibrationUnits.LFactor.Precision);
                Assert.AreEqual(0.1, us_calibrationUnits.LFactor.Min);
                Assert.AreEqual(2, us_calibrationUnits.LFactor.Max);
                Assert.AreEqual("fraction", us_calibrationUnits.LFactor.UnitKey);
                //Productivity Index
                Assert.AreEqual(4, (int)us_calibrationUnits.ProductivityIndex.Precision);
                Assert.AreEqual(0.0001, us_calibrationUnits.ProductivityIndex.Min);
                Assert.AreEqual(1000000, us_calibrationUnits.ProductivityIndex.Max);
                Assert.AreEqual("STB/d/psi", us_calibrationUnits.ProductivityIndex.UnitKey);
                //Resorvior Pressure
                Assert.AreEqual(2, (int)us_calibrationUnits.ReservoirPressure.Precision);
                Assert.AreEqual(14.7, us_calibrationUnits.ReservoirPressure.Min);
                Assert.AreEqual(25000, us_calibrationUnits.ReservoirPressure.Max);
                Assert.AreEqual("psia", us_calibrationUnits.ReservoirPressure.UnitKey);

                //Model Data - Solution Node
                AnalysisNodeUnitsDTO us_solNode = us_input.ModelData.SolutionNode.Units;
                Assert.AreEqual("ft", us_solNode.MD);

                //Model Data - Solution Nodes
                AnalysisNodeUnitsDTO us_solNodes = us_input.ModelData.SolutionNodes.Units;
                Assert.AreEqual("ft", us_solNodes.MD);

                //Model Data - Start Node
                AnalysisNodeUnitsDTO us_stNode = us_input.ModelData.StartNode.Units;
                Assert.AreEqual("ft", us_stNode.MD);

                //Model Data - Start Nodes
                AnalysisNodeUnitsDTO us_stNodes = us_input.ModelData.StartNodes.Units;
                Assert.AreEqual("ft", us_stNodes.MD);

                //Test Data
                GeneralTestInputUnitsDTO us_testInputs = us_input.TestData.Units;

                //Downhole Gauge Pressure
                Assert.AreEqual(2, (int)us_testInputs.DownholeGaugePressure.Precision);
                Assert.AreEqual(14.7, us_testInputs.DownholeGaugePressure.Min);
                Assert.AreEqual(25000, us_testInputs.DownholeGaugePressure.Max);
                Assert.AreEqual("psia", us_testInputs.DownholeGaugePressure.UnitKey);
                //Flowing Bottomhole Pressure
                Assert.AreEqual(2, (int)us_testInputs.FlowingBottomholePressure.Precision);
                Assert.AreEqual(14.7, us_testInputs.FlowingBottomholePressure.Min);
                Assert.AreEqual(25000, us_testInputs.FlowingBottomholePressure.Max);
                Assert.AreEqual("psia", us_testInputs.FlowingBottomholePressure.UnitKey);
                //Gas Oil Ratio
                Assert.AreEqual(4, (int)us_testInputs.GasOilRatio.Precision);
                Assert.AreEqual("scf/STB", us_testInputs.GasOilRatio.UnitKey);
                //Gas Rate
                Assert.AreEqual(2, (int)us_testInputs.GasRate.Precision);
                Assert.AreEqual(0, us_testInputs.GasRate.Min);
                Assert.AreEqual(50000, us_testInputs.GasRate.Max);
                Assert.AreEqual("Mscf/d", us_testInputs.GasRate.UnitKey);
                //Oil Rate
                Assert.AreEqual(1, (int)us_testInputs.OilRate.Precision);
                Assert.AreEqual(0, us_testInputs.OilRate.Min);
                Assert.AreEqual(10000, us_testInputs.OilRate.Max);
                Assert.AreEqual("STB/d", us_testInputs.OilRate.UnitKey);
                //Total Gas Rate
                Assert.AreEqual(2, (int)us_testInputs.TotalGasRate.Precision);
                Assert.AreEqual(0, us_testInputs.TotalGasRate.Min);
                Assert.AreEqual(50000, us_testInputs.TotalGasRate.Max);
                Assert.AreEqual("Mscf/d", us_testInputs.TotalGasRate.UnitKey);
                //Water Cut
                Assert.AreEqual(4, (int)us_testInputs.WaterCut.Precision);
                Assert.AreEqual("fraction", us_testInputs.WaterCut.UnitKey);
                //Water Rate
                Assert.AreEqual(1, (int)us_testInputs.WaterRate.Precision);
                Assert.AreEqual(0, us_testInputs.WaterRate.Min);
                Assert.AreEqual(10000, us_testInputs.WaterRate.Max);
                Assert.AreEqual("STB/d", us_testInputs.WaterRate.UnitKey);
                //Well Head Pressure
                Assert.AreEqual(2, (int)us_testInputs.WellHeadPressure.Precision);
                Assert.AreEqual(14.7, us_testInputs.WellHeadPressure.Min);
                Assert.AreEqual(15000, us_testInputs.WellHeadPressure.Max);
                Assert.AreEqual("psia", us_testInputs.WellHeadPressure.UnitKey);
                //WellHeadTemperature
                Assert.AreEqual(1, (int)us_testInputs.WellHeadTemperature.Precision);
                Assert.AreEqual(0, us_testInputs.WellHeadTemperature.Min);
                Assert.AreEqual(1000, us_testInputs.WellHeadTemperature.Max);
                Assert.AreEqual("F", us_testInputs.WellHeadTemperature.UnitKey);

                #endregion Validation Check for the Analysis Input - US

                #region Validation Check for the Analysis Input - Metric

                //Calibration Data
                CalibrationInputUnitsDTO metric_calibrationUnits = metric_input.CalibrationData.Units;
                CalibrationInputDTO us_calibrationValue = us_input.CalibrationData.Value;
                CalibrationInputDTO metric_calibrationValue = metric_input.CalibrationData.Value;
                //LFactor
                Assert.AreEqual(4, (int)metric_calibrationUnits.LFactor.Precision);
                Assert.AreEqual(0.1, metric_calibrationUnits.LFactor.Min);
                Assert.AreEqual(2, metric_calibrationUnits.LFactor.Max);
                Assert.AreEqual("fraction", metric_calibrationUnits.LFactor.UnitKey);
                //Productivity Index
                Assert.AreEqual(4, (int)metric_calibrationUnits.ProductivityIndex.Precision);
                Assert.AreEqual(UnitConversion("STB/d/psi", us_calibrationUnits.ProductivityIndex.Min), metric_calibrationUnits.ProductivityIndex.Min);
                Assert.AreEqual(UnitConversion("STB/d/psi", us_calibrationUnits.ProductivityIndex.Max), metric_calibrationUnits.ProductivityIndex.Max);
                Assert.AreEqual("sm3/d/kPa", metric_calibrationUnits.ProductivityIndex.UnitKey);
                Assert.AreEqual(UnitConversion("STB/d/psi", us_calibrationValue.ProductivityIndex), metric_calibrationValue.ProductivityIndex);
                //Resorvior Pressure
                Assert.AreEqual(1, (int)metric_calibrationUnits.ReservoirPressure.Precision);
                Assert.AreEqual(UnitsConversion("psia", us_calibrationUnits.ReservoirPressure.Min), metric_calibrationUnits.ReservoirPressure.Min);
                Assert.AreEqual(UnitsConversion("psia", us_calibrationUnits.ReservoirPressure.Max), metric_calibrationUnits.ReservoirPressure.Max);
                Assert.AreEqual("kPa", metric_calibrationUnits.ReservoirPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_calibrationValue.ReservoirPressure), metric_calibrationValue.ReservoirPressure);

                //Model Data - Solution Node
                AnalysisNodeUnitsDTO metric_solNode = metric_input.ModelData.SolutionNode.Units;
                AnalysisNodeDTO us_solNodeValue = us_input.ModelData.SolutionNode.Value;
                AnalysisNodeDTO metric_solNodeValue = metric_input.ModelData.SolutionNode.Value;
                Assert.AreEqual("m", metric_solNode.MD);
                Assert.AreEqual(Math.Round(UnitsConversion("ft", us_solNodeValue.MD).Value, 3, MidpointRounding.ToEven), metric_solNodeValue.MD);
                //Model Data - Solution Nodes
                AnalysisNodeUnitsDTO metric_solNodes = metric_input.ModelData.SolutionNodes.Units;
                AnalysisNodeDTO[] us_solNodeValues = us_input.ModelData.SolutionNodes.Values;
                AnalysisNodeDTO[] metric_solNodeValues = metric_input.ModelData.SolutionNodes.Values;
                Assert.AreEqual("m", metric_solNodes.MD);
                Assert.AreEqual(us_solNodeValues.Count(), metric_solNodeValues.Count());
                for (int i = 0; i < us_solNodeValues.Count(); i++)
                {
                    Assert.AreEqual(Math.Round(UnitsConversion("ft", us_solNodeValues[i].MD).Value, 3, MidpointRounding.ToEven), metric_solNodeValues[i].MD);
                }
                //Model Data - Start Node
                AnalysisNodeUnitsDTO metric_stNode = metric_input.ModelData.StartNode.Units;
                AnalysisNodeDTO us_stNodeValue = us_input.ModelData.StartNode.Value;
                AnalysisNodeDTO metric_stNodeValue = metric_input.ModelData.StartNode.Value;
                Assert.AreEqual("m", metric_stNode.MD);
                Assert.AreEqual(Math.Round(UnitsConversion("ft", us_stNodeValue.MD).Value, 3, MidpointRounding.ToEven), metric_stNodeValue.MD);
                //Model Data - Start Nodes
                AnalysisNodeUnitsDTO metric_stNodes = metric_input.ModelData.StartNodes.Units;
                Assert.AreEqual("m", metric_stNodes.MD);
                AnalysisNodeDTO[] us_stNodesValues = us_input.ModelData.StartNodes.Values;
                AnalysisNodeDTO[] metric_stNodesValues = metric_input.ModelData.StartNodes.Values;
                Assert.AreEqual("m", metric_solNodes.MD);
                Assert.AreEqual(us_stNodesValues.Count(), metric_stNodesValues.Count());
                for (int i = 0; i < us_solNodeValues.Count(); i++)
                {
                    Assert.AreEqual(Math.Round(UnitsConversion("ft", us_stNodesValues[i].MD).Value, 3, MidpointRounding.ToEven), metric_stNodesValues[i].MD);
                }
                //Test Data
                GeneralTestInputUnitsDTO metric_testInputs = metric_input.TestData.Units;
                GeneralTestInputDTO us_testValue = us_input.TestData.Value;
                GeneralTestInputDTO metric_testValue = metric_input.TestData.Value;

                //Downhole Gauge Pressure
                Assert.AreEqual(1, (int)metric_testInputs.DownholeGaugePressure.Precision);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.DownholeGaugePressure.Min), metric_testInputs.DownholeGaugePressure.Min);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.DownholeGaugePressure.Max), metric_testInputs.DownholeGaugePressure.Max);
                Assert.AreEqual("kPa", metric_testInputs.DownholeGaugePressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_testValue.DownholeGaugePressure), metric_testValue.DownholeGaugePressure);
                //Flowing Bottomhole Pressure
                Assert.AreEqual(1, (int)metric_testInputs.FlowingBottomholePressure.Precision);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.FlowingBottomholePressure.Min), metric_testInputs.FlowingBottomholePressure.Min);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.FlowingBottomholePressure.Max), metric_testInputs.FlowingBottomholePressure.Max);
                Assert.AreEqual("kPa", metric_testInputs.FlowingBottomholePressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_testValue.FlowingBottomholePressure), metric_testValue.FlowingBottomholePressure);
                //Gas Oil Ratio
                Assert.AreEqual(5, (int)metric_testInputs.GasOilRatio.Precision);
                Assert.AreEqual("sm3/sm3", metric_testInputs.GasOilRatio.UnitKey);
                //Gas Rate
                Assert.AreEqual(3, (int)metric_testInputs.GasRate.Precision);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testInputs.GasRate.Min), metric_testInputs.GasRate.Min);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testInputs.GasRate.Max), metric_testInputs.GasRate.Max);
                Assert.AreEqual("sm3/d", metric_testInputs.GasRate.UnitKey);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testValue.GasRate), metric_testValue.GasRate);
                //Oil Rate
                Assert.AreEqual(3, (int)metric_testInputs.OilRate.Precision);
                Assert.AreEqual(UnitsConversion("STB/d", us_testInputs.OilRate.Min), metric_testInputs.OilRate.Min);
                Assert.AreEqual(UnitsConversion("STB/d", us_testInputs.OilRate.Max), metric_testInputs.OilRate.Max);
                Assert.AreEqual("sm3/d", metric_testInputs.OilRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_testValue.OilRate), metric_testValue.OilRate);
                //Total Gas Rate
                Assert.AreEqual(3, (int)metric_testInputs.TotalGasRate.Precision);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testInputs.TotalGasRate.Min), metric_testInputs.TotalGasRate.Min);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testInputs.TotalGasRate.Max), metric_testInputs.TotalGasRate.Max);
                Assert.AreEqual("sm3/d", metric_testInputs.TotalGasRate.UnitKey);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_testValue.TotalGasRate), metric_testValue.TotalGasRate);
                //Water Cut
                Assert.AreEqual(4, (int)metric_testInputs.WaterCut.Precision);
                Assert.AreEqual("fraction", metric_testInputs.WaterCut.UnitKey);
                //Water Rate
                Assert.AreEqual(3, (int)metric_testInputs.WaterRate.Precision);
                Assert.AreEqual(UnitsConversion("STB/d", us_testInputs.WaterRate.Min), metric_testInputs.WaterRate.Min);
                Assert.AreEqual(UnitsConversion("STB/d", us_testInputs.WaterRate.Max), metric_testInputs.WaterRate.Max);
                Assert.AreEqual("sm3/d", metric_testInputs.WaterRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_testValue.WaterRate), metric_testValue.WaterRate);
                //Well Head Pressure
                Assert.AreEqual(1, (int)metric_testInputs.WellHeadPressure.Precision);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.WellHeadPressure.Min), metric_testInputs.WellHeadPressure.Min);
                Assert.AreEqual(UnitsConversion("psia", us_testInputs.WellHeadPressure.Max), metric_testInputs.WellHeadPressure.Max);
                Assert.AreEqual("kPa", metric_testInputs.WellHeadPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_testValue.WellHeadPressure), metric_testValue.WellHeadPressure);
                //WellHeadTemperature
                Assert.AreEqual(1, (int)metric_testInputs.WellHeadTemperature.Precision);
                Assert.AreEqual(UnitsConversion("F", us_testInputs.WellHeadTemperature.Min), metric_testInputs.WellHeadTemperature.Min);
                Assert.AreEqual(UnitsConversion("F", us_testInputs.WellHeadTemperature.Max), metric_testInputs.WellHeadTemperature.Max);
                Assert.AreEqual("C", metric_testInputs.WellHeadTemperature.UnitKey);
                Assert.AreEqual(UnitsConversion("F", us_testValue.WellHeadTemperature), metric_testValue.WellHeadTemperature);

                #endregion Validation Check for the Analysis Input - Metric

                #region Validation Check for the Pressure Drop Analysis - US

                //Validating Gas Lift Pressure Drop Analysis
                //Gradient Curves - US
                GradientCurvesAndUnitsDTO us_GradientCurves = us_anaysisinput.PressureDropResults.GradientCurves;

                Assert.AreEqual("ft", us_GradientCurves.GradientCurves.Units.MD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.GradientCurves.Units.TVD.UnitKey);
                Assert.AreEqual("F", us_GradientCurves.GradientCurves.Units.Temperature.UnitKey);
                Assert.AreEqual("psia", us_GradientCurves.GradientCurves.Units.TubingPressure.UnitKey);
                //Depth Lines - US
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.DownholeGaugeMD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.DownholeGaugeTVD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.InjectionMD.UnitKey);
                Assert.AreEqual("ft", us_GradientCurves.DepthLines.Units.InjectionTVD.UnitKey);

                //Solution Point - US
                SolutionPointAndUnitsDTO us_SolutionPoint = us_anaysisinput.PressureDropResults.SolutionPoint;
                Assert.AreEqual("psia", us_SolutionPoint.Units.BottomholePressure.UnitKey);
                Assert.AreEqual("psia", us_SolutionPoint.Units.BubblePointPressure.UnitKey);
                Assert.AreEqual("Mscf/d", us_SolutionPoint.Units.GasRate.UnitKey);
                Assert.AreEqual("STB/d", us_SolutionPoint.Units.LiquidRate.UnitKey);
                Assert.AreEqual("STB/d", us_SolutionPoint.Units.OilRate.UnitKey);
                Assert.AreEqual("psia", us_SolutionPoint.Units.Pressure.UnitKey);
                Assert.AreEqual("F", us_SolutionPoint.Units.Temperature.UnitKey);
                Assert.AreEqual("fraction", us_SolutionPoint.Units.WaterCut.UnitKey);
                Assert.AreEqual("STB/d", us_SolutionPoint.Units.WaterRate.UnitKey);

                #endregion Validation Check for the Pressure Drop Analysis - US

                #region Validation Check for the Pressure Drop Analysis - Metric

                //Gradient Curves - Metric
                GradientCurvesAndUnitsDTO metric_GradientCurves = metric_anaysisinput.PressureDropResults.GradientCurves;

                Assert.AreEqual("m", metric_GradientCurves.GradientCurves.Units.MD.UnitKey);
                Assert.AreEqual("m", metric_GradientCurves.GradientCurves.Units.TVD.UnitKey);
                Assert.AreEqual("C", metric_GradientCurves.GradientCurves.Units.Temperature.UnitKey);
                Assert.AreEqual("kPa", metric_GradientCurves.GradientCurves.Units.TubingPressure.UnitKey);
                Assert.AreEqual(us_GradientCurves.GradientCurves.Values.Count(), metric_GradientCurves.GradientCurves.Values.Count());
                for (int i = 0; i < us_GradientCurves.GradientCurves.Values.Count(); i++)
                {
                    Assert.AreEqual(Math.Round(UnitsConversion("ft", us_GradientCurves.GradientCurves.Values[i].MD).Value, 2, MidpointRounding.ToEven), metric_GradientCurves.GradientCurves.Values[i].MD, 0.2);
                    Assert.AreEqual(Math.Round(UnitsConversion("ft", us_GradientCurves.GradientCurves.Values[i].TVD).Value, 2, MidpointRounding.ToEven), metric_GradientCurves.GradientCurves.Values[i].TVD, 0.2);
                    Assert.AreEqual(Math.Round(UnitsConversion("F", us_GradientCurves.GradientCurves.Values[i].Temperature).Value, 1), metric_GradientCurves.GradientCurves.Values[i].Temperature, 0.2);
                    Assert.AreEqual(Math.Round(UnitsConversion("psia", us_GradientCurves.GradientCurves.Values[i].TubingPressure).Value, 2, MidpointRounding.ToEven), metric_GradientCurves.GradientCurves.Values[i].TubingPressure, 0.2);
                }

                //Depth Lines - Metric
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.DownholeGaugeMD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.DownholeGaugeMD ?? 0).Value, metric_GradientCurves.DepthLines.Value.DownholeGaugeMD ?? 0, 0.2);
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.DownholeGaugeTVD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.DownholeGaugeTVD ?? 0).Value, metric_GradientCurves.DepthLines.Value.DownholeGaugeTVD ?? 0, 0.2);
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.InjectionMD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.InjectionMD).Value, metric_GradientCurves.DepthLines.Value.InjectionMD, 0.2);
                Assert.AreEqual("m", metric_GradientCurves.DepthLines.Units.InjectionTVD.UnitKey);
                Assert.AreEqual(UnitsConversion("ft", us_GradientCurves.DepthLines.Value.InjectionTVD).Value, metric_GradientCurves.DepthLines.Value.InjectionTVD, 0.2);

                //Solution Point - Metric
                SolutionPointAndUnitsDTO metric_SolutionPoint = metric_anaysisinput.PressureDropResults.SolutionPoint;
                Assert.AreEqual("kPa", metric_SolutionPoint.Units.BottomholePressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_SolutionPoint.Value.BottomholePressure).Value, metric_SolutionPoint.Value.BottomholePressure.Value, 0.2);
                Assert.AreEqual("kPa", metric_SolutionPoint.Units.BubblePointPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_SolutionPoint.Value.BubblePointPressure).Value, metric_SolutionPoint.Value.BubblePointPressure.Value, 0.2);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.GasRate.UnitKey);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_SolutionPoint.Value.GasRate).Value, metric_SolutionPoint.Value.GasRate, 0.2);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.LiquidRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_SolutionPoint.Value.LiquidRate).Value, metric_SolutionPoint.Value.LiquidRate, 0.2);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.OilRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_SolutionPoint.Value.OilRate).Value, metric_SolutionPoint.Value.OilRate, 0.2);
                Assert.AreEqual("kPa", metric_SolutionPoint.Units.Pressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_SolutionPoint.Value.Pressure).Value, metric_SolutionPoint.Value.Pressure, 0.2);
                Assert.AreEqual("C", metric_SolutionPoint.Units.Temperature.UnitKey);
                Assert.AreEqual(UnitsConversion("F", us_SolutionPoint.Value.Temperature).Value, metric_SolutionPoint.Value.Temperature, 0.2);
                Assert.AreEqual("fraction", metric_SolutionPoint.Units.WaterCut.UnitKey);
                Assert.AreEqual("sm3/d", metric_SolutionPoint.Units.WaterRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_SolutionPoint.Value.WaterRate).Value, metric_SolutionPoint.Value.WaterRate, 0.2);

                #endregion Validation Check for the Pressure Drop Analysis - Metric

                #region Validation Check for Operating Point Analysis - US

                //Operating Point Analysis-US
                SolutionPointAndUnitsDTO us_OperatingPoint = us_anaysisinput.OperatingPointResults.OperatingPoint;
                FlowCurveDataPointArrayAndUnitsDTO us_FlowCurves = us_anaysisinput.OperatingPointResults.FlowCurves;
                //Operating Point-US
                Assert.AreEqual("psia", us_OperatingPoint.Units.BottomholePressure.UnitKey);
                Assert.AreEqual("psia", us_OperatingPoint.Units.BubblePointPressure.UnitKey);
                Assert.AreEqual("Mscf/d", us_OperatingPoint.Units.GasRate.UnitKey);
                Assert.AreEqual("STB/d", us_OperatingPoint.Units.LiquidRate.UnitKey);
                Assert.AreEqual("STB/d", us_OperatingPoint.Units.OilRate.UnitKey);
                Assert.AreEqual("psia", us_OperatingPoint.Units.Pressure.UnitKey);
                Assert.AreEqual("F", us_OperatingPoint.Units.Temperature.UnitKey);
                Assert.AreEqual("STB/d", us_OperatingPoint.Units.WaterRate.UnitKey);
                //Flow Curves-US
                Assert.AreEqual("psia", us_FlowCurves.Units.InflowPressure.UnitKey);
                Assert.AreEqual("STB/d", us_FlowCurves.Units.OilRate.UnitKey);
                Assert.AreEqual("psia", us_FlowCurves.Units.OutflowPressure.UnitKey);
                Assert.AreEqual("STB/d", us_FlowCurves.Units.Rate.UnitKey);

                #endregion Validation Check for Operating Point Analysis - US

                #region Validation Check for Operating Point Analysis - Metric

                //Operating Point Analysis-Metric
                SolutionPointAndUnitsDTO metric_OperatingPoint = metric_anaysisinput.OperatingPointResults.OperatingPoint;
                FlowCurveDataPointArrayAndUnitsDTO metric_FlowCurves = metric_anaysisinput.OperatingPointResults.FlowCurves;
                //Operating Point-Metric
                Assert.AreEqual("kPa", metric_OperatingPoint.Units.BottomholePressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_OperatingPoint.Value.BottomholePressure).Value, metric_OperatingPoint.Value.BottomholePressure.Value, 0.2);
                Assert.AreEqual("kPa", metric_OperatingPoint.Units.BubblePointPressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_OperatingPoint.Value.BubblePointPressure).Value, metric_OperatingPoint.Value.BubblePointPressure.Value, 0.2);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.GasRate.UnitKey);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_OperatingPoint.Value.GasRate).Value, metric_OperatingPoint.Value.GasRate, 0.2);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.LiquidRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_OperatingPoint.Value.LiquidRate).Value, metric_OperatingPoint.Value.LiquidRate, 0.2);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.OilRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_OperatingPoint.Value.OilRate).Value, metric_OperatingPoint.Value.OilRate, 0.2);
                Assert.AreEqual("kPa", metric_OperatingPoint.Units.Pressure.UnitKey);
                Assert.AreEqual(UnitsConversion("psia", us_OperatingPoint.Value.Pressure).Value, metric_OperatingPoint.Value.Pressure, 0.2);
                Assert.AreEqual("C", metric_OperatingPoint.Units.Temperature.UnitKey);
                Assert.AreEqual(UnitsConversion("F", us_OperatingPoint.Value.Temperature).Value, metric_OperatingPoint.Value.Temperature, 0.2);
                Assert.AreEqual("sm3/d", metric_OperatingPoint.Units.WaterRate.UnitKey);
                Assert.AreEqual(UnitsConversion("STB/d", us_OperatingPoint.Value.WaterRate).Value, metric_OperatingPoint.Value.WaterRate, 0.2);

                //Flow Curves-Metric
                Assert.AreEqual("kPa", metric_FlowCurves.Units.InflowPressure.UnitKey);
                Assert.AreEqual("sm3/d", metric_FlowCurves.Units.OilRate.UnitKey);
                Assert.AreEqual("kPa", metric_FlowCurves.Units.OutflowPressure.UnitKey);
                Assert.AreEqual("sm3/d", metric_FlowCurves.Units.Rate.UnitKey);
                Assert.AreEqual(us_FlowCurves.Values.Count(), metric_FlowCurves.Values.Count());
                for (int i = 0; i < metric_FlowCurves.Values.Count(); i++)
                {
                    Assert.AreEqual(UnitsConversion("psia", us_FlowCurves.Values[i].InflowPressure).Value, metric_FlowCurves.Values[i].InflowPressure.Value, 0.2);
                    Assert.AreEqual(UnitsConversion("STB/d", us_FlowCurves.Values[i].OilRate).Value, metric_FlowCurves.Values[i].OilRate, 0.2);
                    Assert.AreEqual(UnitsConversion("psia", us_FlowCurves.Values[i].OutflowPressure).Value, metric_FlowCurves.Values[i].OutflowPressure.Value, 0.2);
                    Assert.AreEqual(UnitsConversion("STB/d", us_FlowCurves.Values[i].Rate).Value, metric_FlowCurves.Values[i].Rate, 0.2);
                }

                #endregion Validation Check for Operating Point Analysis - Metric

                #region Validation Check for Performance Curves - US

                //Performance Curve - US
                WellPerformanceCurveAndUnitsDTO us_PerformanceCureves = us_anaysisinput.WellPerformanceCurve;
                Assert.AreEqual("psia", us_PerformanceCureves.WellPerformanceCurve.Units.WellHeadPressure.UnitKey);
                Assert.AreEqual("STB/d", us_PerformanceCureves.WellPerformanceCurve.Units.LiquidProduced.UnitKey);
                Assert.AreEqual("STB/d", us_PerformanceCureves.WellPerformanceCurve.Units.OilProduced.UnitKey);
                Assert.AreEqual("Mscf/d", us_PerformanceCureves.WellPerformanceCurve.Units.GasProduced.UnitKey);
                Assert.AreEqual("Hz", us_PerformanceCureves.OperatingFrequency.UnitKey);

                #endregion Validation Check for Performance Curves - US

                #region Validation Check for Performance Curves - Metric

                //Performance Curve - Metric
                WellPerformanceCurveAndUnitsDTO metric_PerformanceCureves = metric_anaysisinput.WellPerformanceCurve;
                Assert.AreEqual("sm3/d", metric_PerformanceCureves.WellPerformanceCurve.Units.LiquidProduced.UnitKey);
                Assert.AreEqual("sm3/d", metric_PerformanceCureves.WellPerformanceCurve.Units.OilProduced.UnitKey);
                Assert.AreEqual("sm3/d", metric_PerformanceCureves.WellPerformanceCurve.Units.GasProduced.UnitKey);
                Assert.AreEqual("kPa", metric_PerformanceCureves.WellPerformanceCurve.Units.WellHeadPressure.UnitKey);
                Assert.AreEqual(us_PerformanceCureves.WellPerformanceCurve.Values.Count(), metric_PerformanceCureves.WellPerformanceCurve.Values.Count());
                for (int i = 0; i < metric_PerformanceCureves.WellPerformanceCurve.Values.Count(); i++)
                {
                    Assert.AreEqual(UnitsConversion("Mscf/d", us_PerformanceCureves.WellPerformanceCurve.Values[i].GasProduced).Value, metric_PerformanceCureves.WellPerformanceCurve.Values[i].GasProduced.Value, 0.2);
                    Assert.AreEqual(UnitsConversion("STB/d", us_PerformanceCureves.WellPerformanceCurve.Values[i].LiquidProduced).Value, metric_PerformanceCureves.WellPerformanceCurve.Values[i].LiquidProduced.Value, 0.2);
                    Assert.AreEqual(UnitsConversion("STB/d", us_PerformanceCureves.WellPerformanceCurve.Values[i].OilProduced).Value, metric_PerformanceCureves.WellPerformanceCurve.Values[i].OilProduced.Value, 0.2);
                    Assert.AreEqual(UnitsConversion("psia", us_PerformanceCureves.WellPerformanceCurve.Values[i].WellHeadPressure ?? 0).Value, metric_PerformanceCureves.WellPerformanceCurve.Values[i].WellHeadPressure ?? 0, 0.2);
                }
                Assert.AreEqual(UnitsConversion("STB/d", us_PerformanceCureves.MaximumLiquidProduced).Value, metric_PerformanceCureves.MaximumLiquidProduced, 0.2);
                Assert.AreEqual(UnitsConversion("STB/d", us_PerformanceCureves.MaximumOilProduced).Value, metric_PerformanceCureves.MaximumOilProduced, 0.2);
                Assert.AreEqual(UnitsConversion("Mscf/d", us_PerformanceCureves.MaximumGasProduced).Value, metric_PerformanceCureves.MaximumGasProduced, 0.2);
                Assert.AreEqual(UnitsConversion("psia", us_PerformanceCureves.MaximumWellHeadPressure).Value, metric_PerformanceCureves.MaximumWellHeadPressure, 0.2);

                #endregion Validation Check for Performance Curves - Metric
            }
            finally
            {
                RemoveWell("NFWWELL_0001");
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AddtwoOptionsPIPandPDPForESP()
        {
            PIPandPDPOption[] espPIPandPDP = ModelFileService.GetPIPandPDPOption(WellTypeId.ESP.ToString());
            Assert.AreEqual(2, espPIPandPDP.Count());
            Assert.IsTrue(espPIPandPDP.Contains(PIPandPDPOption.Has_PumpIntakePressure));
            Assert.IsTrue(espPIPandPDP.Contains(PIPandPDPOption.Has_PumpDischargePressure));
        }

        public double? UnitConversion(string unitKey, double? value)
        {
            double? Metricvalue = null;
            //"STB/d/psi" to sm3/d/kPa
            Metricvalue = value * 0.0230591593;
            return Metricvalue;
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void LFactorTuning()
        {
            try
            {
                WellDTO wellESP = AddNonRRLWell("ESPWELL_0001", WellTypeId.ESP, false, CalibrationMethodId.LFactor);
                WellDTO wellGL = AddNonRRLWell("GLWELL_0001", WellTypeId.GLift, false, CalibrationMethodId.LFactor);
                WellDTO wellNF = AddNonRRLWell("NFWWELL_0001", WellTypeId.NF, false, CalibrationMethodId.LFactor);
                //string espAssemlblyId = WellboreComponentService.GetAssemblyByWellId(wellESP.Id.ToString()).Id.ToString();
                //string glAssemlblyId = WellboreComponentService.GetAssemblyByWellId(wellGL.Id.ToString()).Id.ToString();
                //string nfAssemlblyId = WellboreComponentService.GetAssemblyByWellId(wellNF.Id.ToString()).Id.ToString();
                WellTestAndUnitsDTO espWellTest = WellTestDataService.GetLatestValidWellTestByWellId(wellESP.Id.ToString());
                Assert.IsNotNull(espWellTest.Value.FlowingBottomholePressure, "Flowing bottom hole pressure is null after Lfactor tuning");
                WellTestAndUnitsDTO glWellTest = WellTestDataService.GetLatestValidWellTestByWellId(wellGL.Id.ToString());
                Assert.IsNotNull(glWellTest.Value.FlowingBottomholePressure, "Flowing bottom hole pressure is null after Lfactor tuning");
                WellTestAndUnitsDTO nfWellTest = WellTestDataService.GetLatestValidWellTestByWellId(wellNF.Id.ToString());
                Assert.IsNotNull(nfWellTest.Value.FlowingBottomholePressure, "Flowing bottom hole pressure is null after Lfactor tuning");
            }
            finally
            {
                RemoveWell("ESPWELL_0001");
                RemoveWell("GLWELL_0001");
                RemoveWell("NFWWELL_0001");
            }
        }

        public void AddWellTestDataWL(long wellId, DateTime date, int addDays, int addHours = 6)
        {
            WellTestDTO testDataDTO = new WellTestDTO()
            {
                WellId = wellId,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 110,
                AverageTubingTemperature = 100,
                AverageCasingPressure = 1250,
                GasInjectionRate = 1000,
                FlowLinePressure = 50,
                SeparatorPressure = 30,
                GaugePressure = 12000,
                Oil = (decimal)495,
                Gas = 1842,
                Water = (decimal)100,
                ChokeSize = 50,
            };
            testDataDTO.SampleDate = date.AddDays(addDays).AddHours(addHours).ToUniversalTime();
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(wellId.ToString()).Units;
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WellTestsDateRangeverification()
        {
            WellDTO well = SetDefaultFluidType(new WellDTO()
            {
                Name = "Well",
                FacilityId = "RPOC_0001",
                DataConnection = GetDefaultCygNetDataConnection(),
                CommissionDate = DateTime.Now.AddDays(-30),
                AssemblyAPI = "RPOC_0001",
                SubAssemblyAPI = "RPOC_0001",
                WellType = WellTypeId.RRL,
                GasAllocationGroup = null,
                OilAllocationGroup = null,
                WaterAllocationGroup = null
            });

            WellConfigDTO wellConfig = new WellConfigDTO();
            wellConfig.Well = well;
            wellConfig.ModelConfig = ReturnBlankModel();
            //Well
            WellConfigDTO addedWellConfig = WellConfigurationService.AddWellConfig(wellConfig);
            Assert.IsNotNull(addedWellConfig);
            Assert.IsNotNull(addedWellConfig.Well);
            DateTime date = addedWellConfig.Well.CommissionDate.Value;
            _wellsToRemove.Add(addedWellConfig.Well);
            long assemblyId = WellboreComponentService.GetAssemblyByWellId(addedWellConfig.Well.Id.ToString()).Id;

            WellTestDTO[] bWellTests = WellTestDataService.GetAllValidWellTestByWellId(addedWellConfig.Well.Id.ToString());
            Assert.AreEqual(0, bWellTests.Count(), "Before adding well tests, Well Test count should be 0");

            try
            {
                AddWellTestDataWL(addedWellConfig.Well.Id, date, 1);
                AddWellTestDataWL(addedWellConfig.Well.Id, date, 2);
                AddWellTestDataWL(addedWellConfig.Well.Id, date, 2, 7);
                AddWellTestDataWL(addedWellConfig.Well.Id, date, 4);
                AddWellTestDataWL(addedWellConfig.Well.Id, date, 5);
            }
            catch (WebException e)
            {
                CheckResponseCode(e, HttpStatusCode.BadRequest);
            }

            WellTestDTO[] aWellTests = WellTestDataService.GetAllValidWellTestByWellId(addedWellConfig.Well.Id.ToString());
            Assert.AreEqual(5, aWellTests.Count(), "Well tests count is incorrect");

            //WellTestDTO[] wellTestsWithinDateRange = WellTestDataService.GetWellTestsByWellIdWithinDateRange(addedWellConfig.Well.Id.ToString(), DateTime.Now.AddDays(2).ToShortDateString(), DateTime.Now.AddDays(2).ToShortDateString());
            //Assert.AreEqual(2, wellTestsWithinDateRange.Count(), "Retrieved Well Tests count is incorrect ");

            WellTestDTO[] wellTestsWithinDateRange1 = WellTestDataService.GetWellTestsByWellIdWithinDateRange(addedWellConfig.Well.Id.ToString(), date.AddDays(2).ToShortDateString(), date.AddDays(3).ToShortDateString());
            Assert.AreEqual(2, wellTestsWithinDateRange1.Count(), "Retrieved Well Tests count is incorrect ");

            WellTestDTO[] wellTestsWithinDateRange2 = WellTestDataService.GetWellTestsByWellIdWithinDateRange(addedWellConfig.Well.Id.ToString(), date.AddDays(2).ToShortDateString(), date.AddDays(5).ToShortDateString());
            Assert.AreEqual(3, wellTestsWithinDateRange2.Count(), "Retrieved Well Tests count is incorrect ");

            WellTestDTO[] wellTestsWithinDateRange3 = WellTestDataService.GetWellTestsByWellIdWithinDateRange(addedWellConfig.Well.Id.ToString(), date.AddDays(1).ToShortDateString(), date.AddDays(6).ToShortDateString());
            Assert.AreEqual(5, wellTestsWithinDateRange3.Count(), "Retrieved Well Tests count is incorrect ");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WellTestsonMOPChange()
        {
            WellDTO well = SetDefaultFluidType(new WellDTO()
            {
                Name = "Well",
                FacilityId = "RPOC_0001",
                DataConnection = GetDefaultCygNetDataConnection(),
                CommissionDate = DateTime.Today.AddYears(-2),
                AssemblyAPI = "RPOC_0001",
                SubAssemblyAPI = "RPOC_0001",
                WellType = WellTypeId.NF,
                GasAllocationGroup = null,
                OilAllocationGroup = null,
                WaterAllocationGroup = null
            });

            WellConfigDTO wellConfig = new WellConfigDTO();
            wellConfig.Well = well;
            wellConfig.ModelConfig = ReturnBlankModel();
            //Well
            WellConfigDTO addedWellConfig = WellConfigurationService.AddWellConfig(wellConfig);
            Assert.IsNotNull(addedWellConfig);
            Assert.IsNotNull(addedWellConfig.Well);
            _wellsToRemove.Add(addedWellConfig.Well);
            long assemblyId = WellboreComponentService.GetAssemblyByWellId(addedWellConfig.Well.Id.ToString()).Id;
            try
            {
                AddWellTestDataWL(addedWellConfig.Well.Id, addedWellConfig.Well.CommissionDate.Value, -1);
                Assert.Fail("Well test added before the MOP chnage date");
            }
            catch (WebException e)
            {
                CheckResponseCode(e, HttpStatusCode.InternalServerError);
            }

            //Change MOP
            WellMoPHistoryDTO wellMoPHistoryDTO = new WellMoPHistoryDTO();
            wellMoPHistoryDTO.WellId = addedWellConfig.Well.Id;
            wellMoPHistoryDTO.WellType = WellTypeId.RRL;
            wellMoPHistoryDTO.ChangeDate = addedWellConfig.Well.CommissionDate.Value.AddDays(10).ToUniversalTime();
            wellMoPHistoryDTO.Comment = "Change Well type to RRL";
            WellService.ChangeWellType(wellMoPHistoryDTO);

            try
            {
                AddWellTestDataWL(addedWellConfig.Well.Id, addedWellConfig.Well.CommissionDate.Value, 8);
                Assert.Fail("Well test added before the MOP chnage date");
            }
            catch (WebException e)
            {
                CheckResponseCode(e, HttpStatusCode.InternalServerError);
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void SurfaceParameterValidationTests()
        {
            SetValuesInSystemSettings(SettingServiceStringConstants.TUNE_WELL_TEST_FOR_INVALID_SURFACE_PARAMETERS, "1");
            SetValuesInSystemSettings(SettingServiceStringConstants.BYPASS_SURFACE_PARAMETER_VALIDATION, "0");
            try
            {
                //GasInjection model in test documents not good for tuning
                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
             Tuple.Create("GasLift-LFactor2.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressureAndLFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR) } }),
            };
                foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
                {
                    string model = modelInfo.Item1;
                    WellTypeId wellType = modelInfo.Item2;
                    ModelFileOptionDTO options = modelInfo.Item3;

                    Trace.WriteLine("Testing model: " + model);
                    //Create a new well
                    WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddDays(-20), WellType = wellType }) });
                    var allWells = WellService.GetAllWells().ToList();
                    WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                    Assert.IsNotNull(well);
                    _wellsToRemove.Add(well);

                    ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                    options.Comment = "CASETest Upload " + modelInfo.Item1;
                    modelFile.Options = options;
                    modelFile.ApplicableDate = DateTime.Today.AddDays(-15).ToUniversalTime();
                    modelFile.WellId = well.Id;

                    byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                    Assert.IsNotNull(fileAsByteArray);
                    modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                    Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                    ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                    Assert.IsNotNull(ModelFileValidationData);
                    ModelFileService.AddWellModelFile(modelFile);
                    ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                    Assert.IsNotNull(newModelFile);
                    _modelFilesToRemove.Add(newModelFile.Id.ToString());

                    //add new wellTestData 1, 2, 3
                    WellTestDTO testDataDTO1 = new WellTestDTO()
                    {

                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 200,
                        AverageTubingTemperature = null,
                        AverageCasingPressure = 1000,
                        GasInjectionRate = 1000,
                        FlowLinePressure = null,
                        SeparatorPressure = null,
                        GaugePressure = 1900,
                        Oil = (decimal)1142,
                        Gas = 600,
                        Water = (decimal)1730,
                        ChokeSize = null,
                    };

                    testDataDTO1.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestAndUnitsDTO WellTestAndUnits = new WellTestAndUnitsDTO();
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO1;
                    WellTestDataService.SaveWellTest(WellTestAndUnits);

                    WellTestDTO testDataDTO2 = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 1000,
                        AverageTubingTemperature = null,
                        AverageCasingPressure = 1010,
                        GasInjectionRate = 1100,
                        FlowLinePressure = null,
                        SeparatorPressure = null,
                        GaugePressure = 50,
                        Oil = (decimal)197.8,
                        Gas = 150,
                        Water = (decimal)246.6,
                        ChokeSize = null,
                    };

                    testDataDTO2.SampleDate = (DateTime.Today.AddDays(-1).ToUniversalTime());
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO2;
                    WellTestDataService.SaveWellTest(WellTestAndUnits);

                    WellTestDTO testDataDTO3 = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 500,
                        AverageTubingTemperature = null,
                        AverageCasingPressure = 400,
                        GasInjectionRate = 300,
                        FlowLinePressure = null,
                        SeparatorPressure = null,
                        GaugePressure = 50,
                        Oil = (decimal)597.8,
                        Gas = 350,
                        Water = (decimal)646.6,
                        ChokeSize = null,
                    };

                    testDataDTO3.SampleDate = (DateTime.Today.AddDays(-2).ToUniversalTime());
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO3;
                    WellTestDataService.SaveWellTest(WellTestAndUnits);

                    WellTestDTO[] allTunedTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                    decimal? l1 = allTunedTests[0].LFactor;
                    decimal? l2 = allTunedTests[1].LFactor;
                    decimal? l3 = allTunedTests[2].LFactor;
                    for (int i = 0; i < allTunedTests.Length; i++)
                    {
                        allTunedTests[i].LFactor = 0;
                        WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, allTunedTests[i]));
                        allTunedTests[i].Status = WellTestStatus.TUNING_NOT_COMPLETE;
                        WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, allTunedTests[i]));
                    }
                    WellTestDataService.TuneWellTests(well.Id.ToString());
                    allTunedTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                    Assert.AreEqual("TUNING_SUCCEEDED", allTunedTests[0].Status.ToString(), "Well Test Status is not Success");

                    //WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                    //Assert.AreEqual(l1, allTunedAgainTests[0].LFactor);
                    //Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_RESERVOIR_PRESSURE_TOO_HIGH, allTunedAgainTests[0].Status);
                    //Assert.AreEqual(l2, allTunedAgainTests[1].LFactor);
                    //Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_RESERVOIR_PRESSURE_TOO_HIGH, allTunedAgainTests[1].Status);
                    //Assert.AreEqual(l3, allTunedAgainTests[2].LFactor);
                    //Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_LFATCOR_TOO_HIGH, allTunedAgainTests[2].Status);

                    //ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    //ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                }
            }
            finally
            {
                SetValuesInSystemSettings(SettingServiceStringConstants.TUNE_WELL_TEST_FOR_INVALID_SURFACE_PARAMETERS, "0");
                SetValuesInSystemSettings(SettingServiceStringConstants.BYPASS_SURFACE_PARAMETER_VALIDATION, "1");

            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ImportWellTestsValidations()
        {
            //GasInjection model in test documents not good for tuning and no WAG Injection has been added. Will be added when WAG is introduced in create well and save welltest
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
             Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } }),
             Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.PI, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
             Tuple.Create("WellfloWaterInjectionExample1.wflx", WellTypeId.WInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.InjectivityIndex, OptionalUpdate = new long[] { ((long)OptionalUpdates.CalculateChokeD_Factor), ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("WellfloGasLiftExampleTuningTrace.WFLX", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
             //Tuple.Create("WellfloGasInjectionExample1.wflx", WellTypeId.GInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
            };
            foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
            {
                int i = 1;
                string model = modelInfo.Item1;
                WellTypeId wellType = modelInfo.Item2;
                ModelFileOptionDTO options = modelInfo.Item3;

                Trace.WriteLine("Testing model: " + model);
                //Create a new well
                WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
                var allWells = WellService.GetAllWells().ToList();
                WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                Assert.IsNotNull(well);
                _wellsToRemove.Add(well);

                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                options.Comment = "CASETest Upload " + modelInfo.Item1;
                modelFile.Options = options;
                modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i);
                modelFile.WellId = well.Id;

                byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                Assert.IsNotNull(fileAsByteArray);
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                Assert.IsNotNull(ModelFileValidationData);
                ModelFileService.AddWellModelFile(modelFile);
                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());

                #region ESP

                if (wellType == WellTypeId.ESP)
                {
                    //Try to add WellTest and check its not added due to incorrect JSON
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "AllocatableTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        PumpIntakePressure = 10000,
                        PumpDischargePressure = 11000,
                        GaugePressure = 12000,
                        Oil = 50008888, //Incorect Value
                        Gas = 500,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                        Frequency = 20,
                        MotorVolts = 250,
                        MotorCurrent = 48,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    //WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                    List<WellTestDTO> data = new List<WellTestDTO>();
                    data.Add(testDataDTO);
                    WellTestDTO[] arrComponent = data.ToArray();
                    bool addWelltest = WellTestDataService.ImportWellTests(arrComponent);
                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNull(testDataDTOCheck);
                }

                #endregion ESP

                #region WaterInjection

                else if (wellType == WellTypeId.WInj)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 50008888, //Incorect Value
                        AverageTubingTemperature = 65,
                        PumpIntakePressure = 10000,
                        PumpDischargePressure = 11000,
                        GaugePressure = 12000,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    //WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                    List<WellTestDTO> data = new List<WellTestDTO>();
                    data.Add(testDataDTO);
                    WellTestDTO[] arrComponent = data.ToArray();
                    bool addWelltest = WellTestDataService.ImportWellTests(arrComponent);
                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNull(testDataDTOCheck);
                }

                #endregion WaterInjection

                #region GasLift

                else if (wellType == WellTypeId.GLift)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 658888, //Incorect Value
                        AverageCasingPressure = 1000,
                        GasInjectionRate = 1000,
                        FlowLinePressure = 50,
                        SeparatorPressure = 30,
                        GaugePressure = 12000,
                        Oil = (decimal)1497.8,
                        Gas = 500,
                        Water = (decimal)2246.6,
                        ChokeSize = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestAndUnitsDTO WellTestAndUnits = new WellTestAndUnitsDTO();
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO;
                    //WellTestDataService.SaveWellTest(WellTestAndUnits);
                    List<WellTestDTO> data = new List<WellTestDTO>();
                    data.Add(testDataDTO);
                    WellTestDTO[] arrComponent = data.ToArray();
                    bool addWelltest = WellTestDataService.ImportWellTests(arrComponent);
                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNull(testDataDTOCheck);
                }

                #endregion GasLift

                #region NF

                else if (wellType == WellTypeId.NF)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        GaugePressure = 12000,
                        Oil = 5000,
                        Gas = 5008888, //Incorect Value
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    //WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                    List<WellTestDTO> data = new List<WellTestDTO>();
                    data.Add(testDataDTO);
                    WellTestDTO[] arrComponent = data.ToArray();
                    bool addWelltest = WellTestDataService.ImportWellTests(arrComponent);
                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNull(testDataDTOCheck);
                }
                #endregion NF
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ImportWellTestsBackendAddition()
        {
            //GasInjection model in test documents not good for tuning
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
             Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } }),
             Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.PI, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
             Tuple.Create("WellfloWaterInjectionExample1.wflx", WellTypeId.WInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.InjectivityIndex, OptionalUpdate = new long[] { ((long)OptionalUpdates.CalculateChokeD_Factor), ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("WellfloGasLiftExampleTuningTrace.WFLX", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
             //Tuple.Create("WellfloGasInjectionExample1.wflx", WellTypeId.GInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
            };
            foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
            {
                int i = 1;
                string model = modelInfo.Item1;
                WellTypeId wellType = modelInfo.Item2;
                ModelFileOptionDTO options = modelInfo.Item3;

                Trace.WriteLine("Testing model: " + model);
                //Create a new well
                WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
                var allWells = WellService.GetAllWells().ToList();
                WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                Assert.IsNotNull(well);
                _wellsToRemove.Add(well);

                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                options.Comment = "CASETest Upload " + modelInfo.Item1;
                modelFile.Options = options;
                modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i);
                modelFile.WellId = well.Id;

                byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                Assert.IsNotNull(fileAsByteArray);
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                Assert.IsNotNull(ModelFileValidationData);
                ModelFileService.AddWellModelFile(modelFile);
                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());

                #region ESP

                if (wellType == WellTypeId.ESP)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "AllocatableTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        PumpIntakePressure = 10000,
                        PumpDischargePressure = 11000,
                        GaugePressure = 12000,
                        Oil = 5000,
                        Gas = 500,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                        Frequency = 20,
                        MotorVolts = 250,
                        MotorCurrent = 48,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    List<WellTestDTO> data = new List<WellTestDTO>();
                    data.Add(testDataDTO);
                    WellTestDTO[] arrComponent = data.ToArray();
                    bool addWelltest = WellTestDataService.ImportWellTests(arrComponent);
                    Assert.IsTrue(addWelltest, "Need Defect, unable to add corect json type. Check Field validations");

                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual("AllocatableTest", testDataDTOCheck.SPTCodeDescription);
                    Assert.AreEqual(5000, testDataDTOCheck.AverageTubingPressure);
                    Assert.AreEqual(65, testDataDTOCheck.AverageTubingTemperature);
                    Assert.AreEqual(10000, testDataDTOCheck.PumpIntakePressure);
                    Assert.AreEqual(11000, testDataDTOCheck.PumpDischargePressure);
                    Assert.AreEqual(12000, testDataDTOCheck.GaugePressure);
                    Assert.AreEqual(5000, testDataDTOCheck.Oil);
                    Assert.AreEqual(500, testDataDTOCheck.Gas);
                    Assert.AreEqual(8000, testDataDTOCheck.Water);
                    Assert.AreEqual(50, testDataDTOCheck.ChokeSize);
                    Assert.AreEqual(50, testDataDTOCheck.FlowLinePressure);
                    Assert.AreEqual(10000, testDataDTOCheck.SeparatorPressure);
                    Assert.AreEqual(20, testDataDTOCheck.Frequency);
                    Assert.AreEqual(250, testDataDTOCheck.MotorVolts);
                    Assert.AreEqual(48, testDataDTOCheck.MotorCurrent);
                    //Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_RESERVOIR_PRESSURE_TOO_HIGH, testDataDTOCheck.Status);

                    //change the added well test data and save
                    testDataDTOCheck.PumpIntakePressure = 10001;
                    testDataDTOCheck.GaugePressure = 12001;
                    testDataDTOCheck.Gas = 501;
                    testDataDTOCheck.Frequency = 25;
                    testDataDTOCheck.MotorVolts = 350;
                    testDataDTOCheck.MotorCurrent = 50;

                    WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTOCheck));

                    //get the changed well test data
                    var TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(10001, testDataDTOCheck.PumpIntakePressure);
                    Assert.AreEqual(12001, testDataDTOCheck.GaugePressure);
                    Assert.AreEqual(501, testDataDTOCheck.Gas);
                    Assert.AreEqual(25, testDataDTOCheck.Frequency);
                    Assert.AreEqual(350, testDataDTOCheck.MotorVolts);
                    Assert.AreEqual(50, testDataDTOCheck.MotorCurrent);
                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                    var TestDataArray1 = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray1.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                }

                #endregion ESP

                #region WaterInjection

                else if (wellType == WellTypeId.WInj)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        PumpIntakePressure = 10000,
                        PumpDischargePressure = 11000,
                        GaugePressure = 12000,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    List<WellTestDTO> data = new List<WellTestDTO>();
                    data.Add(testDataDTO);
                    WellTestDTO[] arrComponent = data.ToArray();
                    bool addWelltest = WellTestDataService.ImportWellTests(arrComponent);
                    Assert.IsTrue(addWelltest, "Need Defect, unable to add corect json type. Check Field validations");

                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNotNull(testDataDTOCheck);
                    //Assert.AreEqual("RepresentativeTest", testDataDTOCheck.SPTCodeDescription);
                    Assert.AreEqual(5000, testDataDTOCheck.AverageTubingPressure);
                    Assert.AreEqual(65, testDataDTOCheck.AverageTubingTemperature);
                    Assert.AreEqual(10000, testDataDTOCheck.PumpIntakePressure);
                    Assert.AreEqual(11000, testDataDTOCheck.PumpDischargePressure);
                    Assert.AreEqual(12000, testDataDTOCheck.GaugePressure);
                    Assert.AreEqual(8000, testDataDTOCheck.Water);
                    Assert.AreEqual(50, testDataDTOCheck.ChokeSize);
                    Assert.AreEqual(50, testDataDTOCheck.FlowLinePressure);
                    //Assert.AreEqual(WellTestStatus.TUNING_IPR_TUNING_ONLY_FAILED, testDataDTOCheck.Status);

                    //change the added well test data and save
                    testDataDTOCheck.PumpIntakePressure = 10001;
                    testDataDTOCheck.GaugePressure = 12001;
                    testDataDTOCheck.ChokeSize = 25;

                    WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTOCheck));

                    //get the changed well test data
                    var TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(10001, testDataDTOCheck.PumpIntakePressure);
                    Assert.AreEqual(12001, testDataDTOCheck.GaugePressure);
                    Assert.AreEqual(25, testDataDTOCheck.ChokeSize);
                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                    var TestDataArray1 = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray1.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                }

                #endregion WaterInjection

                #region GasLift

                else if (wellType == WellTypeId.GLift)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        AverageCasingPressure = 1000,
                        GasInjectionRate = 1000,
                        FlowLinePressure = 50,
                        SeparatorPressure = 30,
                        GaugePressure = 12000,
                        Oil = (decimal)1497.8,
                        Gas = 500,
                        Water = (decimal)2246.6,
                        ChokeSize = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestAndUnitsDTO WellTestAndUnits = new WellTestAndUnitsDTO();
                    WellTestAndUnits.Units = units;
                    WellTestAndUnits.Value = testDataDTO;
                    List<WellTestDTO> data = new List<WellTestDTO>();
                    data.Add(testDataDTO);
                    WellTestDTO[] arrComponent = data.ToArray();
                    bool addWelltest = WellTestDataService.ImportWellTests(arrComponent);
                    Assert.IsTrue(addWelltest, "Need Defect, unable to add corect json type. Check Field validations");

                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNotNull(testDataDTOCheck);

                    //Assert.AreEqual("RepresentativeTest", testDataDTOCheck.SPTCodeDescription);
                    Assert.AreEqual(5000, testDataDTOCheck.AverageTubingPressure);
                    Assert.AreEqual(65, testDataDTOCheck.AverageTubingTemperature);
                    Assert.AreEqual(1000, testDataDTOCheck.AverageCasingPressure);

                    Assert.AreEqual(12000, testDataDTOCheck.GaugePressure);
                    Assert.AreEqual((decimal)1497.8, testDataDTOCheck.Oil);
                    Assert.AreEqual(500, testDataDTOCheck.Gas);
                    Assert.AreEqual((decimal)2246.6, testDataDTOCheck.Water);
                    Assert.AreEqual(50, testDataDTOCheck.ChokeSize);
                    Assert.AreEqual(50, testDataDTOCheck.FlowLinePressure);
                    //Assert.AreEqual(0, testDataDTOCheck.OrificeSize);
                    //Assert.AreEqual(WellTestStatus.ACCEPTANCE_LIMITS_RESERVOIR_PRESSURE_TOO_HIGH, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_IPR_TUNING_ONLY_FAILED, testDataDTOCheck.Status);

                    //change the added well test data and save

                    testDataDTOCheck.GasInjectionRate = 1001;
                    testDataDTOCheck.FlowLinePressure = 51;
                    WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTOCheck));

                    //get the changed well test data
                    var TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(1001, testDataDTOCheck.GasInjectionRate);
                    Assert.AreEqual(51, testDataDTOCheck.FlowLinePressure);
                    //Assert.AreEqual(CalibrationMethodId.ReservoirPressure, testDataDTOCheck.CalibrationMethod); //3= ReservoirPressure

                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                    var TestDataArray1 = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray1.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(6000, ModelFileValidationData.DHPG);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                }

                #endregion GasLift

                #region NF

                else if (wellType == WellTypeId.NF)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = 5000,
                        AverageTubingTemperature = 65,
                        GaugePressure = 12000,
                        Oil = 5000,
                        Gas = 500,
                        Water = 8000,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    List<WellTestDTO> data = new List<WellTestDTO>();
                    data.Add(testDataDTO);
                    WellTestDTO[] arrComponent = data.ToArray();
                    bool addWelltest = WellTestDataService.ImportWellTests(arrComponent);
                    Assert.IsTrue(addWelltest, "Need Defect, unable to add corect json type. Check Field validations");

                    WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                    Assert.IsNotNull(testDataDTOCheck);
                    //Assert.AreEqual("RepresentativeTest", testDataDTOCheck.SPTCodeDescription);
                    Assert.AreEqual(5000, testDataDTOCheck.AverageTubingPressure);
                    Assert.AreEqual(65, testDataDTOCheck.AverageTubingTemperature);
                    Assert.AreEqual(12000, testDataDTOCheck.GaugePressure);
                    Assert.AreEqual(5000, testDataDTOCheck.Oil);
                    Assert.AreEqual(500, testDataDTOCheck.Gas);
                    Assert.AreEqual(8000, testDataDTOCheck.Water);
                    Assert.AreEqual(50, testDataDTOCheck.ChokeSize);
                    Assert.AreEqual(50, testDataDTOCheck.FlowLinePressure);
                    Assert.AreEqual(10000, testDataDTOCheck.SeparatorPressure);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_SUCCEEDED, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_IPR_TUNING_ONLY_FAILED, testDataDTOCheck.Status);

                    //change the added well test data and save
                    testDataDTOCheck.GaugePressure = 12001;
                    testDataDTOCheck.Gas = 501;
                    testDataDTOCheck.ChokeSize = 25;
                    WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, testDataDTOCheck));

                    //get the changed well test data
                    var TestDataArray = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    Assert.AreEqual(12001, testDataDTOCheck.GaugePressure);
                    Assert.AreEqual(501, testDataDTOCheck.Gas);
                    Assert.AreEqual(25, testDataDTOCheck.ChokeSize);

                    ModelFileService.RemoveModelFileOptionByModelFileId(newModelFile.Id.ToString());
                    ModelFileService.RemoveModelFile(newModelFile.Id.ToString());
                    var TestDataArray1 = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                    testDataDTOCheck = null;
                    testDataDTOCheck = TestDataArray1.Values.FirstOrDefault(a => a.WellId == well.Id);
                    Assert.IsNotNull(testDataDTOCheck);
                    //Assert.AreEqual(WellTestStatus.IPR_TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                    //Assert.AreEqual(WellTestStatus.TUNING_NOT_COMPLETE, testDataDTOCheck.Status);
                }

                #endregion NF
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ValidateCasingHeadPressureforZeropsia()
        {
            Authenticate();
            try
            {
                //1. Add new ESP Well
                #region ESPWelltest
                WellDTO well = AddNonRRLWell(GetFacilityId("ESP_", 1), WellTypeId.ESP);
                //2. Change Acceptnace Limits for same to make sure it tunes
                SettingDTO setting = SettingService.GetSettingByName(SettingServiceStringConstants.RESERVOIR_PRESSURE_MIN_AL);
                SettingService.SaveWellSetting(new WellSettingDTO
                {
                    SettingId = setting.Id,
                    NumericValue = 1000,
                    WellId = well.Id
                });

                setting = SettingService.GetSettingByName(SettingServiceStringConstants.RESERVOIR_PRESSURE_MAX_AL);
                SettingService.SaveWellSetting(new WellSettingDTO
                {
                    SettingId = setting.Id,
                    NumericValue = 25000,
                    WellId = well.Id
                });

                //3. Add Well Test with Zero casing Pressure 
                WellTestAndUnitsDTO WellTestAndUnits = new WellTestAndUnitsDTO();
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                WellTestDTO welltestdto = new WellTestDTO()
                {
                    WellId = well.Id,
                    SPTCodeDescription = "AllocatableTest",
                    TestDuration = 12,
                    AverageTubingPressure = 200,
                    AverageTubingTemperature = 80,
                    AverageCasingPressure = 0, // we are passing casing head pressure accepting 0 value 
                    Frequency = 50,
                    FlowLinePressure = 100,
                    SeparatorPressure = 70,
                    GaugePressure = 50,
                    Oil = (decimal)2396.70,
                    Gas = (decimal)1198.36,
                    Water = (decimal)3595.10,
                    ChokeSize = 32,
                    Comment = "ESP WELL Test FRWM-4485 Avg Casing Head Pressure Takes 0 value."
                };
                welltestdto.SampleDate = (DateTime.Today.AddDays(-2).ToUniversalTime());
                WellTestAndUnits.Units = units;
                WellTestAndUnits.Value = welltestdto;
                WellTestDataService.SaveWellTest(WellTestAndUnits);
                WellTestDTO[] allTunedTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                allTunedTests[0].ReservoirPressure = 0;
                WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, allTunedTests[0]));
                allTunedTests[0].Status = WellTestStatus.TUNING_NOT_COMPLETE;
                string success = "TUNING_SUCCEEDED";
                WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, allTunedTests[0]));
                //4. Tune Well test and ensure Tuning is Succeess.
                WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                //  llTunedAgainTests[0].Status = ""

                bool tunigstatus = WellTestDataService.TuneWellTests(well.Id.ToString());

                allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                Assert.AreEqual(success, allTunedAgainTests[0].Status.ToString(), "Tunig Failed");
                Assert.AreEqual(3902.98, (double)allTunedAgainTests[0].ReservoirPressure, 0.2);
                RemoveWell(GetFacilityId("ESP_", 1));
                #endregion
                // **************************************  Test on GL Well 
                //5. Add new GL Well
                #region GLWelltest
                WellDTO wellgl = AddNonRRLWell(GetFacilityId("GL_", 1), WellTypeId.GLift);
                //6. Change Acceptnace Limits for same to make sure it tunes
                setting = SettingService.GetSettingByName(SettingServiceStringConstants.RESERVOIR_PRESSURE_MIN_AL);
                SettingService.SaveWellSetting(new WellSettingDTO
                {
                    SettingId = setting.Id,
                    NumericValue = 1000,
                    WellId = wellgl.Id
                });

                setting = SettingService.GetSettingByName(SettingServiceStringConstants.RESERVOIR_PRESSURE_MAX_AL);
                SettingService.SaveWellSetting(new WellSettingDTO
                {
                    SettingId = setting.Id,
                    NumericValue = 25000,
                    WellId = wellgl.Id
                });

                //7. Add Well Test with Zero casing Pressure 
                WellTestAndUnits = null;
                welltestdto = null;
                WellTestAndUnits = new WellTestAndUnitsDTO();
                units = WellTestDataService.GetWellTestDefaults(wellgl.Id.ToString()).Units;
                welltestdto = new WellTestDTO()
                {
                    WellId = wellgl.Id,
                    SPTCodeDescription = "AllocatableTest",
                    TestDuration = 12,
                    AverageTubingPressure = (decimal)604.23,
                    AverageTubingTemperature = 205,
                    AverageCasingPressure = 0, // we are passing casing head pressure accepting 0 value 
                    FlowLinePressure = 15,
                    SeparatorPressure = 70,
                    GaugePressure = 1000,
                    GasInjectionRate = (decimal)2900.49,
                    Oil = (decimal)1906.70,
                    Gas = (decimal)2211.82,
                    Water = (decimal)1960.60,
                    ChokeSize = 32,
                    Comment = "GL Well Test FRWM-4485 Avg Casing Head Pressure Takes 0 value."
                };

                welltestdto.SampleDate = (DateTime.Today.AddDays(-2).ToUniversalTime());
                WellTestAndUnits.Units = units;
                WellTestAndUnits.Value = welltestdto;
                WellTestDataService.SaveWellTest(WellTestAndUnits);
                allTunedTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                allTunedTests[0].ReservoirPressure = 0;
                WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, allTunedTests[0]));
                allTunedTests[0].Status = WellTestStatus.TUNING_NOT_COMPLETE;

                WellTestDataService.UpdateWellTestData(new WellTestAndUnitsDTO(units, allTunedTests[0]));
                //4. Tune Well test and ensure Tuning is Succeess.
                allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
                //  llTunedAgainTests[0].Status = ""

                //8. Tune Well test and ensure Tuning is Succeess.
                tunigstatus = WellTestDataService.TuneWellTests(wellgl.Id.ToString());

                allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(wellgl.Id.ToString());
                Assert.AreEqual(success, allTunedAgainTests[0].Status.ToString(), "Tunig Failed");
                Assert.AreEqual(5709.01, (double)allTunedAgainTests[0].ReservoirPressure, 0.2);
                RemoveWell(GetFacilityId("GL_", 1));

                #endregion
            }
            catch (Exception e)
            {
                Trace.WriteLine("Error " + e.InnerException);
                RemoveWell(GetFacilityId("ESP_", 1));
                RemoveWell(GetFacilityId("GL_", 1));
                Assert.Fail();
                throw;
            }


        }

        //Test Method is written for OT Well - Well Test)
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void OTWellWellTest()
        {
            string facilityId;

            if (s_isRunningInATS)
                facilityId = "RPOC_00001";
            else
                facilityId = "RPOC_0001";

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
            WellDTO wellOT = AddOTWell(facilityId);
            Trace.WriteLine("Added OT Well " + wellOT.Name);
            _wellsToRemove.Add(wellOT);

            //Adding WellTest
            WellTestDTO testDataDTO = new WellTestDTO()
            {
                WellId = wellOT.Id,
                SPTCodeDescription = "Allocatable Test",
                SampleDate = wellOT.CommissionDate.Value.AddDays(5).ToUniversalTime(),
                TestDuration = 24,
                Oil = 12,
                Water = 13,
                Gas = 14,
                Comment = "OTWellTestCheck",
                AverageCasingPressure = 0,
                FlowLineTemperature = 100

            };
            //Saved WellTest Data
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(wellOT.Id.ToString()).Units;
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
            Assert.AreEqual(1, WellTestDataService.GetWellTestDataByWellId(wellOT.Id.ToString()).Values.Length, "Well Test is not saved successfully");
            Trace.WriteLine("Well test saved successfully");

            //Get Well Test Data
            WellTestArrayAndUnitsDTO getOtWellTestData = WellTestDataService.GetWellTestDataByWellId(wellOT.Id.ToString());

            Assert.AreEqual(wellOT.CommissionDate.Value.AddDays(5).ToUniversalTime(), getOtWellTestData.Values.FirstOrDefault().SampleDate, "Entered Date is Mismatched");
            Assert.AreEqual(24, getOtWellTestData.Values.FirstOrDefault().TestDuration.Value, "Entered Duration is Mismatched");
            Assert.AreEqual("AllocatableTest", getOtWellTestData.Values.FirstOrDefault().SPTCodeDescription, "Entered Quality Code is Mismatched");
            Assert.AreEqual(12, getOtWellTestData.Values.FirstOrDefault().Oil.Value, "Entered Oil is Mismatched");
            Assert.AreEqual(13, getOtWellTestData.Values.FirstOrDefault().Water.Value, "Entered Water is Mismatched");
            Assert.AreEqual(14, getOtWellTestData.Values.FirstOrDefault().Gas.Value, "Entered Gas is Mismatched");
            Assert.AreEqual("OTWellTestCheck", getOtWellTestData.Values.FirstOrDefault().Comment, "Entered Comment is Mismatched");
            Assert.AreEqual(100, getOtWellTestData.Values.FirstOrDefault().FlowLineTemperature.Value, "Entered FlowLineTemperature is Mismatched");
            Trace.WriteLine("Get well test successfully");
        }
        /// <summary>
        /// Description : PCP Well configuration and Model file Upload -FRWM-4049
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WellConfig_PCP()
        {
            string facilityId = GetFacilityId("WFTA1K_", 1);

            //Adding PCP Well 
            WellDTO pcpWell = AddNonRRLWell(facilityId, WellTypeId.PCP, false, CalibrationMethodId.ReservoirPressure);
            _wellsToRemove.Add(pcpWell);
        }

        //Test Method is written for PCP Well - Well Test
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PCPWellWellTest()
        {
            string facilityId = GetFacilityId("WFTA1K_", 1);

            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
            Trace.WriteLine("System set for US unit system");

            //Adding Well along with WellTest Data
            WellDTO pcpWell = AddNonRRLWell(facilityId, WellTypeId.PCP, false, CalibrationMethodId.ReservoirPressure);
            _wellsToRemove.Add(pcpWell);

            //Get Well Test Data - US System
            WellTestArrayAndUnitsDTO getPCPWellTestData_US = WellTestDataService.GetWellTestDataByWellId(pcpWell.Id.ToString());

            Assert.AreEqual(pcpWell.CommissionDate.Value.AddDays(5).ToUniversalTime(), getPCPWellTestData_US.Values.FirstOrDefault().SampleDate, "Entered Date is Mismatched");
            Assert.AreEqual(12, getPCPWellTestData_US.Values.FirstOrDefault().TestDuration.Value, "Entered Duration is Mismatched");
            Assert.AreEqual("AllocatableTest", getPCPWellTestData_US.Values.FirstOrDefault().SPTCodeDescription, "Entered Quality Code is Mismatched");

            Assert.AreEqual("STB/d", getPCPWellTestData_US.Units.Oil.UnitKey, "Unit for Oil is Mismatched");
            Assert.AreEqual((decimal)210.2, getPCPWellTestData_US.Values.FirstOrDefault().Oil.Value, "Entered Oil is Mismatched");

            Assert.AreEqual("STB/d", getPCPWellTestData_US.Units.Water.UnitKey, "Unit for Water is Mismatched");
            Assert.AreEqual((decimal)141.2, getPCPWellTestData_US.Values.FirstOrDefault().Water.Value, "Entered Water is Mismatched");

            Assert.AreEqual("Mscf/d", getPCPWellTestData_US.Units.Gas.UnitKey, "Unit for Gas is Mismatched");
            Assert.AreEqual((decimal)10.40, getPCPWellTestData_US.Values.FirstOrDefault().Gas.Value, "Entered Gas is Mismatched");

            Assert.AreEqual("psia", getPCPWellTestData_US.Units.AverageTubingPressure.UnitKey, "Unit for TubingPressure is Mismatched");
            Assert.AreEqual((decimal)100.0, getPCPWellTestData_US.Values.FirstOrDefault().AverageTubingPressure.Value, "Entered TubingPressure  is Mismatched");

            Assert.AreEqual("F", getPCPWellTestData_US.Units.AverageTubingTemperature.UnitKey, "Unit for TubingTemperature is Mismatched");
            Assert.AreEqual((decimal)80.0, getPCPWellTestData_US.Values.FirstOrDefault().AverageTubingTemperature.Value, "Entered TubingTemperature is Mismatched");

            Assert.AreEqual("psia", getPCPWellTestData_US.Units.PumpIntakePressure.UnitKey, "Unit for PumpIntakePressure is Mismatched");
            Assert.AreEqual((decimal)161.19, getPCPWellTestData_US.Values.FirstOrDefault().PumpIntakePressure.Value, "Entered PumpIntakePressure is Mismatched");

            Assert.AreEqual("psia", getPCPWellTestData_US.Units.PumpDischargePressure.UnitKey, "Unit for PumpDischargePressure is Mismatched");
            Assert.AreEqual((decimal)2130.69, getPCPWellTestData_US.Values.FirstOrDefault().PumpDischargePressure.Value, "Entered PumpDischargePressure is Mismatched");

            Assert.AreEqual("ft-lbs", getPCPWellTestData_US.Units.PolishedRodTorque.UnitKey, "Unit for PolishedRodTorque is Mismatched");
            Assert.AreEqual((decimal)361.35, getPCPWellTestData_US.Values.FirstOrDefault().PolishedRodTorque.Value, "Entered PolishedRodTorque is Mismatched");

            Assert.AreEqual("ft-lbs", getPCPWellTestData_US.Units.PumpTorque.UnitKey, "Unit for PumpTorque is Mismatched");
            Assert.AreEqual((decimal)185.23, getPCPWellTestData_US.Values.FirstOrDefault().PumpTorque.Value, "Entered PumpTorque is Mismatched");

            Assert.AreEqual("rpm", getPCPWellTestData_US.Units.PumpSpeed.UnitKey, "Unit for Speed is Mismatched");
            Assert.AreEqual((decimal)225.0, getPCPWellTestData_US.Values.FirstOrDefault().PumpSpeed.Value, "Entered Speed is Mismatched");

            Assert.AreEqual("psia", getPCPWellTestData_US.Units.FlowLinePressure.UnitKey, "Unit for FlowLinePressure is Mismatched");
            Assert.AreEqual((decimal)1862.0, getPCPWellTestData_US.Values.FirstOrDefault().FlowLinePressure.Value, "Entered FlowLinePressure is Mismatched");

            Assert.AreEqual("psia", getPCPWellTestData_US.Units.SeparatorPressure.UnitKey, "Unit for SeparatorPressure is Mismatched");
            Assert.AreEqual((decimal)1523.0, getPCPWellTestData_US.Values.FirstOrDefault().SeparatorPressure.Value, "Entered SeparatorPressure is Mismatched");

            Assert.AreEqual("1/64in", getPCPWellTestData_US.Units.ChokeSize.UnitKey, "Unit for ChokeSize is Mismatched");
            Assert.AreEqual((decimal)64.0, getPCPWellTestData_US.Values.FirstOrDefault().ChokeSize.Value, "Entered ChokeSize is Mismatched");

            Assert.AreEqual("PCPWellTest_Comment_Check", getPCPWellTestData_US.Values.FirstOrDefault().Comment, "Entered Comment is Mismatched");

            Assert.AreEqual("F", getPCPWellTestData_US.Units.FlowLineTemperature.UnitKey, "Unit for FlowLineTemperature is Mismatched");
            Assert.AreEqual((decimal)80.0, getPCPWellTestData_US.Values.FirstOrDefault().FlowLineTemperature.Value, "Entered FlowlineTemperature is Mismatched");


            Trace.WriteLine("Successfully Retrive US Well Test");

            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");

            Trace.WriteLine("System set for Metric unit system");


            //Get Well Test Data - Metric System
            WellTestArrayAndUnitsDTO getPCPWellTestData_Metric = WellTestDataService.GetWellTestDataByWellId(pcpWell.Id.ToString());

            Assert.AreEqual("sm3/d", getPCPWellTestData_Metric.Units.Oil.UnitKey, "Unit for Oil is Mismatched");
            Assert.AreEqual((decimal)(210.2 * 0.1589873), getPCPWellTestData_Metric.Values.FirstOrDefault().Oil.Value, "Entered Oil is Mismatched");

            Assert.AreEqual("sm3/d", getPCPWellTestData_Metric.Units.Water.UnitKey, "Unit for Water is Mismatched");
            Assert.AreEqual((decimal)(141.2 * 0.1589873), getPCPWellTestData_Metric.Values.FirstOrDefault().Water.Value, "Entered Water is Mismatched");

            Assert.AreEqual("sm3/d", getPCPWellTestData_Metric.Units.Gas.UnitKey, "Unit for Gas is Mismatched");
            Assert.AreEqual((decimal)(10.40 * 28.3168466), getPCPWellTestData_Metric.Values.FirstOrDefault().Gas.Value, "Entered Gas is Mismatched");

            Assert.AreEqual("kPa", getPCPWellTestData_Metric.Units.AverageTubingPressure.UnitKey, "Unit for TubingPressure is Mismatched");
            Assert.AreEqual((decimal)(100.0 * 6.894757), getPCPWellTestData_Metric.Values.FirstOrDefault().AverageTubingPressure.Value, "Entered TubingPressure  is Mismatched");

            Assert.AreEqual("C", getPCPWellTestData_Metric.Units.AverageTubingTemperature.UnitKey, "Unit for TubingTemperature is Mismatched");
            Assert.AreEqual(Math.Round((decimal)((80.0 - 32) * 0.55555555555555555555555555555556), 2), Math.Round(getPCPWellTestData_Metric.Values.FirstOrDefault().AverageTubingTemperature.Value, 2), "Entered TubingTemperature is Mismatched");

            Assert.AreEqual("kPa", getPCPWellTestData_Metric.Units.PumpIntakePressure.UnitKey, "Unit for PumpIntakePressure is Mismatched");
            Assert.AreEqual((decimal)(161.19 * 6.894757), getPCPWellTestData_Metric.Values.FirstOrDefault().PumpIntakePressure.Value, "Entered PumpIntakePressure is Mismatched");

            Assert.AreEqual("kPa", getPCPWellTestData_Metric.Units.PumpDischargePressure.UnitKey, "Unit for PumpDischargePressure is Mismatched");
            Assert.AreEqual((decimal)(2130.69 * 6.894757), getPCPWellTestData_Metric.Values.FirstOrDefault().PumpDischargePressure.Value, "Entered PumpDischargePressure is Mismatched");

            Assert.AreEqual("N-m", getPCPWellTestData_Metric.Units.PolishedRodTorque.UnitKey, "Unit for PolishedRodTorque is Mismatched");
            Assert.AreEqual((decimal)(361.35 * 1.355818), getPCPWellTestData_Metric.Values.FirstOrDefault().PolishedRodTorque.Value, "Entered PolishedRodTorque is Mismatched");

            Assert.AreEqual("N-m", getPCPWellTestData_Metric.Units.PumpTorque.UnitKey, "Unit for PumpTorque is Mismatched");
            Assert.AreEqual((decimal)(185.23 * 1.355818), getPCPWellTestData_Metric.Values.FirstOrDefault().PumpTorque.Value, "Entered PumpTorque is Mismatched");

            Assert.AreEqual("rpm", getPCPWellTestData_Metric.Units.PumpSpeed.UnitKey, "Unit for Speed is Mismatched");
            Assert.AreEqual((decimal)(225.0), getPCPWellTestData_Metric.Values.FirstOrDefault().PumpSpeed.Value, "Entered Speed is Mismatched");

            Assert.AreEqual("kPa", getPCPWellTestData_Metric.Units.FlowLinePressure.UnitKey, "Unit for FlowLinePressure is Mismatched");
            Assert.AreEqual((decimal)(1862.00 * 6.894757), getPCPWellTestData_Metric.Values.FirstOrDefault().FlowLinePressure.Value, "Entered FlowLinePressure is Mismatched");

            Assert.AreEqual("kPa", getPCPWellTestData_Metric.Units.SeparatorPressure.UnitKey, "Unit for SeparatorPressure is Mismatched");
            Assert.AreEqual((decimal)(1523.00 * 6.894757), getPCPWellTestData_Metric.Values.FirstOrDefault().SeparatorPressure.Value, "Entered SeparatorPressure is Mismatched");

            Assert.AreEqual("mm", getPCPWellTestData_Metric.Units.ChokeSize.UnitKey, "Unit for ChokeSize is Mismatched");
            Assert.AreEqual((decimal)(64.00 * 0.396875), getPCPWellTestData_Metric.Values.FirstOrDefault().ChokeSize.Value, "Entered ChokeSize is Mismatched");

            Assert.AreEqual("C", getPCPWellTestData_Metric.Units.FlowLineTemperature.UnitKey, "Unit for FlowLineTemperature is Mismatched");
            Assert.AreEqual(Math.Round((decimal)((80.0 - 32) * 0.55555555555555555555555555555556), 2), Math.Round(getPCPWellTestData_Metric.Values.FirstOrDefault().FlowLineTemperature.Value, 2), "Entered lowLineTemperature is Mismatched");


            Trace.WriteLine("Successfully Retrive Metric Well Test");

            // Set system to US units - for next run
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            Trace.WriteLine("System reverted and set for US unit system");
        }

        //Test Method is written for verify Valid Successful WellTest with L Factor Tuning Method
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PCPValidSuccessfulWellTestwithLFactor()
        {
            string facilityId = GetFacilityId("WFTA1K_", 1);

            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
            Trace.WriteLine("System set for US unit system");

            //Adding Well along with WellTest Data  with L Factor Tuning Method
            WellDTO pcpWell = AddNonRRLWell(facilityId, WellTypeId.PCP, false, CalibrationMethodId.LFactor);
            _wellsToRemove.Add(pcpWell);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min L Factor Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max L Factor Acceptance Limit", 2.0);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max Water Cut Acceptance Limit", 1.0);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max GOR Acceptance Limit", 50.0);

            WellTestDTO latestTestData_PCP = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_PCP.Id });

            WellTestDTO latestTestDataAfterTune_PCP = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            Assert.AreEqual("TUNING_SUCCEEDED", latestTestDataAfterTune_PCP.Status.ToString(), "Well Test Status is not Success");
        }

        //Test Method is written for verify Valid Successful WellTest with PI Tuning Method
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PCPValidSuccessfulWellTestwithPI()
        {
            string facilityId = GetFacilityId("WFTA1K_", 1);

            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
            Trace.WriteLine("System set for US unit system");

            //Adding Well along with WellTest Data with PI Tuning Method
            WellDTO pcpWell = AddNonRRLWell(facilityId, WellTypeId.PCP, false, CalibrationMethodId.PI);
            _wellsToRemove.Add(pcpWell);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min Productivity Index Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max Productivity Index Acceptance Limit", 1.0);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max Water Cut Acceptance Limit", 1.0);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max GOR Acceptance Limit", 50.0);

            WellTestDTO latestTestData_PCP = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_PCP.Id });

            WellTestDTO latestTestDataAfterTune_PCP = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            Assert.AreEqual("TUNING_SUCCEEDED", latestTestDataAfterTune_PCP.Status.ToString(), "Well Test Status is not Success");
        }

        //Test Method is written for verify Valid Successful WellTest with ReserviorPressure Tuning Method
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PCPValidSuccessfulWellTestwithReserviorPressure()
        {
            string facilityId = GetFacilityId("WFTA1K_", 1);

            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
            Trace.WriteLine("System set for US unit system");

            //Adding Well along with WellTest Data with Reservior Pressure Tuning Method
            WellDTO pcpWell = AddNonRRLWell(facilityId, WellTypeId.PCP, false, CalibrationMethodId.ReservoirPressure);
            _wellsToRemove.Add(pcpWell);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min Reservoir Pressure Acceptance Limit", 21.5);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max Reservoir Pressure Acceptance Limit", 2100.5);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max Water Cut Acceptance Limit", 1.0);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max GOR Acceptance Limit", 50.0);

            WellTestDTO latestTestData_PCP = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_PCP.Id });

            WellTestDTO latestTestDataAfterTune_PCP = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            Assert.AreEqual("TUNING_SUCCEEDED", latestTestDataAfterTune_PCP.Status.ToString(), "Well Test Status is not Success");
        }

        /// <summary>
        /// Discription     : Add the various Sensitivities(THP, CHP, QGI and Erosion Coefficient) in database for GL well and validate values from Database.        
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AddSensitivitiesForGLTests()
        {
            string IsAddedInDB = null, IsUpdatedInDB = null;
            bool IsDeleted;

            try
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");
                #region Well Configuration            
                // This is the path to the GL example well model in the codebase.
                const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

                Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("GasLift_ProductionTestData.wflx", WellTypeId.GLift,
                    new ModelFileOptionDTO
                    {
                        CalibrationMethod = CalibrationMethodId.LFactor,
                        OptionalUpdate = new long[]
                        {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR
                        }
                    });

                string modelFileName = model.Item1;
                WellTypeId wellType = model.Item2;
                ModelFileOptionDTO options = model.Item3;

                Trace.WriteLine("Testing model: " + modelFileName);

                WellConfigurationService.AddWellConfig(new WellConfigDTO()
                {
                    Well = SetDefaultFluidType(new WellDTO()
                    {
                        Name = "GLWell01" + wellType.ToString(),
                        CommissionDate = (DateTime.Today - TimeSpan.FromDays(10)),
                        WellType = wellType,
                        AssemblyAPI = "GLWell01" + wellType.ToString(),
                        SubAssemblyAPI = "GLWell01" + wellType.ToString(),
                        IntervalAPI = "GLWell01" + wellType.ToString(),
                        DepthCorrectionFactor = 2,
                        WellDepthDatumElevation = 1,
                        WellGroundElevation = 1,
                        GasAllocationGroup = null,
                        OilAllocationGroup = null,
                        WaterAllocationGroup = null,
                    })
                });
                WellDTO newWell = WellService.GetWellByName("GLWell01" + wellType.ToString());
                Assert.IsNotNull(newWell);
                _wellsToRemove.Add(newWell);

                ModelFileBase64DTO modelFile = new ModelFileBase64DTO();

                options.Comment = "GL Well Testing..." + model.Item1;
                modelFile.Options = options;
                modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
                modelFile.WellId = newWell.Id;

                byte[] fileAsByteArray = GetByteArray(path, model.Item1);
                Assert.IsNotNull(fileAsByteArray);
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File is not an GL model file.");
                ModelFileValidationDataDTO modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                Assert.IsNotNull(modelFileValidationData);
                ModelFileService.AddWellModelFile(modelFile);
                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());
                Trace.WriteLine("GL Well added successfully.");
                #endregion Well Configuration

                #region Add, Retrive, Verify and Delete Single Sensitivities data
                // Add CasingHeadPressure Sensitivities to GL Well
                WellSensitivityDTO wellSensitivitydto = new WellSensitivityDTO
                {
                    WellId = newWell.Id,
                    SensitivityType = SensitivityQuantity.CasingHeadPressure,
                    DoubleValue = new double[] { 10.10, 20.20 }
                };
                string sensitivityCHP = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
                Assert.AreEqual("1", sensitivityCHP, "The Sensitivity not added successfully in DB.");
                // Retrive data for CasingHeadPressure Sensitivities
                WellSensitivityAndUnitsDTO getCHPSensitivity = WellService.GetWellSensitivityConfigurationAndUnits(newWell.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.CasingHeadPressure)));
                Assert.AreEqual(10.10, Math.Round(getCHPSensitivity.Value.DoubleValue[0], 2), 0.05, "Mismatch value at 0 in expected CHP Sensitivity");
                Assert.AreEqual(20.20, Math.Round(getCHPSensitivity.Value.DoubleValue[1], 2), 0.05, "Mismatch value at 1 in expected CHP Sensitivity");
                Assert.AreEqual("psia", getCHPSensitivity.Units.CasingHeadPressure.UnitKey, "Mismatch units in CHP Sensitivity");

                // Delete CasingHeadPressure Sensitivities
                IsDeleted = WellService.RemoveWellSensitivityConfiguration(newWell.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.CasingHeadPressure)));
                Assert.IsTrue(IsDeleted, "The CHP Sensitivity not deleted successfully.");
                Trace.WriteLine("Single Sensitivity data - Add, Retrive, Verify and Delete.");
                #endregion

                #region Add various Sensitivities (ErosionCoefficient,GasInjectionRate and TubingHeadPressure) to GL Well and Validate
                var VariousSensitivities = new List<Tuple<SensitivityQuantity, double[]>>
                {
                    Tuple.Create(SensitivityQuantity.ErosionCoefficient,new double[]{10.0, 20.0, 30.0 }),
                    Tuple.Create(SensitivityQuantity.GasInjectionRate,new double[]{ 10.0, 20.0, 30.0, 40.0 }),
                    Tuple.Create(SensitivityQuantity.TubingHeadPressure,new double[]{ 10.0, 20.0, 30.0, 40.0, 50.0 }),
                };

                foreach (Tuple<SensitivityQuantity, double[]> sen in VariousSensitivities)
                {
                    wellSensitivitydto.SensitivityType = sen.Item1;
                    wellSensitivitydto.DoubleValue = sen.Item2;
                    IsAddedInDB = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
                    Assert.IsNotNull(IsAddedInDB, "1", "The " + sen.Item1 + "sensitivity not added successfully in DB.");
                }
                Trace.WriteLine("Remaning Sensitivities are added.");

                // Retrive data for all Sensitivities.
                WellSensitivityAndUnitsDTO[] getAllSensitivities = WellService.GetWellSensitivitiesConfigurationAndUnitsForWell(newWell.Id.ToString());
                Assert.IsNotNull(getAllSensitivities, "No Sensitivities found at Database");
                Assert.AreEqual(VariousSensitivities.Count, getAllSensitivities.Count(), "Mismatch count in Various Sensitivities");

                foreach (var sensitivities in getAllSensitivities)
                {
                    var getSensitivity = VariousSensitivities.FirstOrDefault(x => x.Item1 == sensitivities.Value.SensitivityType);
                    Assert.AreEqual(getSensitivity.Item2.Length, sensitivities.Value.DoubleValue.Length, "Mismatch count of double values in" + getSensitivity.Item1.ToString());

                    //Unit verification                    
                    if (getSensitivity.Item1.ToString() == SensitivityQuantity.GasInjectionRate.ToString())
                        Assert.AreEqual("Mscf/d", sensitivities.Units.GasInjectionRate.UnitKey, "Mismatch units in " + getSensitivity.Item1.ToString() + " Sensitivity");
                    else if (getSensitivity.Item1.ToString() == SensitivityQuantity.TubingHeadPressure.ToString())
                        Assert.AreEqual("psia", sensitivities.Units.TubingHeadPressure.UnitKey, "Mismatch units in " + getSensitivity.Item1.ToString() + " Sensitivity");

                    for (int i = 0; i < sensitivities.Value.DoubleValue.Length; i++)
                    {
                        Assert.AreEqual(getSensitivity.Item2[i], Math.Round(sensitivities.Value.DoubleValue[i], 2), 0.05, "Mismatch value at" + i + "in expected" + getSensitivity + "Sensitivity");
                    }
                }
                Trace.WriteLine("Validated Remaning Sensitivities data.");
                #endregion                               

                #region Update exisitng THP Sensitivities data
                //Update existing THP values
                wellSensitivitydto.SensitivityType = SensitivityQuantity.TubingHeadPressure;
                wellSensitivitydto.DoubleValue = new double[] { 100.0, 200.0 };
                IsUpdatedInDB = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
                Assert.IsNotNull(IsUpdatedInDB, "2", "The Sensitivity not updated successfully in DB.");

                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                Trace.WriteLine("System set for Metric unit system");

                // Retrive data for CasingHeadPressure Sensitivities
                WellSensitivityAndUnitsDTO getUpdatedCHPSensitivity = WellService.GetWellSensitivityConfigurationAndUnits(newWell.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.TubingHeadPressure)));
                Assert.AreEqual(689.47, Math.Round(getUpdatedCHPSensitivity.Value.DoubleValue[0], 2), 0.05, "Mismatch value at 0 in expected THP Sensitivity");
                Assert.AreEqual(1378.95, Math.Round(getUpdatedCHPSensitivity.Value.DoubleValue[1], 2), 0.05, "Mismatch value at 1 in expected THP Sensitivity");
                Assert.AreEqual("kPa", getUpdatedCHPSensitivity.Units.TubingHeadPressure.UnitKey, "Mismatch units in THP Sensitivity");

                Trace.WriteLine("Updated exisitng THP Sensitivities data.");
                #endregion Update exisitng THP Sensitivities data

                #region Delete All Sensitivities and validate                
                foreach (var sen in getAllSensitivities)
                {
                    IsDeleted = WellService.RemoveWellSensitivityConfiguration(newWell.Id.ToString(), Convert.ToString(((Int32)sen.Value.SensitivityType)));
                    Assert.IsTrue(IsDeleted, "The " + sen.Value.SensitivityType.ToString() + "sensitivity not deleted successfully in DB.");
                }
                Trace.WriteLine("Remaning Sensitivities are deleted succssfully.");
                #endregion Delete All Sensitivities and validate

            }
            catch (Exception ex)
            {
                Trace.WriteLine("Error in AddSensitivitiesAndPerformanceCurvesForGLTests " + ex.Message);
            }
            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System reverted and set for US unit system");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ApplySensitivitiesForGL_CHP_US()
        {
            var modelFileName = "Gldesign.wflx";
            var wellType = WellTypeId.GLift;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.LFactor,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.UpdateGOR_CGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("GLWELL_", wellType, WellFluidType.BlackOil, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 96,
                AverageTubingTemperature = 100,
                AverageCasingPressure = 1277.5m,
                GasInjectionRate = 1200,
                Gas = 700.0m,
                Water = 504.8m,
                Oil = 413.0m,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testData));
            Trace.WriteLine("Well Test Added Successfully");

            //Reading expected Gradient & Velocity Curve DTO from Json File
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            string FileName = "GradientCurveVelocityCurve.json";
            GasLiftPressureDropAnalysisResultsAndUnitsDTO[] expectedCurveDTO = JsonConvert.DeserializeObject<GasLiftPressureDropAnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));

            //get the newly added (latest) well test data
            var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            // Add CasingHeadPressure Sensitivities to GL Well
            WellSensitivityDTO wellSensitivitydto = new WellSensitivityDTO
            {
                WellId = well.Id,
                SensitivityType = SensitivityQuantity.CasingHeadPressure,
                DoubleValue = new double[] { 1000, 1277.5 }
            };
            string sensitivityCHP = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
            Assert.AreEqual("1", sensitivityCHP, "The Sensitivity Added successfully in DB.");

            var glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            NodalAnalysisSensitivitiesDTO analysisInputWithSensitivities = new NodalAnalysisSensitivitiesDTO();
            analysisInputWithSensitivities.analysisInputs = glAnalysisInput;
            analysisInputWithSensitivities.curveType = 1;
            analysisInputWithSensitivities.sensitivities = wellSensitivitydto;
            GasLiftPressureDropAnalysisResultsAndUnitsDTO[] actualCurveDTO = WellTestDataService.PerformGasLiftPressureDropWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("Curves Retrieved");
            Assert.AreEqual(expectedCurveDTO.Count(), actualCurveDTO.Count(), "Number of Sensitivities and number of Curve Sets retrieved are not matching");

            for (int i = 0; i < actualCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyGradientCurve(expectedCurveDTO[i].GradientCurves, actualCurveDTO[i].GradientCurves, wellType);
                Trace.WriteLine("Gradient curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
                VerifyVelocityCurve(expectedCurveDTO[i].GasVelocityCurves, actualCurveDTO[i].GasVelocityCurves, wellType);
                Trace.WriteLine("Velocity curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }

            //Now Verifying Performance Curves
            //Reading expected Performance Curve DTO from Json File
            FileName = "GasLift_CHP_PerformanceCurves.json";
            GasLiftWellPerformanceCurvesAndUnitsDTO[] expectedPerformanceCurveDTO = JsonConvert.DeserializeObject<GasLiftWellPerformanceCurvesAndUnitsDTO[]>(GetJsonString(Path + FileName));
            //Calling API to retrieve Performance Curves
            analysisInputWithSensitivities.curveType = 2;
            GasLiftWellPerformanceCurvesAndUnitsDTO[] actualPerformanceCurveDTO = WellTestDataService.GenerateGasLiftPerformanceCurvesWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("Performance Curves Retrieved");

            Assert.AreEqual(expectedPerformanceCurveDTO.Count(), actualPerformanceCurveDTO.Count(), "Number of Sensitivities and number of Performance Curves Sets retrieved are not matching");
            for (int i = 0; i < actualPerformanceCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyPerformanceCurve(expectedPerformanceCurveDTO[i], actualPerformanceCurveDTO[i], wellType);
                Trace.WriteLine("Performance curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }

            //Now Verifying Inflow/Outflow curve
            //Reading expected Inflow/Outflow Curve DTO from Json File
            FileName = "GasLift_CHP_InflowOutflowCurves.json";
            GasLiftOperatingPointAnalysisResultsAndUnitsDTO[] expectedInflowOutflowCurveDTO = JsonConvert.DeserializeObject<GasLiftOperatingPointAnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));
            //Calling API to retrieve InflowOutflow Curves
            analysisInputWithSensitivities.curveType = 3;
            GasLiftOperatingPointAnalysisResultsAndUnitsDTO[] actualInflowOutflowCurveDTO = WellTestDataService.PerformGasLiftOperatingPointAnalysisWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("InflowOutflow Curves Retrieved");


            Assert.AreEqual(expectedInflowOutflowCurveDTO.Count(), actualInflowOutflowCurveDTO.Count(), "Number of Sensitivities and number of Inflow/Outflow Curves Sets retrieved are not matching");
            for (int i = 0; i < actualInflowOutflowCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyInflowOutflowCurve(expectedInflowOutflowCurveDTO[i], actualInflowOutflowCurveDTO[i], wellType);
                Trace.WriteLine("InflowOutflow curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }

        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ApplySensitivitiesForGL_CHP_Metric()
        {
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            Trace.WriteLine("System set for Metric unit system");

            var modelFileName = "Gldesign.wflx";
            var wellType = WellTypeId.GLift;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.LFactor,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.UpdateGOR_CGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("GLWELL_", wellType, WellFluidType.BlackOil, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 661.9m,
                AverageTubingTemperature = 37.8m,
                AverageCasingPressure = 8808.1m,
                GasInjectionRate = 33980.216m,
                Gas = 53802.009m,
                Water = 80.257m,
                Oil = 65.662m,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testData));
            Trace.WriteLine("Well Test Added Successfully");

            //Reading expected Gradient & Velocity Curve DTO from Json File
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            string FileName = "GradientCurveVelocityCurve_Metric.json";
            GasLiftPressureDropAnalysisResultsAndUnitsDTO[] expectedCurveDTO = JsonConvert.DeserializeObject<GasLiftPressureDropAnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));

            //get the newly added (latest) well test data
            var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            // Add CasingHeadPressure Sensitivities to GL Well
            WellSensitivityDTO wellSensitivitydto = new WellSensitivityDTO
            {
                WellId = well.Id,
                SensitivityType = SensitivityQuantity.CasingHeadPressure,
                DoubleValue = new double[] { 6894.8, 8808.1 }
            };
            string sensitivityCHP = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
            Assert.AreEqual("1", sensitivityCHP, "The Sensitivity Added successfully in DB.");

            var glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            NodalAnalysisSensitivitiesDTO analysisInputWithSensitivities = new NodalAnalysisSensitivitiesDTO();
            analysisInputWithSensitivities.analysisInputs = glAnalysisInput;
            analysisInputWithSensitivities.curveType = 1;
            analysisInputWithSensitivities.sensitivities = wellSensitivitydto;
            GasLiftPressureDropAnalysisResultsAndUnitsDTO[] actualCurveDTO = WellTestDataService.PerformGasLiftPressureDropWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("Curves Retrieved");

            Assert.AreEqual(expectedCurveDTO.Count(), actualCurveDTO.Count(), "Number of Sensitivities and number of Curve Sets retrieved are not matching");

            for (int i = 0; i < actualCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyGradientCurve(expectedCurveDTO[i].GradientCurves, actualCurveDTO[i].GradientCurves, wellType);
                Trace.WriteLine("Gradient curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
                VerifyVelocityCurve(expectedCurveDTO[i].GasVelocityCurves, actualCurveDTO[i].GasVelocityCurves, wellType);
                Trace.WriteLine("Velocity curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }

            //Now Verifying Performance Curves
            //Reading expected Performance Curve DTO from Json File
            FileName = "GasLift_CHP_PerformanceCurves_Metric.json";
            GasLiftWellPerformanceCurvesAndUnitsDTO[] expectedPerformanceCurveDTO = JsonConvert.DeserializeObject<GasLiftWellPerformanceCurvesAndUnitsDTO[]>(GetJsonString(Path + FileName));
            //Calling API to retrieve Performance Curves
            analysisInputWithSensitivities.curveType = 2;
            GasLiftWellPerformanceCurvesAndUnitsDTO[] actualPerformanceCurveDTO = WellTestDataService.GenerateGasLiftPerformanceCurvesWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("Performance Curves Retrieved");

            Assert.AreEqual(expectedPerformanceCurveDTO.Count(), actualPerformanceCurveDTO.Count(), "Number of Sensitivities and number of Performance Curves Sets retrieved are not matching");
            for (int i = 0; i < actualPerformanceCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyPerformanceCurve(expectedPerformanceCurveDTO[i], actualPerformanceCurveDTO[i], wellType);
                Trace.WriteLine("Performance curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }

            //Now Verifying Inflow/Outflow curve
            //Reading expected Inflow/Outflow Curve DTO from Json File
            FileName = "GasLift_CHP_InflowOutflowCurves_Metric.json";
            GasLiftOperatingPointAnalysisResultsAndUnitsDTO[] expectedInflowOutflowCurveDTO = JsonConvert.DeserializeObject<GasLiftOperatingPointAnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));
            //Calling API to retrieve InflowOutflow Curves
            analysisInputWithSensitivities.curveType = 3;
            GasLiftOperatingPointAnalysisResultsAndUnitsDTO[] actualInflowOutflowCurveDTO = WellTestDataService.PerformGasLiftOperatingPointAnalysisWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("InflowOutflow Curves Retrieved");

            Assert.AreEqual(expectedInflowOutflowCurveDTO.Count(), actualInflowOutflowCurveDTO.Count(), "Number of Sensitivities and number of Inflow/Outflow Curves Sets retrieved are not matching");
            for (int i = 0; i < actualInflowOutflowCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyInflowOutflowCurve(expectedInflowOutflowCurveDTO[i], actualInflowOutflowCurveDTO[i], wellType);
                Trace.WriteLine("InflowOutflow curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ApplySensitivitiesForNFW_THP()
        {
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            string FileName = "Gradient_Performance_InOutflowCurve_WellboreForNF.json";

            #region NF Well Added            
            var modelFileName = "Dry Gas - IPR Auto Tuning.wflx";
            WellTypeId wellType = WellTypeId.NF;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("NFWWELL_", wellType, WellFluidType.DryGas, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");
            #endregion

            #region Well Test Added            
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 1000,
                AverageTubingTemperature = 100,
                Gas = 1680,
                Water = 555.1m,
                ChokeSize = 64,
                FlowLinePressure = 600,
                SeparatorPressure = 600,
                TestDuration = 12,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };

            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testData));
            Trace.WriteLine("Well Test Added Successfully");
            #endregion
            #region US Unit Verification

            //get the newly added (latest) well test data
            var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            // Add TubingHeadPressure Sensitivities to NF Well
            WellSensitivityDTO wellSensitivitydto = new WellSensitivityDTO
            {
                WellId = well.Id,
                SensitivityType = SensitivityQuantity.TubingHeadPressure,
                DoubleValue = new double[] { 50, 100 }
            };
            string sensitivityTHP = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
            Assert.AreEqual("1", sensitivityTHP, "The Sensitivity Added successfully in DB.");

            var glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            NodalAnalysisSensitivitiesDTO analysisInputWithSensitivities = new NodalAnalysisSensitivitiesDTO();
            analysisInputWithSensitivities.analysisInputs = glAnalysisInput;
            analysisInputWithSensitivities.curveType = 1;
            analysisInputWithSensitivities.sensitivities = wellSensitivitydto;

            AnalysisResultsAndUnitsDTO[] actualCurveDTO = WellTestDataService.PerformAnalysisWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("Curves Retrieved");

            // One time Activity to generate JSON file. Not required for Integration test.
            var json = actualCurveDTO.GetJsonStringFromObject();

            //Reading expected Gradient & Velocity Curve DTO from Json File            
            AnalysisResultsAndUnitsDTO[] expectedCurveDTO = JsonConvert.DeserializeObject<AnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));

            Assert.AreEqual(expectedCurveDTO.Count(), actualCurveDTO.Count(), "Number of Sensitivities and number of Curve Sets retrieved are not matching");

            for (int i = 0; i < actualCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyGradientCurve(expectedCurveDTO[i].PressureDropResults.GradientCurves, actualCurveDTO[i].PressureDropResults.GradientCurves, wellType);
                Trace.WriteLine("Gradient curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
                VerifyVelocityCurve(expectedCurveDTO[i].PressureDropResults.GasVelocityCurves, actualCurveDTO[i].PressureDropResults.GasVelocityCurves, wellType);
                Trace.WriteLine("Velocity curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
                VerifyPerformanceCurve(expectedCurveDTO[i].WellPerformanceCurve, actualCurveDTO[i].WellPerformanceCurve, wellType);
                Trace.WriteLine("WellPerformanceCurve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
                VerifyInflowOutflowCurve(expectedCurveDTO[i].OperatingPointResults, actualCurveDTO[i].OperatingPointResults, wellType);
                Trace.WriteLine("InflowOutflow curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");

            }
            Trace.WriteLine("Verification in US Unit completed");
            #endregion

            //Deleting Sensitivity
            bool IsDeleted = WellService.RemoveWellSensitivityConfiguration(well.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.TubingHeadPressure)));
            Assert.IsTrue(IsDeleted, "The THP Sensitivity not deleted successfully.");

            #region Metric Unit Verification

            //Now verifying in Metric Unit Sysem
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            Trace.WriteLine("System set for Metric unit system");

            FileName = "Gradient_Performance_InOutflowCurve_WellboreForNF_Metric.json";

            //get the newly added (latest) well test data
            latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            // Add TubingHeadPressure Sensitivities to NF Well
            wellSensitivitydto = new WellSensitivityDTO
            {
                WellId = well.Id,
                SensitivityType = SensitivityQuantity.TubingHeadPressure,
                DoubleValue = new double[] { 344.7, 689.5 }
            };
            sensitivityTHP = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
            Assert.AreEqual("1", sensitivityTHP, "The Sensitivity Added successfully in DB.");

            glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            analysisInputWithSensitivities = new NodalAnalysisSensitivitiesDTO();
            analysisInputWithSensitivities.analysisInputs = glAnalysisInput;
            analysisInputWithSensitivities.curveType = 1;
            analysisInputWithSensitivities.sensitivities = wellSensitivitydto;

            actualCurveDTO = WellTestDataService.PerformAnalysisWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("Curves Retrieved");
            // Capture response from json1 and convert it properly and paste it in Gradient_Performance_InOutflowCurve_WellboreForNF_Metric file.
            var json1 = actualCurveDTO.GetJsonStringFromObject();

            expectedCurveDTO = JsonConvert.DeserializeObject<AnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));

            Assert.AreEqual(expectedCurveDTO.Count(), actualCurveDTO.Count(), "Number of Sensitivities and number of Curve Sets retrieved are not matching");

            for (int i = 0; i < actualCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyGradientCurve(expectedCurveDTO[i].PressureDropResults.GradientCurves, actualCurveDTO[i].PressureDropResults.GradientCurves, wellType);
                Trace.WriteLine("Gradient curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
                VerifyVelocityCurve(expectedCurveDTO[i].PressureDropResults.GasVelocityCurves, actualCurveDTO[i].PressureDropResults.GasVelocityCurves, wellType);
                Trace.WriteLine("Velocity curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
                VerifyPerformanceCurve(expectedCurveDTO[i].WellPerformanceCurve, actualCurveDTO[i].WellPerformanceCurve, wellType);
                Trace.WriteLine("WellPerformanceCurve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
                VerifyInflowOutflowCurve(expectedCurveDTO[i].OperatingPointResults, actualCurveDTO[i].OperatingPointResults, wellType);
                Trace.WriteLine("InflowOutflow curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");

            }
            Trace.WriteLine("Verification in Metric Unit completed");
            #endregion
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ApplySensitivitiesForNFW_ErosionCoefficient()
        {
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            string FileName = "NFW_ErosionCoefficient_US.json";

            #region NF Well Added            
            var modelFileName = "Dry Gas - IPR Auto Tuning.wflx";
            WellTypeId wellType = WellTypeId.NF;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("NFWWELL_", wellType, WellFluidType.DryGas, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");
            #endregion

            #region Well Test Added            
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 1000,
                AverageTubingTemperature = 100,
                Gas = 1680,
                Water = 555.1m,
                ChokeSize = 64,
                FlowLinePressure = 600,
                SeparatorPressure = 600,
                TestDuration = 12,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };

            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testData));
            Trace.WriteLine("Well Test Added Successfully");
            #endregion
            #region US Unit Verification

            //Reading expected Gradient & Velocity Curve DTO from Json File            
            AnalysisResultsAndUnitsDTO[] expectedCurveDTO = JsonConvert.DeserializeObject<AnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));

            //get the newly added (latest) well test data
            var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            // Add TubingHeadPressure Sensitivities to NF Well
            WellSensitivityDTO wellSensitivitydto = new WellSensitivityDTO
            {
                WellId = well.Id,
                SensitivityType = SensitivityQuantity.ErosionCoefficient,
                DoubleValue = new double[] { 7.5, 1000 }
            };
            string sensitivityTHP = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
            Assert.AreEqual("1", sensitivityTHP, "The Sensitivity Added successfully in DB.");

            var glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            NodalAnalysisSensitivitiesDTO analysisInputWithSensitivities = new NodalAnalysisSensitivitiesDTO();
            analysisInputWithSensitivities.analysisInputs = glAnalysisInput;
            analysisInputWithSensitivities.curveType = 1;
            analysisInputWithSensitivities.sensitivities = wellSensitivitydto;

            AnalysisResultsAndUnitsDTO[] actualCurveDTO = WellTestDataService.PerformAnalysisWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("Curves Retrieved");

            // One time Activity to generate JSON file. Not required for Integration test.
            var json = actualCurveDTO.GetJsonStringFromObject();

            Assert.AreEqual(expectedCurveDTO.Count(), actualCurveDTO.Count(), "Number of Sensitivities and number of Curve Sets retrieved are not matching");

            for (int i = 0; i < actualCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyVelocityCurve(expectedCurveDTO[i].PressureDropResults.GasVelocityCurves, actualCurveDTO[i].PressureDropResults.GasVelocityCurves, wellType);
                Trace.WriteLine("Velocity curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }
            Trace.WriteLine("Verification in US Unit completed");
            #endregion

            //Deleting Sensitivity
            bool IsDeleted = WellService.RemoveWellSensitivityConfiguration(well.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.ErosionCoefficient)));
            Assert.IsTrue(IsDeleted, "The ErosionCoefficient Sensitivity not deleted successfully.");
            #region Metric Unit Verification

            //Now verifying in Metric Unit Sysem
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            Trace.WriteLine("System set for Metric unit system");

            FileName = "NFW_ErosionCoefficient_Metric.json";

            //get the newly added (latest) well test data
            latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            // Add TubingHeadPressure Sensitivities to NF Well
            wellSensitivitydto = new WellSensitivityDTO
            {
                WellId = well.Id,
                SensitivityType = SensitivityQuantity.ErosionCoefficient,
                DoubleValue = new double[] { 7.5, 1000 }
            };
            sensitivityTHP = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
            Assert.AreEqual("1", sensitivityTHP, "The Sensitivity Added successfully in DB.");

            glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            analysisInputWithSensitivities = new NodalAnalysisSensitivitiesDTO();
            analysisInputWithSensitivities.analysisInputs = glAnalysisInput;
            analysisInputWithSensitivities.curveType = 1;
            analysisInputWithSensitivities.sensitivities = wellSensitivitydto;

            actualCurveDTO = WellTestDataService.PerformAnalysisWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("Curves Retrieved");

            expectedCurveDTO = JsonConvert.DeserializeObject<AnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));

            Assert.AreEqual(expectedCurveDTO.Count(), actualCurveDTO.Count(), "Number of Sensitivities and number of Curve Sets retrieved are not matching");

            for (int i = 0; i < actualCurveDTO.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyVelocityCurve(expectedCurveDTO[i].PressureDropResults.GasVelocityCurves, actualCurveDTO[i].PressureDropResults.GasVelocityCurves, wellType);
                Trace.WriteLine("Velocity curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }
            Trace.WriteLine("Verification in Metric Unit completed");
            #endregion
        }
        public void VerifyGradientCurve(GradientCurvesAndUnitsDTO expCurveDTO, GradientCurvesAndUnitsDTO actCurveDTO, WellTypeId wellType)
        {

            CompareObjectsUsingReflection(expCurveDTO.GradientCurves.Units, actCurveDTO.GradientCurves.Units, "Units not matching for Gradient Curve");
            Trace.WriteLine("Completed Unit Verification for Gradient Curve");
            for (int i = 0; i < actCurveDTO.GradientCurves.Values.Count(); i++)
            {
                CompareObjectsUsingReflection(expCurveDTO.GradientCurves.Values[i], actCurveDTO.GradientCurves.Values[i], "Value mismatch in Gradient Points", null, 0.2);
            }
            Trace.WriteLine("Verification completed for Gradient Curve points");

            CompareObjectsUsingReflection(expCurveDTO.DepthLines.Units, actCurveDTO.DepthLines.Units, "Units not matching for Depth Lines Curve");
            Trace.WriteLine("Completed Unit Verification for Depth Lines Curve");
            CompareObjectsUsingReflection(expCurveDTO.DepthLines.Value, actCurveDTO.DepthLines.Value, "Value not matching for Depth Lines Curve", null, 0.2);
            Trace.WriteLine("Verification completed for Depth Lines Curve points");
            if (wellType == WellTypeId.GLift)
            {
                CompareObjectsUsingReflection(expCurveDTO.ValveCurves.Units, actCurveDTO.ValveCurves.Units, "Units not matching for Valve Curve");
                Trace.WriteLine("Completed Unit Verification for Valve Curve");
                for (int i = 0; i < actCurveDTO.ValveCurves.Values.Count(); i++)
                {
                    CompareObjectsUsingReflection(expCurveDTO.ValveCurves.Values[i], actCurveDTO.ValveCurves.Values[i], "Value mismatch in Valve Curve Points", null, 0.2);
                }
                Trace.WriteLine("Verification completed for Valve Curve points");
            }
            else
            {
                CompareObjectsUsingReflection(expCurveDTO.ValveCurves, actCurveDTO.ValveCurves, "Value mismatch in Valve Curve Points");
            }

            Assert.AreEqual(expCurveDTO.MaximumMD, actCurveDTO.MaximumMD, 0.2, "MaximumMD mismatch");
            Assert.AreEqual(expCurveDTO.MaximumPressure, actCurveDTO.MaximumPressure, 0.2, "MaximumPressure mismatch");
            Assert.AreEqual(expCurveDTO.MaximumTemperature, actCurveDTO.MaximumTemperature, 0.2, "MaximumTemperature mismatch");
            Assert.AreEqual(expCurveDTO.MaximumTVD, actCurveDTO.MaximumTVD, 0.2, "MaximumTVD mismatch");
        }

        public void VerifyVelocityCurve(GasVelocityCurvesAndUnitsDTO expCurveDTO, GasVelocityCurvesAndUnitsDTO actCurveDTO, WellTypeId wellType)
        {
            CompareObjectsUsingReflection(expCurveDTO.GasVelocityCurves.Units, actCurveDTO.GasVelocityCurves.Units, "Units not matching for Gas Velocity Curve");

            Trace.WriteLine("Completed Unit Verification for GasVelocityCurves Curve");
            for (int i = 0; i < actCurveDTO.GasVelocityCurves.Values.Count(); i++)
            {
                CompareObjectsUsingReflection(expCurveDTO.GasVelocityCurves.Values[i], actCurveDTO.GasVelocityCurves.Values[i], "Value mismatch in Gas Velocity Curve Points", null, 0.2);
            }
            Trace.WriteLine("Verification completed for GasVelocityCurves points");

            Assert.AreEqual(expCurveDTO.MaximumMD, actCurveDTO.MaximumMD, 0.2, "MaximumMD mismatch");
            Assert.AreEqual(expCurveDTO.MaximumVelocity, actCurveDTO.MaximumVelocity, 0.2, "MaximumVelocity mismatch");
            Assert.AreEqual(expCurveDTO.MaximumTVD, actCurveDTO.MaximumTVD, 0.2, "MaximumTVD mismatch");
        }

        public void VerifyPerformanceCurve(object expCurveDTO, object actCurveDTO, WellTypeId wellType)
        {
            if (wellType == WellTypeId.GLift)
            {
                GasLiftWellPerformanceCurvesAndUnitsDTO actualCurveDTO = actCurveDTO as GasLiftWellPerformanceCurvesAndUnitsDTO;
                GasLiftWellPerformanceCurvesAndUnitsDTO expectedCurveDTO = expCurveDTO as GasLiftWellPerformanceCurvesAndUnitsDTO;
                for (int i = 0; i < actualCurveDTO.WellPerformanceCurves.Count(); i++)
                {
                    CompareObjectsUsingReflection(expectedCurveDTO.WellPerformanceCurves[i].TubingHeadPressure, actualCurveDTO.WellPerformanceCurves[i].TubingHeadPressure, "Unit/Value Mismatch in Performance Curve -> TubingHeadPressure", null, 0.2);
                    Trace.WriteLine("Verified TubingHeadPressure Units & Values");
                    CompareObjectsUsingReflection(expectedCurveDTO.WellPerformanceCurves[i].WellPerformanceCurve.Units, actualCurveDTO.WellPerformanceCurves[i].WellPerformanceCurve.Units, "Unit Mismatch in Performance Curve -> WellPerformanceCurve");

                    for (int j = 0; j < actualCurveDTO.WellPerformanceCurves[i].WellPerformanceCurve.Values.Count(); j++)
                    {
                        CompareObjectsUsingReflection(expectedCurveDTO.WellPerformanceCurves[i].WellPerformanceCurve.Values[j], actualCurveDTO.WellPerformanceCurves[i].WellPerformanceCurve.Values[j], "Value Mismatch in Performance Curve -> WellPerformanceCurve Points", null, 0.2);
                    }

                }
                Trace.WriteLine("Verification completed for WellPerformanceCurve points");

                Assert.AreEqual(expectedCurveDTO.MaximumGasInjected, actualCurveDTO.MaximumGasInjected, 0.2, "MaximumGasInjected Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumLiquidProduced, actualCurveDTO.MaximumLiquidProduced, 0.2, "MaximumLiquidProduced Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumOilProduced, actualCurveDTO.MaximumOilProduced, 0.2, "MaximumOilProduced Mismatch");
            }
            else
            {
                WellPerformanceCurveAndUnitsDTO actualCurveDTO = actCurveDTO as WellPerformanceCurveAndUnitsDTO;
                WellPerformanceCurveAndUnitsDTO expectedCurveDTO = expCurveDTO as WellPerformanceCurveAndUnitsDTO;
                CompareObjectsUsingReflection(expectedCurveDTO.WellPerformanceCurve.Units, actualCurveDTO.WellPerformanceCurve.Units, "Unit Mismatch in Performance Curve -> WellPerformanceCurve");
                Trace.WriteLine("Unit verification completed for WellPerformance Curves ");
                for (int j = 0; j < actualCurveDTO.WellPerformanceCurve.Values.Count(); j++)
                {
                    CompareObjectsUsingReflection(expectedCurveDTO.WellPerformanceCurve.Values[j], actualCurveDTO.WellPerformanceCurve.Values[j], "Value Mismatch in Performance Curve -> WellPerformanceCurve Points", null, 0.2);
                }
                Trace.WriteLine("Verification completed for WellPerformance points");

                CompareObjectsUsingReflection(expectedCurveDTO.OperatingFrequency, actualCurveDTO.OperatingFrequency, "Unit/Value Mismatch in Performance Curve -> OperatingFrequency", null, 0.2);
                Trace.WriteLine("Verification completed for Operating Frequemcy");

                CompareObjectsUsingReflection(expectedCurveDTO.PumpSpeed, actualCurveDTO.PumpSpeed, "Value Mismatch in Performance Curve -> PumpSpeed", null, 0.2);
                Trace.WriteLine("Verification completed for PumpSpeed");
                Assert.AreEqual(expectedCurveDTO.IsInjectionWell, actualCurveDTO.IsInjectionWell, "IsInjectionWell Mismatch");
                Assert.AreEqual(expectedCurveDTO.IsLiquid, actualCurveDTO.IsLiquid, "IsLiquid Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumOilProduced, actualCurveDTO.MaximumOilProduced, 0.2, "MaximumOilProduced Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumGasProduced, actualCurveDTO.MaximumGasProduced, 0.2, "MaximumGasProduced Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumLiquidProduced, actualCurveDTO.MaximumLiquidProduced, 0.2, "MaximumLiquidProduced Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumWellHeadPressure, actualCurveDTO.MaximumWellHeadPressure, 0.2, "MaximumWellHeadPressure Mismatch");
            }
        }

        public void VerifyInflowOutflowCurve(object expCurveDTO, object actCurveDTO, WellTypeId wellType)
        {

            if (wellType == WellTypeId.GLift)
            {

                GasLiftOperatingPointAnalysisResultsAndUnitsDTO actualCurveDTO = actCurveDTO as GasLiftOperatingPointAnalysisResultsAndUnitsDTO;
                GasLiftOperatingPointAnalysisResultsAndUnitsDTO expectedCurveDTO = expCurveDTO as GasLiftOperatingPointAnalysisResultsAndUnitsDTO;
                CompareObjectsUsingReflection(expectedCurveDTO.FlowCurves.Units, actualCurveDTO.FlowCurves.Units, "Unit Mismatch in Flow Curves");
                Trace.WriteLine("Unit verification completed for Flow Curves ");

                for (int i = 0; i < actualCurveDTO.FlowCurves.Values.Count(); i++)
                {
                    CompareObjectsUsingReflection(expectedCurveDTO.FlowCurves.Values[i], actualCurveDTO.FlowCurves.Values[i], "Value Mismatch in Flow Curves", null, 0.2);
                }
                Trace.WriteLine("Verification completed for FlowCurves points");

                CompareObjectsUsingReflection(expectedCurveDTO.OperatingPoint.Units, actualCurveDTO.OperatingPoint.Units, "Unit Mismatch in Operating Point");
                Trace.WriteLine("Unit verification completed for Operating Point ");

                CompareObjectsUsingReflection(expectedCurveDTO.OperatingPoint.Value, actualCurveDTO.OperatingPoint.Value, "Value Mismatch in Opearting Point", null, 0.2);
                Trace.WriteLine("Verification completed for Operating point");

                Assert.AreEqual(expectedCurveDTO.MaximumFlowRate, actualCurveDTO.MaximumFlowRate, 0.2, "MaximumFlowRate Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumGasRate, actualCurveDTO.MaximumGasRate, 0.2, "MaximumGasRate Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumOilRate, actualCurveDTO.MaximumOilRate, 0.2, "MaximumOilRate Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumPressure, actualCurveDTO.MaximumPressure, 0.2, "MaximumPressure Mismatch");
            }
            else
            {
                OperatingPointAnalysisResultsAndUnitsDTO actualCurveDTO = actCurveDTO as OperatingPointAnalysisResultsAndUnitsDTO;
                OperatingPointAnalysisResultsAndUnitsDTO expectedCurveDTO = expCurveDTO as OperatingPointAnalysisResultsAndUnitsDTO;
                CompareObjectsUsingReflection(expectedCurveDTO.FlowCurves.Units, actualCurveDTO.FlowCurves.Units, "Unit Mismatch in Flow Curves");
                Trace.WriteLine("Unit verification completed for Flow Curves ");

                for (int i = 0; i < actualCurveDTO.FlowCurves.Values.Count(); i++)
                {
                    CompareObjectsUsingReflection(expectedCurveDTO.FlowCurves.Values[i], actualCurveDTO.FlowCurves.Values[i], "Value Mismatch in Flow Curves", null, 0.2);
                }
                Trace.WriteLine("Verification completed for FlowCurves points");

                CompareObjectsUsingReflection(expectedCurveDTO.OperatingPoint.Units, actualCurveDTO.OperatingPoint.Units, "Unit Mismatch in Operating Point");
                Trace.WriteLine("Unit verification completed for Operating Point ");

                CompareObjectsUsingReflection(expectedCurveDTO.OperatingPoint.Value, actualCurveDTO.OperatingPoint.Value, "Value Mismatch in Opearting Point", null, 0.2);
                Trace.WriteLine("Verification completed for Operating point");

                Assert.AreEqual(expectedCurveDTO.MaximumFlowRate, actualCurveDTO.MaximumFlowRate, 0.2, "MaximumFlowRate Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumGasRate, actualCurveDTO.MaximumGasRate, 0.2, "MaximumGasRate Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumOilRate, actualCurveDTO.MaximumOilRate, 0.2, "MaximumOilRate Mismatch");
                Assert.AreEqual(expectedCurveDTO.MaximumPressure, actualCurveDTO.MaximumPressure, 0.2, "MaximumPressure Mismatch");
            }

        }

        /// <summary>
        /// Discription     : Add the various Sensitivities(THP and Erosion Coefficient(WAMI not supported)) in database for NFW well and validate values from Database.
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AddSensitivitiesForNFWTest()
        {
            string IsUpdatedInDB = null, facilityId = GetFacilityId("NFWWELL_", 1); ;
            bool IsDeleted;

            try
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");
                #region Well Configuration            
                // This is the path to the NFW example well model in the codebase.
                WellDTO newWell = AddNonRRLWell(facilityId, WellTypeId.NF, false, CalibrationMethodId.LFactor);
                Assert.IsNotNull(newWell);

                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());
                Trace.WriteLine("NFW Well added successfully.");
                #endregion Well Configuration

                #region Add, Retrive, Verify and Delete THP Sensitivities data
                // Add CasingHeadPressure Sensitivities to GL Well
                WellSensitivityDTO wellSensitivitydto = new WellSensitivityDTO
                {
                    WellId = newWell.Id,
                    SensitivityType = SensitivityQuantity.TubingHeadPressure,
                    DoubleValue = new double[] { 10.10, 20.20 }
                };
                string sensitivityTHP = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
                Assert.AreEqual("1", sensitivityTHP, "The Sensitivity not added successfully in DB.");
                Trace.WriteLine("The Sensitivity Added successfully in DB.");

                // Retrive data for THP Sensitivities in US unit system
                WellSensitivityAndUnitsDTO getCHPSensitivity = WellService.GetWellSensitivityConfigurationAndUnits(newWell.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.TubingHeadPressure)));
                Assert.AreEqual(10.10, Math.Round(getCHPSensitivity.Value.DoubleValue[0], 2), 0.05, "Mismatch value at 0 in expected THP Sensitivity");
                Assert.AreEqual(20.20, Math.Round(getCHPSensitivity.Value.DoubleValue[1], 2), 0.05, "Mismatch value at 1 in expected THP Sensitivity");
                Assert.AreEqual("psia", getCHPSensitivity.Units.TubingHeadPressure.UnitKey, "Mismatch units in THP Sensitivity");

                //Update existing THP values
                wellSensitivitydto.SensitivityType = SensitivityQuantity.TubingHeadPressure;
                wellSensitivitydto.DoubleValue = new double[] { 100.0, 200.0 };
                IsUpdatedInDB = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
                Assert.IsNotNull(IsUpdatedInDB, "2", "The Sensitivity not updated successfully in DB.");

                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                Trace.WriteLine("System set for Metric unit system");

                // Retrive data for THP Sensitivities in metric unit system
                WellSensitivityAndUnitsDTO getUpdatedCHPSensitivity = WellService.GetWellSensitivityConfigurationAndUnits(newWell.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.TubingHeadPressure)));
                Assert.AreEqual(689.47, Math.Round(getUpdatedCHPSensitivity.Value.DoubleValue[0], 2), 0.05, "Mismatch value at 0 in expected THP Sensitivity");
                Assert.AreEqual(1378.95, Math.Round(getUpdatedCHPSensitivity.Value.DoubleValue[1], 2), 0.05, "Mismatch value at 1 in expected THP Sensitivity");
                Assert.AreEqual("kPa", getUpdatedCHPSensitivity.Units.TubingHeadPressure.UnitKey, "Mismatch units in THP Sensitivity");

                Trace.WriteLine("Updated exisitng THP Sensitivities data.");

                // Delete THP Sensitivities
                IsDeleted = WellService.RemoveWellSensitivityConfiguration(newWell.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.TubingHeadPressure)));
                Assert.IsTrue(IsDeleted, "The THP Sensitivity not deleted successfully.");
                Trace.WriteLine("Single Sensitivity data - Add, Retrive, Verify and Delete.");
                #endregion                  
            }
            catch (Exception ex)
            {
                Trace.WriteLine("Error in AddSensitivitiesForNFWTest " + ex.Message);
            }
            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System reverted and set for US unit system");
                Trace.WriteLine("Sensitivities test successfully executed.");
            }
        }

        /// <summary>
        /// Discription     : Add the various Sensitivities in database for ESP well and validate values from Database.        
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AddSensitivitiesForESPTests()
        {
            string IsAddedInDB = null, IsUpdatedInDB = null, facilityId = GetFacilityId("ESPWELL_", 1);
            bool IsDeleted;

            try
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");
                #region Well Configuration                            
                WellDTO newWell = AddNonRRLWell(facilityId, WellTypeId.ESP, false, CalibrationMethodId.LFactor);
                Assert.IsNotNull(newWell);

                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());
                Trace.WriteLine("ESP Well added successfully.");
                #endregion Well Configuration

                #region Add various Sensitivities (ErosionCoefficient,GasInjectionRate and TubingHeadPressure) to ESP Well and Validate
                WellSensitivityDTO wellSensitivitydto = new WellSensitivityDTO();
                var VariousSensitivities = new List<Tuple<SensitivityQuantity, double[]>>
                {
                    Tuple.Create(SensitivityQuantity.FormationGOR,new double[]{10.0, 20.0 }),
                    Tuple.Create(SensitivityQuantity.WaterCut,new double[]{ 10.0, 20.0}),
                    Tuple.Create(SensitivityQuantity.LayerPressure,new double[]{ 10.0, 20.0}),
                    Tuple.Create(SensitivityQuantity.PI,new double[]{ 14.7, 20.0}),
                    Tuple.Create(SensitivityQuantity.TubingHeadPressure,new double[]{ 10.0, 20.0}),
                    Tuple.Create(SensitivityQuantity.FlowCorrelation,new double[]{ 3,4}),
                    Tuple.Create(SensitivityQuantity.ESPDepth,new double[]{ 10.0, 20.0}),
                    Tuple.Create(SensitivityQuantity.MotorWearFactor,new double[]{ 10.0, 20.0}),
                    Tuple.Create(SensitivityQuantity.OperatingFrequency,new double[]{ 10.0, 20.0}),
                    Tuple.Create(SensitivityQuantity.HeadTuningFactor   ,new double[]{ 10.0, 20.0}),
                    Tuple.Create(SensitivityQuantity.SeparatorEfficiency,new double[]{ 10.0, 20.0}),
                };

                foreach (Tuple<SensitivityQuantity, double[]> sen in VariousSensitivities)
                {
                    wellSensitivitydto.WellId = newWell.Id;
                    wellSensitivitydto.SensitivityType = sen.Item1;
                    wellSensitivitydto.DoubleValue = sen.Item2;
                    IsAddedInDB = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
                    Assert.IsNotNull(IsAddedInDB, "1", "The " + sen.Item1 + "sensitivity not added successfully in DB.");
                }
                Trace.WriteLine("Remaning Sensitivities are added.");

                // Retrive data for all Sensitivities.
                WellSensitivityAndUnitsDTO[] getAllSensitivities = WellService.GetWellSensitivitiesConfigurationAndUnitsForWell(newWell.Id.ToString());
                Assert.IsNotNull(getAllSensitivities, "No Sensitivities found at Database");
                Assert.AreEqual(VariousSensitivities.Count, getAllSensitivities.Count(), "Mismatch count in Various Sensitivities");

                foreach (var sensitivities in getAllSensitivities)
                {
                    var getSensitivity = VariousSensitivities.FirstOrDefault(x => x.Item1 == sensitivities.Value.SensitivityType);
                    Assert.AreEqual(getSensitivity.Item2.Length, sensitivities.Value.DoubleValue.Length, "Mismatch count of double values in" + getSensitivity.Item1.ToString());

                    //Unit verification                    
                    if (getSensitivity.Item1.ToString() == SensitivityQuantity.TubingHeadPressure.ToString())
                        Assert.AreEqual("psia", sensitivities.Units.TubingHeadPressure.UnitKey, "Mismatch units in " + getSensitivity.Item1.ToString() + " Sensitivity");

                    for (int i = 0; i < sensitivities.Value.DoubleValue.Length; i++)
                    {
                        Assert.AreEqual(getSensitivity.Item2[i], Math.Round(sensitivities.Value.DoubleValue[i], 2), 0.05, "Mismatch value at" + i + "in expected" + getSensitivity + "Sensitivity");
                    }
                }
                Trace.WriteLine("Validated Remaning Sensitivities data.");
                #endregion                               

                #region Update exisitng THP Sensitivities data
                //Update existing THP values
                wellSensitivitydto.SensitivityType = SensitivityQuantity.TubingHeadPressure;
                wellSensitivitydto.DoubleValue = new double[] { 100.0, 200.0 };
                IsUpdatedInDB = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
                Assert.IsNotNull(IsUpdatedInDB, "2", "The Sensitivity not updated successfully in DB.");

                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                Trace.WriteLine("System set for Metric unit system");

                // Retrive data for TubingHeadPressure Sensitivities
                WellSensitivityAndUnitsDTO getUpdatedTHPSensitivity = WellService.GetWellSensitivityConfigurationAndUnits(newWell.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.TubingHeadPressure)));
                Assert.AreEqual(689.47, Math.Round(getUpdatedTHPSensitivity.Value.DoubleValue[0], 2), 0.05, "Mismatch value at 0 in expected THP Sensitivity");
                Assert.AreEqual(1378.95, Math.Round(getUpdatedTHPSensitivity.Value.DoubleValue[1], 2), 0.05, "Mismatch value at 1 in expected THP Sensitivity");
                Assert.AreEqual("kPa", getUpdatedTHPSensitivity.Units.TubingHeadPressure.UnitKey, "Mismatch units in THP Sensitivity");

                Trace.WriteLine("Updated exisitng THP Sensitivities data.");
                #endregion Update exisitng THP Sensitivities data

                #region Delete All Sensitivities and validate                
                foreach (var sen in getAllSensitivities)
                {
                    IsDeleted = WellService.RemoveWellSensitivityConfiguration(newWell.Id.ToString(), Convert.ToString(((Int32)sen.Value.SensitivityType)));
                    Assert.IsTrue(IsDeleted, "The " + sen.Value.SensitivityType.ToString() + "sensitivity not deleted successfully in DB.");
                }
                Trace.WriteLine("Remaning Sensitivities are deleted succssfully.");
                #endregion Delete All Sensitivities and validate
            }
            catch (Exception ex)
            {
                Trace.WriteLine("Error in AddSensitivitiesAndPerformanceCurvesForESPTests " + ex.Message);
                Assert.Fail(ex.Message);
            }
            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System reverted and set for US unit system");
                Trace.WriteLine("Sensitivities test successfully executed.");
            }
        }

        /// <summary>
        /// Description : Units verification for sensitivities parameter
        /// Author : Rahul Pingale
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void SensitivitiesUnitCheck()
        {
            string facilityId = GetFacilityId("ESPWELL_", 1);
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            string FileName_USUnit = "SensitivitiesUnits_US.json";
            string FileName_MetricUnit = "SensitivitiesUnits_Metric.json";

            try
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");
                #region Well Configuration                            
                WellDTO newWell = AddNonRRLWell(facilityId, WellTypeId.ESP, false, CalibrationMethodId.LFactor);
                Assert.IsNotNull(newWell);

                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());
                Trace.WriteLine("ESP Well added successfully.");
                #endregion Well Configuration

                // Retrive data for all Sensitivities in US Units system.
                WellSensitivityAndUnitsDTO[] getAllSensitivities = WellService.GetWellSensitivitiesConfigurationAndUnitsForWell(newWell.Id.ToString());

                //Reading expected WellSensitivityAndUnits DTO from Json File
                WellSensitivityAndUnitsDTO[] expectedSensitivities = JsonConvert.DeserializeObject<WellSensitivityAndUnitsDTO[]>(GetJsonString(Path + FileName_USUnit));

                //Verification of sensitivities in US Unit system
                Assert.AreEqual(expectedSensitivities[0].Value, getAllSensitivities[0].Value);
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.CasingHeadPressure, getAllSensitivities[0].Units.CasingHeadPressure, "Mismatch in Casing Head Pressure Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.ErosionCoefficient, getAllSensitivities[0].Units.ErosionCoefficient, "Mismatch in ErosionCoefficient Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.ESPDepth, getAllSensitivities[0].Units.ESPDepth, "Mismatch in ESPDepth Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.FormationGOR, getAllSensitivities[0].Units.FormationGOR, "Mismatch in FormationGOR Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.GasInjectionRate, getAllSensitivities[0].Units.GasInjectionRate, "Mismatch in GasInjectionRate Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.HeadTuningFactor, getAllSensitivities[0].Units.HeadTuningFactor, "Mismatch in HeadTuningFactor Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.LayerPressure, getAllSensitivities[0].Units.LayerPressure, "Mismatch in LayerPressure Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.MotorWearFactor, getAllSensitivities[0].Units.MotorWearFactor, "Mismatch in MotorWearFactor Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.OperatingFrequency, getAllSensitivities[0].Units.OperatingFrequency, "Mismatch in OperatingFrequency Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.PI, getAllSensitivities[0].Units.PI, "Mismatch in PI Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.SeparatorEfficiency, getAllSensitivities[0].Units.SeparatorEfficiency, "Mismatch in SeparatorEfficiency Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.TubingHeadPressure, getAllSensitivities[0].Units.TubingHeadPressure, "Mismatch in TubingHeadPressure Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.WaterCut, getAllSensitivities[0].Units.WaterCut, "Mismatch in WaterCut Properties");

                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                Trace.WriteLine("System set for Metric unit system");

                // Retrive data for all Sensitivities in Metric Units system.
                getAllSensitivities = WellService.GetWellSensitivitiesConfigurationAndUnitsForWell(newWell.Id.ToString());

                //Reading expected WellSensitivityAndUnits DTO from Json File
                expectedSensitivities = JsonConvert.DeserializeObject<WellSensitivityAndUnitsDTO[]>(GetJsonString(Path + FileName_MetricUnit));

                //Verification of sensitivities in Metric Unit system
                Assert.AreEqual(expectedSensitivities[0].Value, getAllSensitivities[0].Value);
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.CasingHeadPressure, getAllSensitivities[0].Units.CasingHeadPressure, "Mismatch in Casing Head Pressure Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.ErosionCoefficient, getAllSensitivities[0].Units.ErosionCoefficient, "Mismatch in ErosionCoefficient Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.ESPDepth, getAllSensitivities[0].Units.ESPDepth, "Mismatch in ESPDepth Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.FormationGOR, getAllSensitivities[0].Units.FormationGOR, "Mismatch in FormationGOR Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.GasInjectionRate, getAllSensitivities[0].Units.GasInjectionRate, "Mismatch in GasInjectionRate Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.HeadTuningFactor, getAllSensitivities[0].Units.HeadTuningFactor, "Mismatch in HeadTuningFactor Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.LayerPressure, getAllSensitivities[0].Units.LayerPressure, "Mismatch in LayerPressure Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.MotorWearFactor, getAllSensitivities[0].Units.MotorWearFactor, "Mismatch in MotorWearFactor Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.OperatingFrequency, getAllSensitivities[0].Units.OperatingFrequency, "Mismatch in OperatingFrequency Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.PI, getAllSensitivities[0].Units.PI, "Mismatch in PI Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.SeparatorEfficiency, getAllSensitivities[0].Units.SeparatorEfficiency, "Mismatch in SeparatorEfficiency Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.TubingHeadPressure, getAllSensitivities[0].Units.TubingHeadPressure, "Mismatch in TubingHeadPressure Properties");
                CompareObjectsUsingReflection(expectedSensitivities[0].Units.WaterCut, getAllSensitivities[0].Units.WaterCut, "Mismatch in WaterCut Properties");

            }
            catch (Exception ex)
            {
                Trace.WriteLine("Error : " + ex.Message);
                Assert.Fail(ex.Message);
            }
            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System reverted and set for US unit system");
            }
        }

        public void AddWellWithFileStremModel(string WellName, WellTypeId wellType, ModelFileBase64DTO filestream)
        {
            WellConfigurationService.AddWellConfig(new WellConfigDTO()
            {
                Well = SetDefaultFluidTypeAndPhase(new WellDTO()
                {
                    Name = WellName,
                    CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)),
                    WellType = wellType,
                    AssemblyAPI = WellName,
                    SubAssemblyAPI = WellName,
                    IntervalAPI = WellName,
                    WellStatusId = 2,
                    WellGroundElevation = 5,
                    WellDepthDatumElevation = 7,
                    WellDepthDatumId = 2,
                    SurfaceLatitude = (decimal?)random.Next(-90, 90),
                    SurfaceLongitude = (decimal?)random.Next(-180, 180)
                })
            });
            WellDTO newWell = WellService.GetWellByName(WellName);
            Assert.IsNotNull(newWell);
            _wellsToRemove.Add(newWell);

            //Importing modified file just before export with base 64 reference
            AssemblyDTO assembly = WellboreComponentService.GetAssemblyByWellId(newWell.Id.ToString());
            ModelFileOptionDTO options = new ModelFileOptionDTO();
            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };
            modelFile.ApplicableDate = newWell.CommissionDate.Value.AddDays(1).ToUniversalTime();
            modelFile.WellId = newWell.Id;

            options.CalibrationMethod = CalibrationMethodId.LFactor;
            options.Comment = "Used Exported file for  " + WellName + " " + wellType;
            options.OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.UpdateGOR_CGR) };
            //USed direct reference of file stream 
            modelFile.Base64Contents = filestream.Base64Contents;
            modelFile.Options = options;

            ModelFileValidationDataDTO ModelFileValidationData;
            ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            if (ModelFileValidationData != null)
                ModelFileService.AddWellModelFile(modelFile);
            else
                Trace.WriteLine(string.Format("Failed to validate model file"));
        }

        public void DeleteExportedFileandFolder(string exportedlocation, string updatedFile, string withoutupdatedFile)
        {
            if (File.Exists(Path.Combine(exportedlocation, updatedFile)))
            {
                // If file found, delete it    
                File.SetAttributes(exportedlocation, FileAttributes.Normal);
                File.Delete(Path.Combine(exportedlocation, updatedFile));
                Console.WriteLine("File deleted.");
            }
            else Console.WriteLine("File not found");

            if (File.Exists(Path.Combine(exportedlocation, withoutupdatedFile)))
            {
                // If file found, delete it    
                File.SetAttributes(exportedlocation, FileAttributes.Normal);
                File.Delete(Path.Combine(exportedlocation, withoutupdatedFile));
                Console.WriteLine("File deleted.");
            }
            else Console.WriteLine("File not found");

            if (Directory.Exists(exportedlocation))
            {
                Directory.Delete(exportedlocation);
            }
        }

        /// Description : FRWM-559 - Non-RRL Well Analysis - Option to export updated well model file
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GLWellExportFunctionality()
        {
            string facilityId = GetFacilityId("GLWELL_", 1);
            string exportedUpdatedFileName = "GLWell_BlackOil_Updated.wflx";
            string exportedWithOutUpdatedFileName = "GLWell_BlackOil_WithOutUpdated.wflx";
            string currentPath = String.Empty;
            string exportUpdatedPath = String.Empty;
            string exportWithOutUpdatedPath = String.Empty;
            string exportedlocation = String.Empty;

            try
            {
                //Adding Well along with WellTest Data
                #region Adding Well with Well Test
                WellDTO glWell = AddNonRRLWell(facilityId, WellTypeId.GLift, false, CalibrationMethodId.LFactor);
                #endregion Adding Well with Well Test

                //Getting WellAnalysis data for latest well test data
                #region Running NodelAnalysis and selecting latest well test record
                // Get it back out and use it to load the analysis inputs (?)
                WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(glWell.Id.ToString());
                NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
                Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.TestData, "Test data is not available in the analysis input");

                Assert.IsNotNull(analysisInput.ModelData.GasLiftData.Value.GasInjectionMode, "Injection Depth is not available in the model data");
                Assert.IsNotNull(analysisInput.ModelData.FlowCorrelation, "Flow Correlation is not available in the model data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
                Assert.IsNotNull(analysisInput.TestData.Value.WellHeadPressure, "Tubing head pressure is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.WellHeadTemperature, "Tubing head temperature is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.OilRate, "Oil rate is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.WaterRate, "Water rate is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.GasRate, "Gas rate is not available in test data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.ProductivityIndex, "Productivity is not available in test data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");
                #endregion Running NodelAnalysis and selecting latest well test record

                //Modifying existing well test records
                #region modifying existing well test data
                analysisInput.CalibrationData.Value.LFactor = 1.0089;
                analysisInput.CalibrationData.Value.ReservoirPressure = 3005;
                analysisInput.CalibrationData.Value.ProductivityIndex = 0.9019;
                analysisInput.TestData.Value.WellHeadPressure = 101;
                analysisInput.TestData.Value.CasingHeadPressure = 1282.5;
                analysisInput.TestData.Value.GasRate = 1205;
                analysisInput.TestData.Value.TotalGasRate = 1905;
                analysisInput.TestData.Value.OilRate = 413;
                analysisInput.TestData.Value.WaterRate = 509.7;

                WellTestDataService.UpdateEngineeredWellTest(analysisInput);
                #endregion modifying existing well test data

                //Creating folder location with file name where wellflo file will export
                #region creating folder directory
                currentPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

                if (!Directory.Exists(Path.Combine(currentPath, "ExportWellFloFile")))
                {
                    Directory.CreateDirectory(Path.Combine(currentPath, "ExportWellFloFile"));
                }
                exportedlocation = Path.Combine(currentPath, "ExportWellFloFile");
                exportUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\GLWell_BlackOil_Updated.wflx");
                exportWithOutUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\GLWell_BlackOil_WithOutUpdated.wflx");
                #endregion creating folder directory

                //Exporting Wellflo file with modified well test data
                #region Exporting Wellflo File With Modified Well Test 
                //Calling export functionality API
                ModelFileBase64DTO fileexportWith = WellTestDataService.GetBase64ModelFileWithAnalysisData("true", analysisInput);
                Stream sourceStream = new MemoryStream(Convert.FromBase64String(fileexportWith.Base64Contents));
                FileStream targetStream = null;
                using (targetStream = new FileStream(exportUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream.Length];
                    sourceStream.Read(buffer, 0, (int)sourceStream.Length);
                    targetStream.Write(buffer, 0, buffer.Length);

                    targetStream.Close();
                    sourceStream.Close();
                }
                Assert.IsNotNull(exportUpdatedPath);
                #endregion Exporting Wellflo File With Modified Well Test 

                //Exporting Wellflo file without modified well test data
                #region Exporting Wellflo File without Modified Well Test
                //Calling export functionality API
                ModelFileBase64DTO fileexportWithOut = WellTestDataService.GetBase64ModelFileWithAnalysisData("false", analysisInput);
                Stream sourceStream_1 = new MemoryStream(Convert.FromBase64String(fileexportWithOut.Base64Contents));
                FileStream targetStream_1 = null;
                using (targetStream_1 = new FileStream(exportWithOutUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream_1.Length];
                    sourceStream_1.Read(buffer, 0, (int)sourceStream_1.Length);
                    targetStream_1.Write(buffer, 0, buffer.Length);

                    targetStream_1.Close();
                    sourceStream_1.Close();
                }
                Assert.IsNotNull(exportWithOutUpdatedPath);
                #endregion Exporting Wellflo File without Modified Well Test 

                //Exported file cannot be reuse(only for API test) because of limitations:
                //1.File can only be import from standard directory "Weatherford.POP.Server.IntegrationTests.TestDocuments." to run intrgration test for team city / ATS.Also, the build action of the file shoul be "embedded resource" which exported file has "None"
                //So,using direct file stream without Base64Contents conversion for reuse the inported file with new well

                //Creating New Well and uploading exported wellflo file which is generated with modified record
                #region creating another Well with exported model file with updated record and comparing withupdated record
                AddWellWithFileStremModel("GLWELL_00002", WellTypeId.GLift, fileexportWith);
                WellDTO newWell = WellService.GetWellByName("GLWELL_00002");
                Assert.IsNotNull(newWell);

                //Comparing exported value with modified record
                var modelconfigdata = WellConfigurationService.GetWellConfigUoM(newWell.Id.ToString());
                double Expected_Reservoir_Pressure = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                Assert.AreEqual(analysisInput.CalibrationData.Value.ReservoirPressure, Expected_Reservoir_Pressure, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(analysisInput.CalibrationData.Value.ProductivityIndex, Expected_PI, 0.1, "Mismatch in Productivity Index");
                Assert.AreEqual((double)analysisInput.TestData.Value.GasOilRatio, Expected_FormationGOR, 0.1, "Mismatch in GOR");
                Assert.AreEqual((double)analysisInput.TestData.Value.WaterCut, Expected_WaterCut, 0.1, "Mismatch in WaterCut");
                #endregion creating another Well with exported model file with updated record and comparing withupdated record

                //Creating New Well and uploading exported wellflo file which is generated without modified record
                #region creating another Well with exported model file without updated record and comparing with original record
                AddWellWithFileStremModel("GLWELL_00003", WellTypeId.GLift, fileexportWithOut);
                WellDTO newWell_2 = WellService.GetWellByName("GLWELL_00003");
                Assert.IsNotNull(newWell_2);

                WellDTO newWell_3 = WellService.GetWellByName(GetFacilityId("GLWELL_", 1));
                Assert.IsNotNull(newWell_3);

                //Comparing exported value with modified record
                var modelconfigdata_2 = WellConfigurationService.GetWellConfigUoM(newWell_2.Id.ToString());
                double Expected_Reservoir_Pressure_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                var modelconfigdata_3 = WellConfigurationService.GetWellConfigUoM(newWell_3.Id.ToString());
                double Expected_Reservoir_Pressure_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;


                Assert.AreEqual(Expected_Reservoir_Pressure_2, Expected_Reservoir_Pressure_3, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(Expected_PI_2, Expected_PI_3, 0.1, "Mismatch in Productivity Index");
                Assert.AreEqual(Expected_FormationGOR_2, Expected_FormationGOR_3, 0.1, "Mismatch in GOR");
                Assert.AreEqual(Expected_WaterCut_2, Expected_WaterCut_3, 0.1, "Mismatch in WaterCut");
                #endregion creating another Well with exported model file without updated record and comparing with original record
            }
            finally
            {
                DeleteExportedFileandFolder(exportedlocation, exportedUpdatedFileName, exportedWithOutUpdatedFileName);
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                RemoveWell(facilityId);
            }
        }

        /// Description : FRWM-559 - Non-RRL Well Analysis - Option to export updated well model file
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void NFWWellFloExportFunctionality()
        {
            string facilityId = GetFacilityId("NFWWELL_", 1);
            string exportedUpdatedFileName = "NFWWell_BlackOil_Updated.wflx";
            string exportedWithOutUpdatedFileName = "NFWWell_BlackOil_WithOutUpdated.wflx";
            string currentPath = String.Empty;
            string exportUpdatedPath = String.Empty;
            string exportWithOutUpdatedPath = String.Empty;
            string exportedlocation = String.Empty;
            try
            {
                //Adding Well along with WellTest Data
                #region Adding Well with Well Test
                WellDTO nfwWell = AddNonRRLWell(facilityId, WellTypeId.NF, false, CalibrationMethodId.LFactor);
                #endregion Adding Well with Well Test

                //Getting WellAnalysis data for latest well test data
                #region Running NodelAnalysis and selecting latest well test record
                // Get it back out and use it to load the analysis inputs (?)
                WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(nfwWell.Id.ToString());
                NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
                Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.TestData, "Test data is not available in the analysis input");


                Assert.IsNotNull(analysisInput.ModelData.FlowCorrelation, "Flow Correlation is not available in the model data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
                Assert.IsNotNull(analysisInput.TestData.Value.WellHeadPressure, "Tubing head pressure is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.WellHeadTemperature, "Tubing head temperature is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.OilRate, "Oil rate is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.WaterRate, "Water rate is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.GasRate, "Gas rate is not available in test data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.ProductivityIndex, "Productivity is not available in test data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");
                Assert.AreNotEqual(analysisInput.ModelData.SolutionNode.Value.Name, analysisInput.ModelData.StartNode.Value.Name, "Start and solution node cannot be the same");
                //Assert.IsNotNull(analysisInput.ModelData.SolutionNode, "Solution node is not available in the model data");
                //Assert.AreEqual(3, analysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of solution nodes are available in analysis input modal data");

                //Assert.IsNotNull(analysisInput.ModelData.StartNode, "Start node is not available in the modal data");
                //Assert.AreEqual(3, analysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of start nodes are available in analysis input modal data");
                #endregion Running NodelAnalysis and selecting latest well test record

                //Modifying existing well test records
                #region modifying existing well test data
                analysisInput.CalibrationData.Value.LFactor = 1.01;
                analysisInput.CalibrationData.Value.ReservoirPressure = 6005;
                analysisInput.CalibrationData.Value.ProductivityIndex = 3.26;
                analysisInput.TestData.Value.WellHeadPressure = 169;
                analysisInput.TestData.Value.GasRate = 885;
                analysisInput.TestData.Value.TotalGasRate = 885;
                analysisInput.TestData.Value.OilRate = 1472.3;
                analysisInput.TestData.Value.WaterRate = 294.1;

                WellTestDataService.UpdateEngineeredWellTest(analysisInput);
                #endregion modifying existing well test data

                //Creating folder location with file name where wellflo file will export
                #region creating folder directory
                currentPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

                if (!Directory.Exists(Path.Combine(currentPath, "ExportWellFloFile")))
                {
                    Directory.CreateDirectory(Path.Combine(currentPath, "ExportWellFloFile"));
                }
                exportedlocation = Path.Combine(currentPath, "ExportWellFloFile");
                exportUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\NFWWell_BlackOil_Updated.wflx");
                exportWithOutUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\NFWWell_BlackOil_WithOutUpdated.wflx");
                #endregion creating folder directory

                //Exporting Wellflo file with modified well test data
                #region Exporting Wellflo File With Modified Well Test 
                //Calling export functionality API
                ModelFileBase64DTO fileexportWith = WellTestDataService.GetBase64ModelFileWithAnalysisData("true", analysisInput);
                Stream sourceStream = new MemoryStream(Convert.FromBase64String(fileexportWith.Base64Contents));
                FileStream targetStream = null;
                using (targetStream = new FileStream(exportUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream.Length];
                    sourceStream.Read(buffer, 0, (int)sourceStream.Length);
                    targetStream.Write(buffer, 0, buffer.Length);

                    targetStream.Close();
                    sourceStream.Close();
                }
                Assert.IsNotNull(exportUpdatedPath);
                #endregion Exporting Wellflo File With Modified Well Test 

                //Exporting Wellflo file without modified well test data
                #region Exporting Wellflo File without Modified Well Test
                //Calling export functionality API
                ModelFileBase64DTO fileexportWithOut = WellTestDataService.GetBase64ModelFileWithAnalysisData("false", analysisInput);
                Stream sourceStream_1 = new MemoryStream(Convert.FromBase64String(fileexportWithOut.Base64Contents));
                FileStream targetStream_1 = null;
                using (targetStream_1 = new FileStream(exportWithOutUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream_1.Length];
                    sourceStream_1.Read(buffer, 0, (int)sourceStream_1.Length);
                    targetStream_1.Write(buffer, 0, buffer.Length);

                    targetStream_1.Close();
                    sourceStream_1.Close();
                }
                Assert.IsNotNull(exportWithOutUpdatedPath);
                #endregion Exporting Wellflo File without Modified Well Test 


                // Exported file cannot be reuse(only for API test) because of limitations:
                //1.File can only be import from standard directory "Weatherford.POP.Server.IntegrationTests.TestDocuments." to run intrgration test for team city / ATS.Also, the build action of the file shoul be "embedded resource" which exported file has "None"
                //So,using direct file stream without Base64Contents conversion for reuse the inported file with new well

                //Creating New Well and uploading exported wellflo file which is generated with modified record
                #region creating another Well with exported model file with updated record and comparing withupdated record
                AddWellWithFileStremModel("NFWWELL_00002", WellTypeId.NF, fileexportWith);
                WellDTO newWell = WellService.GetWellByName("NFWWELL_00002");
                Assert.IsNotNull(newWell);

                //Comparing exported value 
                var modelconfigdata = WellConfigurationService.GetWellConfigUoM(newWell.Id.ToString());
                double Expected_Reservoir_Pressure = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                Assert.AreEqual(analysisInput.CalibrationData.Value.ReservoirPressure, Expected_Reservoir_Pressure, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(analysisInput.CalibrationData.Value.ProductivityIndex, Expected_PI, 0.1, "Mismatch in Productivity Index");
                Assert.AreEqual((double)analysisInput.TestData.Value.GasOilRatio, Expected_FormationGOR, 0.1, "Mismatch in GOR");
                Assert.AreEqual((double)analysisInput.TestData.Value.WaterCut, Expected_WaterCut, 0.1, "Mismatch in Water Cut");
                #endregion creating another Well with exported model file with updated record and comparing withupdated record

                //Creating New Well and uploading exported wellflo file which is generated without modified record
                #region creating another Well with exported model file without updated record and comparing with original record
                AddWellWithFileStremModel("NFWWELL_00003", WellTypeId.NF, fileexportWithOut);
                WellDTO newWell_2 = WellService.GetWellByName("NFWWELL_00003");
                Assert.IsNotNull(newWell_2);

                WellDTO newWell_3 = WellService.GetWellByName(GetFacilityId("NFWWELL_", 1));
                Assert.IsNotNull(newWell_3);

                //Comparing exported value with modified record
                var modelconfigdata_2 = WellConfigurationService.GetWellConfigUoM(newWell_2.Id.ToString());
                double Expected_Reservoir_Pressure_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                var modelconfigdata_3 = WellConfigurationService.GetWellConfigUoM(newWell_3.Id.ToString());
                double Expected_Reservoir_Pressure_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                Assert.AreEqual(Expected_Reservoir_Pressure_2, Expected_Reservoir_Pressure_3, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(Expected_PI_2, Expected_PI_3, 0.1, "Mismatch in Productivity Index");
                Assert.AreEqual(Expected_FormationGOR_2, Expected_FormationGOR_3, 0.1, "Mismatch in GOR");
                Assert.AreEqual(Expected_WaterCut_2, Expected_WaterCut_3, 0.1, "Mismatch in WaterCut");
                #endregion creating another Well with exported model file without updated record and comparing with original record
            }
            finally
            {
                DeleteExportedFileandFolder(exportedlocation, exportedUpdatedFileName, exportedWithOutUpdatedFileName);
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                RemoveWell(facilityId);
            }
        }

        /// Description : FRWM-6749/FRWM-7119 - Non-RRL Well Analysis - Option to export updated well model file
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ESPWellExportFunctionality()
        {
            string facilityId = GetFacilityId("ESPWELL_", 1);
            string exportedUpdatedFileName = "WellfloESPExample1_Updated.wflx";
            string exportedWithOutUpdatedFileName = "WellfloESPExample1_WithOutUpdated.wflx";
            string currentPath = String.Empty;
            string exportUpdatedPath = String.Empty;
            string exportWithOutUpdatedPath = String.Empty;
            string exportedlocation = String.Empty;

            try
            {
                //Adding Well along with WellTest Data
                #region Adding Well with Well Test
                WellDTO ESPWell = AddNonRRLWell(facilityId, WellTypeId.ESP, false, CalibrationMethodId.LFactor);
                #endregion Adding Well with Well Test

                //Getting WellAnalysis data for latest well test data
                #region Running NodelAnalysis and selecting latest well test record
                // Get it back out and use it to load the analysis inputs (?)
                WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(ESPWell.Id.ToString());
                NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
                Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData.ESPData.Value, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.TestData.Value, "Test data is not available in the analysis input");
                #endregion Running NodelAnalysis and selecting latest well test record

                //Modifying existing well test records
                #region modifying existing well test data
                analysisInput.CalibrationData.Value.LFactor = 0.9959;
                analysisInput.ModelData.ESPData.Value.HeadTuningFactor = 1.05;
                analysisInput.CalibrationData.Value.ProductivityIndex = 5.95;
                analysisInput.TestData.Value.WellHeadPressure = 1800;
                analysisInput.TestData.Value.WellHeadTemperature = 110.5;
                analysisInput.CalibrationData.Value.ReservoirPressure = 3075;
                analysisInput.TestData.Value.GasRate = 600;
                analysisInput.TestData.Value.OilRate = 1160.5;
                analysisInput.TestData.Value.WaterRate = 1370.5;

                WellTestDataService.UpdateEngineeredWellTest(analysisInput);
                #endregion modifying existing well test data

                //Creating folder location with file name where wellflo file will export
                #region creating folder directory
                currentPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

                if (!Directory.Exists(Path.Combine(currentPath, "ExportWellFloFile")))
                {
                    Directory.CreateDirectory(Path.Combine(currentPath, "ExportWellFloFile"));
                }
                exportedlocation = Path.Combine(currentPath, "ExportWellFloFile");
                exportUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\WellfloESPExample1_Updated.wflx");
                exportWithOutUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\WellfloESPExample1_WithOutUpdated.wflx");
                #endregion creating folder directory

                //Exporting Wellflo file with modified well test data
                #region Exporting Wellflo File With Modified Well Test 
                //Calling export functionality API
                ModelFileBase64DTO fileexportWith = WellTestDataService.GetBase64ModelFileWithAnalysisData("true", analysisInput);
                Stream sourceStream = new MemoryStream(Convert.FromBase64String(fileexportWith.Base64Contents));
                FileStream targetStream = null;
                using (targetStream = new FileStream(exportUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream.Length];
                    sourceStream.Read(buffer, 0, (int)sourceStream.Length);
                    targetStream.Write(buffer, 0, buffer.Length);

                    targetStream.Close();
                    sourceStream.Close();
                }
                Assert.IsNotNull(exportUpdatedPath);
                #endregion Exporting Wellflo File With Modified Well Test 

                //Exporting Wellflo file without modified well test data
                #region Exporting Wellflo File without Modified Well Test
                //Calling export functionality API
                ModelFileBase64DTO fileexportWithOut = WellTestDataService.GetBase64ModelFileWithAnalysisData("false", analysisInput);
                Stream sourceStream_1 = new MemoryStream(Convert.FromBase64String(fileexportWithOut.Base64Contents));
                FileStream targetStream_1 = null;
                using (targetStream_1 = new FileStream(exportWithOutUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream_1.Length];
                    sourceStream_1.Read(buffer, 0, (int)sourceStream_1.Length);
                    targetStream_1.Write(buffer, 0, buffer.Length);

                    targetStream_1.Close();
                    sourceStream_1.Close();
                }
                Assert.IsNotNull(exportWithOutUpdatedPath);
                #endregion Exporting Wellflo File without Modified Well Test 

                // Exported file cannot be reuse(only for API test) because of limitations:
                //1.File can only be import from standard directory "Weatherford.POP.Server.IntegrationTests.TestDocuments." to run intrgration test for team city / ATS.Also, the build action of the file shoul be "embedded resource" which exported file has "None"
                //So,using direct file stream without Base64Contents conversion for reuse the inported file with new well

                //Creating New Well and uploading exported wellflo file which is generated with modified record
                #region creating another Well with exported model file with updated record and comparing withupdated record
                AddWellWithFileStremModel("ESPWELL_00002", WellTypeId.ESP, fileexportWith);
                WellDTO newWell = WellService.GetWellByName("ESPWELL_00002");
                Assert.IsNotNull(newWell);

                //Comparing exported value 
                var modelconfigdata = WellConfigurationService.GetWellConfigUoM(newWell.Id.ToString());
                double Expected_Reservoir_Pressure = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_GOR = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                Assert.AreEqual(analysisInput.CalibrationData.Value.ReservoirPressure, Expected_Reservoir_Pressure, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(analysisInput.CalibrationData.Value.ProductivityIndex, Expected_PI, 0.1, "Mismatch in Productivity Index");
                Assert.AreEqual((double)analysisInput.TestData.Value.GasOilRatio, Expected_GOR, 0.1, "Mismatch in GOR");
                Assert.AreEqual((double)analysisInput.TestData.Value.WaterCut, Expected_WaterCut, 0.1, "Mismatch in GOR");
                #endregion creating another Well with exported model file with updated record and comparing withupdated record

                //Creating New Well and uploading exported wellflo file which is generated without modified record
                #region creating another Well with exported model file without updated record and comparing with original record
                AddWellWithFileStremModel("ESPWELL_00003", WellTypeId.ESP, fileexportWithOut);
                WellDTO newWell_2 = WellService.GetWellByName("ESPWELL_00003");
                Assert.IsNotNull(newWell_2);

                WellDTO newWell_3 = WellService.GetWellByName(GetFacilityId("ESPWELL_", 1));
                Assert.IsNotNull(newWell_3);

                //Comparing exported value with modified record
                var modelconfigdata_2 = WellConfigurationService.GetWellConfigUoM(newWell_2.Id.ToString());
                double Expected_Reservoir_Pressure_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                var modelconfigdata_3 = WellConfigurationService.GetWellConfigUoM(newWell_3.Id.ToString());
                double Expected_Reservoir_Pressure_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                Assert.AreEqual(Expected_Reservoir_Pressure_2, Expected_Reservoir_Pressure_3, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(Expected_PI_2, Expected_PI_3, 0.1, "Mismatch in Productivity Index");
                Assert.AreEqual(Expected_FormationGOR_2, Expected_FormationGOR_3, 0.1, "Mismatch in GOR");
                Assert.AreEqual(Expected_WaterCut_2, Expected_WaterCut_3, 0.1, "Mismatch in WaterCut");
                #endregion creating another Well with exported model file without updated record and comparing with original record
            }
            finally
            {
                DeleteExportedFileandFolder(exportedlocation, exportedUpdatedFileName, exportedWithOutUpdatedFileName);
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                RemoveWell(facilityId);
            }
        }

        /// Description : FRWM-6749/FRWM-7119 - Non-RRL Well Analysis - Option to export updated well model file
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PCPWellExportFunctionality()
        {
            string facilityId = GetFacilityId("WFTA1K_", 1);
            string exportedUpdatedFileName = "PCP-Multiphase_Updated.wflx";
            string exportedWithOutUpdatedFileName = "PCP-Multiphase_WithOutUpdated.wflx";
            string currentPath = String.Empty;
            string exportUpdatedPath = String.Empty;
            string exportWithOutUpdatedPath = String.Empty;
            string exportedlocation = String.Empty;

            try
            {
                //Adding Well along with WellTest Data
                #region Adding Well with Well Test
                WellDTO PCPWell = AddNonRRLWell(facilityId, WellTypeId.PCP, false, CalibrationMethodId.LFactor);
                #endregion Adding Well with Well Test

                //Getting WellAnalysis data for latest well test data
                #region Running NodelAnalysis and selecting latest well test record
                // Get it back out and use it to load the analysis inputs (?)
                WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(PCPWell.Id.ToString());
                NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
                Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData.PCPData.Value, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.TestData.Value, "Test data is not available in the analysis input");
                #endregion Running NodelAnalysis and selecting latest well test record

                //Modifying existing well test records
                #region modifying existing well test data
                analysisInput.CalibrationData.Value.LFactor = 0.8364;
                analysisInput.CalibrationData.Value.ProductivityIndex = 0.5;
                analysisInput.ModelData.PCPData.Value.FrictionFactor = 0.6;
                analysisInput.ModelData.PCPData.Value.TorqueFactor = 0.7;
                analysisInput.ModelData.PCPData.Value.RateFactor = 0.8;
                analysisInput.TestData.Value.WellHeadPressure = 110;
                analysisInput.TestData.Value.WellHeadTemperature = 110.5;
                analysisInput.ModelData.PCPData.Value.PumpSpeed = 250;
                analysisInput.CalibrationData.Value.ReservoirPressure = 1720;
                analysisInput.TestData.Value.GasRate = 11.50;
                analysisInput.TestData.Value.OilRate = 211.5;
                analysisInput.TestData.Value.WaterRate = 145.5;

                WellTestDataService.UpdateEngineeredWellTest(analysisInput);
                #endregion modifying existing well test data

                //Creating folder location with file name where wellflo file will export
                #region creating folder directory
                currentPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

                if (!Directory.Exists(Path.Combine(currentPath, "ExportWellFloFile")))
                {
                    Directory.CreateDirectory(Path.Combine(currentPath, "ExportWellFloFile"));
                }
                exportedlocation = Path.Combine(currentPath, "ExportWellFloFile");
                exportUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\PCP-Multiphase_Updated.wflx");
                exportWithOutUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\PCP-Multiphase_WithOutUpdated.wflx");
                #endregion creating folder directory

                //Exporting Wellflo file with modified well test data
                #region Exporting Wellflo File With Modified Well Test 
                //Calling export functionality API
                ModelFileBase64DTO fileexportWith = WellTestDataService.GetBase64ModelFileWithAnalysisData("true", analysisInput);
                Stream sourceStream = new MemoryStream(Convert.FromBase64String(fileexportWith.Base64Contents));
                FileStream targetStream = null;
                using (targetStream = new FileStream(exportUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream.Length];
                    sourceStream.Read(buffer, 0, (int)sourceStream.Length);
                    targetStream.Write(buffer, 0, buffer.Length);

                    targetStream.Close();
                    sourceStream.Close();
                }
                Assert.IsNotNull(exportUpdatedPath);
                #endregion Exporting Wellflo File With Modified Well Test 

                //Exporting Wellflo file without modified well test data
                #region Exporting Wellflo File without Modified Well Test
                //Calling export functionality API
                ModelFileBase64DTO fileexportWithOut = WellTestDataService.GetBase64ModelFileWithAnalysisData("false", analysisInput);
                Stream sourceStream_1 = new MemoryStream(Convert.FromBase64String(fileexportWithOut.Base64Contents));
                FileStream targetStream_1 = null;
                using (targetStream_1 = new FileStream(exportWithOutUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream_1.Length];
                    sourceStream_1.Read(buffer, 0, (int)sourceStream_1.Length);
                    targetStream_1.Write(buffer, 0, buffer.Length);

                    targetStream_1.Close();
                    sourceStream_1.Close();
                }
                Assert.IsNotNull(exportWithOutUpdatedPath);
                #endregion Exporting Wellflo File without Modified Well Test

                // Exported file cannot be reuse(only for API test) because of limitations:
                //1.File can only be import from standard directory "Weatherford.POP.Server.IntegrationTests.TestDocuments." to run intrgration test for team city / ATS.Also, the build action of the file shoul be "embedded resource" which exported file has "None"
                //So,using direct file stream without Base64Contents conversion for reuse the inported file with new well

                //Creating New Well and uploading exported wellflo file which is generated with modified record
                #region creating another Well with exported model file with updated record and comparing withupdated record
                AddWellWithFileStremModel("PCPWELL_00002", WellTypeId.PCP, fileexportWith);
                WellDTO newWell = WellService.GetWellByName("PCPWELL_00002");
                Assert.IsNotNull(newWell);

                //Comparing exported value 
                var modelconfigdata = WellConfigurationService.GetWellConfigUoM(newWell.Id.ToString());
                double Expected_Reservoir_Pressure = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_GOR = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                Assert.AreEqual(analysisInput.CalibrationData.Value.ReservoirPressure, Expected_Reservoir_Pressure, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(analysisInput.CalibrationData.Value.ProductivityIndex, Expected_PI, 0.1, "Mismatch in Productivity Index");
                Assert.AreEqual((double)analysisInput.TestData.Value.GasOilRatio, Expected_GOR, 0.1, "Mismatch in GOR");
                Assert.AreEqual((double)analysisInput.TestData.Value.WaterCut, Expected_WaterCut, 0.1, "Mismatch in Water Cut");
                #endregion creating another Well with exported model file with updated record and comparing withupdated record

                //Creating New Well and uploading exported wellflo file which is generated without modified record
                #region creating another Well with exported model file without updated record and comparing with original record
                AddWellWithFileStremModel("PCPWELL_00003", WellTypeId.PCP, fileexportWithOut);
                WellDTO newWell_2 = WellService.GetWellByName("PCPWELL_00003");
                Assert.IsNotNull(newWell_2);

                WellDTO newWell_3 = WellService.GetWellByName(GetFacilityId("WFTA1K_", 1));
                Assert.IsNotNull(newWell_3);

                //Comparing exported value with modified record
                var modelconfigdata_2 = WellConfigurationService.GetWellConfigUoM(newWell_2.Id.ToString());
                double Expected_Reservoir_Pressure_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                var modelconfigdata_3 = WellConfigurationService.GetWellConfigUoM(newWell_3.Id.ToString());
                double Expected_Reservoir_Pressure_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;
                double Expected_FormationGOR_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().GOR;
                double Expected_WaterCut_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().WaterCut;

                Assert.AreEqual(Expected_Reservoir_Pressure_2, Expected_Reservoir_Pressure_3, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(Expected_PI_2, Expected_PI_3, 0.1, "Mismatch in Productivity Index");
                Assert.AreEqual(Expected_FormationGOR_2, Expected_FormationGOR_3, 0.1, "Mismatch in GOR");
                Assert.AreEqual(Expected_WaterCut_2, Expected_WaterCut_3, 0.1, "Mismatch in WaterCut");
                #endregion creating another Well with exported model file without updated record and comparing with original record
            }
            finally
            {
                DeleteExportedFileandFolder(exportedlocation, exportedUpdatedFileName, exportedWithOutUpdatedFileName);
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                RemoveWell(facilityId);
            }
        }

        /// Description : FRWM-6749/FRWM-7119 - Non-RRL Well Analysis - Option to export updated well model file
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GASInjectionWellExportFunctionality()
        {
            string facilityId = GetFacilityId("GASINJWELL_", 1);
            string exportedUpdatedFileName = "WellfloGasInjectionExample1_Updated.wflx";
            string exportedWithOutUpdatedFileName = "WellfloGasInjectionExample1_WithOutUpdated.wflx";
            string currentPath = String.Empty;
            string exportUpdatedPath = String.Empty;
            string exportWithOutUpdatedPath = String.Empty;
            string exportedlocation = String.Empty;
            try
            {
                //Adding Well along with WellTest Data
                #region Adding Well with Well Test
                WellDTO GASInjWell = AddNonRRLWell(facilityId, WellTypeId.GInj, false, CalibrationMethodId.LFactor);
                #endregion Adding Well with Well Test

                //Getting WellAnalysis data for latest well test data
                #region Running NodelAnalysis and selecting latest well test record
                // Get it back out and use it to load the analysis inputs (?)
                WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(GASInjWell.Id.ToString());
                NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
                Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.TestData.Value, "Test data is not available in the analysis input");
                #endregion Running NodelAnalysis and selecting latest well test record

                //Modifying existing well test records
                #region modifying existing well test data
                analysisInput.CalibrationData.Value.LFactor = 0.9832;
                analysisInput.CalibrationData.Value.DarcyFlowCoeff = 719416320.00;
                analysisInput.CalibrationData.Value.ReservoirPressure = 2014;
                analysisInput.TestData.Value.WellHeadPressure = 1815;
                analysisInput.TestData.Value.WellHeadTemperature = 125.5;
                analysisInput.TestData.Value.GasRate = 650;

                WellTestDataService.UpdateEngineeredWellTest(analysisInput);
                #endregion modifying existing well test data

                //Creating folder location with file name where wellflo file will export
                #region creating folder directory
                currentPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

                if (!Directory.Exists(Path.Combine(currentPath, "ExportWellFloFile")))
                {
                    Directory.CreateDirectory(Path.Combine(currentPath, "ExportWellFloFile"));
                }
                exportedlocation = Path.Combine(currentPath, "ExportWellFloFile");
                exportUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\WellfloGasInjectionExample1_Updated.wflx");
                exportWithOutUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\WellfloGasInjectionExample1_WithOutUpdated.wflx");
                #endregion creating folder directory

                //Exporting Wellflo file with modified well test data
                #region Exporting Wellflo File With Modified Well Test 
                //Calling export functionality API
                ModelFileBase64DTO fileexportWith = WellTestDataService.GetBase64ModelFileWithAnalysisData("true", analysisInput);
                Stream sourceStream = new MemoryStream(Convert.FromBase64String(fileexportWith.Base64Contents));
                FileStream targetStream = null;
                using (targetStream = new FileStream(exportUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream.Length];
                    sourceStream.Read(buffer, 0, (int)sourceStream.Length);
                    targetStream.Write(buffer, 0, buffer.Length);

                    targetStream.Close();
                    sourceStream.Close();
                }
                Assert.IsNotNull(exportUpdatedPath);
                #endregion Exporting Wellflo File With Modified Well Test 

                //Exporting Wellflo file without modified well test data
                #region Exporting Wellflo File without Modified Well Test
                //Calling export functionality API
                ModelFileBase64DTO fileexportWithOut = WellTestDataService.GetBase64ModelFileWithAnalysisData("false", analysisInput);
                Stream sourceStream_1 = new MemoryStream(Convert.FromBase64String(fileexportWithOut.Base64Contents));
                FileStream targetStream_1 = null;
                using (targetStream_1 = new FileStream(exportWithOutUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream_1.Length];
                    sourceStream_1.Read(buffer, 0, (int)sourceStream_1.Length);
                    targetStream_1.Write(buffer, 0, buffer.Length);

                    targetStream_1.Close();
                    sourceStream_1.Close();
                }
                Assert.IsNotNull(exportWithOutUpdatedPath);
                #endregion Exporting Wellflo File without Modified Well Test 

                // Exported file cannot be reuse(only for API test) because of limitations:
                //1.File can only be import from standard directory "Weatherford.POP.Server.IntegrationTests.TestDocuments." to run intrgration test for team city / ATS.Also, the build action of the file shoul be "embedded resource" which exported file has "None"
                //So,using direct file stream without Base64Contents conversion for reuse the inported file with new well

                //Creating New Well and uploading exported wellflo file which is generated with modified record
                #region creating another Well with exported model file with updated record and comparing withupdated record
                AddWellWithFileStremModel("GASINJWELL_00002", WellTypeId.GInj, fileexportWith);
                WellDTO newWell = WellService.GetWellByName("GASINJWELL_00002");
                Assert.IsNotNull(newWell);

                //Comparing exported value
                var modelconfigdata = WellConfigurationService.GetWellConfigUoM(newWell.Id.ToString());
                double Expected_Reservoir_Pressure = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_Darcy = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().DarcyCoef;

                Assert.AreEqual(analysisInput.CalibrationData.Value.ReservoirPressure, Expected_Reservoir_Pressure, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(analysisInput.CalibrationData.Value.DarcyFlowCoeff, Expected_Darcy, 0.1, "Mismatch in DarcyFlowCoeff");
                #endregion creating another Well with exported model file with updated record and comparing withupdated record

                //Creating New Well and uploading exported wellflo file which is generated without modified record
                #region creating another Well with exported model file without updated record and comparing with original record
                AddWellWithFileStremModel("GASINJWELL_00003", WellTypeId.GInj, fileexportWithOut);
                WellDTO newWell_2 = WellService.GetWellByName("GASINJWELL_00003");
                Assert.IsNotNull(newWell_2);

                WellDTO newWell_3 = WellService.GetWellByName(GetFacilityId("GASINJWELL_", 1));
                Assert.IsNotNull(newWell_3);

                //Comparing exported value with modified record
                var modelconfigdata_2 = WellConfigurationService.GetWellConfigUoM(newWell_2.Id.ToString());
                double Expected_Reservoir_Pressure_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_Darcy_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().DarcyCoef;

                var modelconfigdata_3 = WellConfigurationService.GetWellConfigUoM(newWell_3.Id.ToString());
                double Expected_Reservoir_Pressure_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_Darcy_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().DarcyCoef;

                Assert.AreEqual(Expected_Reservoir_Pressure_2, Expected_Reservoir_Pressure_3, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(Expected_Darcy_2, Expected_Darcy_3, 0.1, "Mismatch in Productivity Index");
                #endregion creating another Well with exported model file without updated record and comparing with original record
            }
            finally
            {
                DeleteExportedFileandFolder(exportedlocation, exportedUpdatedFileName, exportedWithOutUpdatedFileName);
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                RemoveWell(facilityId);
            }
        }

        /// Description : FRWM-6749/FRWM-7119 - Non-RRL Well Analysis - Option to export updated well model file
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WaterInjectionWellExportFunctionality()
        {
            string facilityId = GetFacilityId("WATERINJWELL_", 1);
            string exportedUpdatedFileName = "WellfloWaterInjectionExample1_Updated.wflx";
            string exportedWithOutUpdatedFileName = "WellfloWaterInjectionExample1_WithOutUpdated.wflx";
            string currentPath = String.Empty;
            string exportUpdatedPath = String.Empty;
            string exportWithOutUpdatedPath = String.Empty;
            string exportedlocation = String.Empty;

            try
            {
                //Adding Well along with WellTest Data
                #region Adding Well with Well Test
                WellDTO WATERInjWell = AddNonRRLWell(facilityId, WellTypeId.WInj, false, CalibrationMethodId.LFactor);
                #endregion Adding Well with Well Test

                //Getting WellAnalysis data for latest well test data
                #region Running NodelAnalysis and selecting latest well test record
                // Get it back out and use it to load the analysis inputs (?)
                WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(WATERInjWell.Id.ToString());
                NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

                Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
                Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.TestData.Value, "Test data is not available in the analysis input");
                #endregion Running NodelAnalysis and selecting latest well test record

                //Modifying existing well test records
                #region modifying existing well test data
                analysisInput.CalibrationData.Value.LFactor = 0.9832;
                analysisInput.CalibrationData.Value.ProductivityIndex = 6.8643;
                analysisInput.CalibrationData.Value.ReservoirPressure = 2014;
                analysisInput.TestData.Value.WellHeadPressure = 1815;
                analysisInput.TestData.Value.WellHeadTemperature = 125.5;
                analysisInput.TestData.Value.GasRate = 650;

                WellTestDataService.UpdateEngineeredWellTest(analysisInput);
                #endregion modifying existing well test data

                //Creating folder location with file name where wellflo file will export
                #region creating folder directory
                currentPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

                if (!Directory.Exists(Path.Combine(currentPath, "ExportWellFloFile")))
                {
                    Directory.CreateDirectory(Path.Combine(currentPath, "ExportWellFloFile"));
                }
                exportedlocation = Path.Combine(currentPath, "ExportWellFloFile");
                exportUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\WellfloWaterInjectionExample1_Updated.wflx");
                exportWithOutUpdatedPath = Path.Combine(currentPath, "ExportWellFloFile\\WellfloWaterInjectionExample1_WithOutUpdated.wflx");
                #endregion creating folder directory

                //Exporting Wellflo file with modified well test data
                #region Exporting Wellflo File With Modified Well Test 
                //Calling export functionality API
                ModelFileBase64DTO fileexportWith = WellTestDataService.GetBase64ModelFileWithAnalysisData("true", analysisInput);
                Stream sourceStream = new MemoryStream(Convert.FromBase64String(fileexportWith.Base64Contents));
                FileStream targetStream = null;
                using (targetStream = new FileStream(exportUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream.Length];
                    sourceStream.Read(buffer, 0, (int)sourceStream.Length);
                    targetStream.Write(buffer, 0, buffer.Length);

                    targetStream.Close();
                    sourceStream.Close();
                }
                Assert.IsNotNull(exportUpdatedPath);
                #endregion Exporting Wellflo File With Modified Well Test 

                //Exporting Wellflo file without modified well test data
                #region Exporting Wellflo File without Modified Well Test
                //Calling export functionality API
                ModelFileBase64DTO fileexportWithOut = WellTestDataService.GetBase64ModelFileWithAnalysisData("false", analysisInput);
                Stream sourceStream_1 = new MemoryStream(Convert.FromBase64String(fileexportWithOut.Base64Contents));
                FileStream targetStream_1 = null;
                using (targetStream_1 = new FileStream(exportWithOutUpdatedPath, FileMode.Create, FileAccess.Write, FileShare.None))
                {
                    byte[] buffer = new byte[sourceStream_1.Length];
                    sourceStream_1.Read(buffer, 0, (int)sourceStream_1.Length);
                    targetStream_1.Write(buffer, 0, buffer.Length);

                    targetStream_1.Close();
                    sourceStream_1.Close();
                }
                Assert.IsNotNull(exportWithOutUpdatedPath);
                #endregion Exporting Wellflo File without Modified Well Test 

                // Exported file cannot be reuse(only for API test) because of limitations:
                //1.File can only be import from standard directory "Weatherford.POP.Server.IntegrationTests.TestDocuments." to run intrgration test for team city / ATS.Also, the build action of the file shoul be "embedded resource" which exported file has "None"
                //So,using direct file stream without Base64Contents conversion for reuse the inported file with new well

                //Creating New Well and uploading exported wellflo file which is generated with modified record
                #region creating another Well with exported model file with updated record and comparing withupdated record
                AddWellWithFileStremModel("WATERINJWELL_00002", WellTypeId.WInj, fileexportWith);
                WellDTO newWell = WellService.GetWellByName("WATERINJWELL_00002");
                Assert.IsNotNull(newWell);

                //Comparing exported value
                var modelconfigdata = WellConfigurationService.GetWellConfigUoM(newWell.Id.ToString());
                double Expected_Reservoir_Pressure = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI = modelconfigdata.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;

                Assert.AreEqual(analysisInput.CalibrationData.Value.ReservoirPressure, Expected_Reservoir_Pressure, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(analysisInput.CalibrationData.Value.ProductivityIndex, Expected_PI, 0.1, "Mismatch in Injectivity Index");
                #endregion creating another Well with exported model file with updated record and comparing withupdated record

                //Creating New Well and uploading exported wellflo file which is generated without modified record
                #region creating another Well with exported model file without updated record and comparing with original record
                AddWellWithFileStremModel("WATERINJWELL_00003", WellTypeId.WInj, fileexportWithOut);
                WellDTO newWell_2 = WellService.GetWellByName("WATERINJWELL_00003");
                Assert.IsNotNull(newWell_2);

                WellDTO newWell_3 = WellService.GetWellByName(GetFacilityId("WATERINJWELL_", 1));
                Assert.IsNotNull(newWell_3);

                //Comparing exported value with modified record
                var modelconfigdata_2 = WellConfigurationService.GetWellConfigUoM(newWell_2.Id.ToString());
                double Expected_Reservoir_Pressure_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_2 = modelconfigdata_2.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;

                var modelconfigdata_3 = WellConfigurationService.GetWellConfigUoM(newWell_3.Id.ToString());
                double Expected_Reservoir_Pressure_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().Pressure;
                double Expected_PI_3 = modelconfigdata_3.Value.CommonModelConfig.ReservoirData.LayerDataAndUnits.Values.FirstOrDefault().ProductivityIndex;

                Assert.AreEqual(Expected_Reservoir_Pressure_2, Expected_Reservoir_Pressure_3, "Mismatch in Reservoir Pressure");
                Assert.AreEqual(Expected_PI_2, Expected_PI_3, 0.1, "Mismatch in Productivity Index");
                #endregion creating another Well with exported model file without updated record and comparing with original record
            }
            finally
            {
                DeleteExportedFileandFolder(exportedlocation, exportedUpdatedFileName, exportedWithOutUpdatedFileName);
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                RemoveWell(facilityId);
            }
        }

        /// Description : FRWM-732 - Add Calculate Choke D Factor in Optional Updates
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void NFWWellChokeDFactorOptionalUpdate()
        {
            WellDTO NFWWell = new WellDTO();
            try
            {
                // Set system to US units
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");

                #region NFW Well Creation
                WellConfigurationService.AddWellConfig(new WellConfigDTO()
                {
                    Well = SetDefaultFluidTypeAndPhase(new WellDTO()
                    {
                        Name = "NFWWELL_00001",
                        CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)),
                        WellType = WellTypeId.NF,
                        AssemblyAPI = "NFWWELL_00001",
                        SubAssemblyAPI = "NFWWELL_00001",
                        IntervalAPI = "NFWWELL_00001",
                        DepthCorrectionFactor = 2,
                        WellDepthDatumElevation = 1,
                        WellDepthDatumId = 2
                    })
                });
                NFWWell = WellService.GetWellByName("NFWWELL_00001");
                Assert.IsNotNull(NFWWell);
                #endregion NFW Well Creation

                #region model file without Choke D Factor Option
                //Attaching NFW Well Model
                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                byte[] fileAsByteArray;
                ModelFileValidationDataDTO ModelFileValidationData;
                AssemblyDTO assembly = WellboreComponentService.GetAssemblyByWellId(NFWWell.Id.ToString());
                ModelFileOptionDTO options = new ModelFileOptionDTO();
                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };
                modelFile.ApplicableDate = NFWWell.CommissionDate.Value.AddDays(1).ToUniversalTime();
                modelFile.WellId = NFWWell.Id;

                fileAsByteArray = GetByteArray(Path, "WellfloNFWExample1.wflx");
                options.CalibrationMethod = CalibrationMethodId.LFactor;
                options.Comment = "NF";
                options.OptionalUpdate = new long[]
                { ((long)OptionalUpdates.UpdateWCT_WGR),
                   ((long)OptionalUpdates.UpdateGOR_CGR),
                   // ((long)OptionalUpdates.CalculateChokeD_Factor)  //Uploading without Choke Factor
                };
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                modelFile.Options = options;
                ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                if (ModelFileValidationData != null)
                    ModelFileService.AddWellModelFile(modelFile);
                else
                    Trace.WriteLine(string.Format("Failed to validate NF model file"));
                #endregion model file without Choke D Factor Option

                #region Entering Well Test Data
                // Inserting Well Test Data
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = NFWWell.Id,
                    SPTCodeDescription = "AllocatableTest",
                    TestDuration = 24,
                    AverageTubingPressure = 1000,
                    AverageTubingTemperature = 80.3m,
                    GaugePressure = 5800,
                    Oil = 100,
                    Gas = 50,
                    Water = 35,
                    ChokeSize = 360,
                    FlowLinePressure = 800,
                    FlowLineTemperature = 67.3m,
                    SeparatorPressure = 500,
                    Comment = "Choke D Factor Calulations",
                };
                testDataDTO.SampleDate = NFWWell.CommissionDate.Value.AddDays(2).ToUniversalTime();
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(NFWWell.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                #endregion Entering Well Test Data

                //Getting Welll Test Data - Choke D Factor should be null
                WellTestAndUnitsDTO WellTestWithOutChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(NFWWell.Id.ToString());
                Assert.IsNull(WellTestWithOutChokeDFactor_US.Value.ChokeDFactor);

                #region model file with Choke D Factor Option
                //Updating Model File With Choke D Factor
                ModelFileHeaderDTO headerdto = ModelFileService.GetCurrentModelHeader(NFWWell.Id.ToString());
                headerdto.Options.OptionalUpdate = new long[] { 1, 2, 4 };
                ModelFileService.SaveModelFileOptions(headerdto.Options);
                #endregion model file with Choke D Factor Option

                #region Validating tuning and Choke D Factor Calulation
                //Getting Welll Test Data - For Choke D Factor Calculations
                WellTestAndUnitsDTO WellTestForChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(NFWWell.Id.ToString());
                Assert.AreEqual("TUNING_NOT_COMPLETE", WellTestForChokeDFactor_US.Value.Status.ToString(), "Mismatch in expected result");

                WellTestDataService.TuneSelectedWellTests(new long[] { WellTestForChokeDFactor_US.Value.Id });
                WellTestAndUnitsDTO WellTestWithChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(NFWWell.Id.ToString());

                Assert.IsNotNull(WellTestWithChokeDFactor_US.Value.ChokeDFactor);
                Assert.AreEqual(0.03, (double)WellTestWithChokeDFactor_US.Value.ChokeDFactor, 0.01, "Mismatch Choke D Factor Calculation");
                #endregion Validating tuning and Choke D Factor Calulation

                #region validation with Metric Conversion 
                //Getting Welll Test Data in Metric System
                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                Trace.WriteLine("System set for Metric unit system");

                WellTestAndUnitsDTO WellTestWithChokeDFactor_Metric = WellTestDataService.GetLatestValidWellTestByWellId(NFWWell.Id.ToString());
                Assert.IsNotNull(WellTestWithChokeDFactor_Metric.Value.ChokeDFactor);
                Assert.AreEqual(0.03, (double)WellTestWithChokeDFactor_Metric.Value.ChokeDFactor, 0.01, "Mismatch Choke D Factor Calculation");
                #endregion validation with Metric Conversion
            }
            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                _wellsToRemove.Add(NFWWell);
            }
        }

        /// Description : FRWM-732 - Add Calculate Choke D Factor in Optional Updates
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ESPWellChokeDFactorOptionalUpdate()
        {
            WellDTO ESPWell = new WellDTO();
            try
            {
                // Set system to US units
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");

                #region ESP Well Creation
                WellConfigurationService.AddWellConfig(new WellConfigDTO()
                {
                    Well = SetDefaultFluidTypeAndPhase(new WellDTO()
                    {
                        Name = "ESPWELL_00001",
                        CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)),
                        WellType = WellTypeId.ESP,
                        AssemblyAPI = "ESPWELL_00001",
                        SubAssemblyAPI = "ESPWELL_00001",
                        IntervalAPI = "ESPWELL_00001",
                        DepthCorrectionFactor = 2,
                        WellDepthDatumElevation = 1,
                        WellDepthDatumId = 2
                    })
                });
                ESPWell = WellService.GetWellByName("ESPWELL_00001");
                Assert.IsNotNull(ESPWell);
                #endregion ESP Well Creation

                #region model file without Choke D Factor Option
                //Attaching ESP Well Model
                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                byte[] fileAsByteArray;
                ModelFileValidationDataDTO ModelFileValidationData;
                AssemblyDTO assembly = WellboreComponentService.GetAssemblyByWellId(ESPWell.Id.ToString());
                ModelFileOptionDTO options = new ModelFileOptionDTO();
                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };
                modelFile.ApplicableDate = ESPWell.CommissionDate.Value.AddDays(1).ToUniversalTime();
                modelFile.WellId = ESPWell.Id;

                fileAsByteArray = GetByteArray(Path, "WellfloESPExample1.wflx");
                options.CalibrationMethod = CalibrationMethodId.LFactor;
                options.Comment = "ESP";
                options.OptionalUpdate = new long[]
                { ((long)OptionalUpdates.UpdateWCT_WGR),
                   ((long)OptionalUpdates.UpdateGOR_CGR),
                   // ((long)OptionalUpdates.CalculateChokeD_Factor)  //Uploading without Choke Factor
                };
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                modelFile.Options = options;
                ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                if (ModelFileValidationData != null)
                    ModelFileService.AddWellModelFile(modelFile);
                else
                    Trace.WriteLine(string.Format("Failed to validate ESP model file"));
                #endregion model file without Choke D Factor Option

                #region Entering Well Test Data
                // Inserting Well Test Data
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = ESPWell.Id,
                    SPTCodeDescription = "AllocatableTest",
                    TestDuration = 24,
                    AverageTubingPressure = 1795,
                    AverageTubingTemperature = 100,
                    AverageCasingPressure = 2600,
                    GaugePressure = 5800,
                    PumpIntakePressure = 2674,
                    PumpDischargePressure = 3067.59m,
                    Oil = 1157,
                    Gas = 596,
                    Water = 1367,
                    ChokeSize = 360,
                    FlowLinePressure = 1300,
                    FlowLineTemperature = 67.3m,
                    SeparatorPressure = 987,
                    Frequency = 60,
                    Comment = "Choke D Factor Calulations",

                };
                testDataDTO.SampleDate = ESPWell.CommissionDate.Value.AddDays(2).ToUniversalTime();
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(ESPWell.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                #endregion Entering Well Test Data

                //Getting Welll Test Data - Choke D Factor should be null
                WellTestAndUnitsDTO WellTestWithOutChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(ESPWell.Id.ToString());
                Assert.IsNull(WellTestWithOutChokeDFactor_US.Value.ChokeDFactor);

                #region model file with Choke D Factor Option
                //Updating Model File With Choke D Factor
                ModelFileHeaderDTO headerdto = ModelFileService.GetCurrentModelHeader(ESPWell.Id.ToString());
                headerdto.Options.OptionalUpdate = new long[] { 1, 2, 4 };
                ModelFileService.SaveModelFileOptions(headerdto.Options);
                #endregion model file with Choke D Factor Option

                #region Validating tuning and Choke D Factor Calulation
                //Getting Welll Test Data - For Choke D Factor Calculations
                WellTestAndUnitsDTO WellTestForChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(ESPWell.Id.ToString());
                Assert.AreEqual("TUNING_NOT_COMPLETE", WellTestForChokeDFactor_US.Value.Status.ToString(), "Mismatch in expected result");

                WellTestDataService.TuneSelectedWellTests(new long[] { WellTestForChokeDFactor_US.Value.Id });
                WellTestAndUnitsDTO WellTestWithChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(ESPWell.Id.ToString());

                Assert.IsNotNull(WellTestWithChokeDFactor_US.Value.ChokeDFactor);
                Assert.AreEqual(0.07, (double)WellTestWithChokeDFactor_US.Value.ChokeDFactor, 0.01, "Mismatch Choke D Factor Calculation");
                #endregion Validating tuning and Choke D Factor Calulation

                #region validation with Metric Conversion 
                //Getting Welll Test Data in Metric System
                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                Trace.WriteLine("System set for Metric unit system");

                WellTestAndUnitsDTO WellTestWithChokeDFactor_Metric = WellTestDataService.GetLatestValidWellTestByWellId(ESPWell.Id.ToString());
                Assert.IsNotNull(WellTestWithChokeDFactor_Metric.Value.ChokeDFactor);
                Assert.AreEqual(0.07, (double)WellTestWithChokeDFactor_Metric.Value.ChokeDFactor, 0.01, "Mismatch Choke D Factor Calculation");
                #endregion validation with Metric Conversion
            }
            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                _wellsToRemove.Add(ESPWell);
            }

        }

        /// Description : FRWM-732 - Add Calculate Choke D Factor in Optional Updates
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GLWellChokeDFactorOptionalUpdate()
        {
            WellDTO GLWell = new WellDTO();
            try
            {
                // Set system to US units
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");

                #region GL Well Creation
                WellConfigurationService.AddWellConfig(new WellConfigDTO()
                {
                    Well = SetDefaultFluidTypeAndPhase(new WellDTO()
                    {
                        Name = "GLWELL_00001",
                        CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)),
                        WellType = WellTypeId.GLift,
                        AssemblyAPI = "GLWELL_00001",
                        SubAssemblyAPI = "GLWELL_00001",
                        IntervalAPI = "GLWELL_00001",
                        DepthCorrectionFactor = 2,
                        WellDepthDatumElevation = 1,
                        WellDepthDatumId = 2
                    })
                });
                GLWell = WellService.GetWellByName("GLWELL_00001");
                Assert.IsNotNull(GLWell);
                #endregion GL Well Creation

                #region model file without Choke D Factor Option
                //Attaching GL Well Model
                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                byte[] fileAsByteArray;
                ModelFileValidationDataDTO ModelFileValidationData;
                AssemblyDTO assembly = WellboreComponentService.GetAssemblyByWellId(GLWell.Id.ToString());
                ModelFileOptionDTO options = new ModelFileOptionDTO();
                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };
                modelFile.ApplicableDate = GLWell.CommissionDate.Value.AddDays(1).ToUniversalTime();
                modelFile.WellId = GLWell.Id;

                fileAsByteArray = GetByteArray(Path, "GL-01-Base.wflx");
                options.CalibrationMethod = CalibrationMethodId.LFactor;
                options.Comment = "GLWell";
                options.OptionalUpdate = new long[]
                { ((long)OptionalUpdates.UpdateWCT_WGR),
                   ((long)OptionalUpdates.UpdateGOR_CGR),
                   // ((long)OptionalUpdates.CalculateChokeD_Factor)  //Uploading without Choke Factor
                };
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                modelFile.Options = options;
                ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                if (ModelFileValidationData != null)
                    ModelFileService.AddWellModelFile(modelFile);
                else
                    Trace.WriteLine(string.Format("Failed to validate GLWell model file"));
                #endregion model file without Choke D Factor Option

                #region Entering Well Test Data
                // Inserting Well Test Data
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = GLWell.Id,
                    SPTCodeDescription = "AllocatableTest",
                    TestDuration = 24,
                    AverageTubingPressure = 1600,
                    AverageTubingTemperature = 100,
                    AverageCasingPressure = 1277.50m,
                    GaugePressure = 5800,
                    Oil = 400,
                    Gas = 450,
                    GasInjectionRate = 1200,
                    Water = 415,
                    ChokeSize = 360,
                    FlowLinePressure = 1500,
                    FlowLineTemperature = 67.3m,
                    SeparatorPressure = 500,
                    Comment = "Choke D Factor Calulations",

                };
                testDataDTO.SampleDate = GLWell.CommissionDate.Value.AddDays(2).ToUniversalTime();
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(GLWell.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                #endregion Entering Well Test Data

                //Getting Welll Test Data - Choke D Factor should be null
                WellTestAndUnitsDTO WellTestWithOutChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(GLWell.Id.ToString());
                Assert.IsNull(WellTestWithOutChokeDFactor_US.Value.ChokeDFactor);

                #region model file with Choke D Factor Option
                //Updating Model File With Choke D Factor
                ModelFileHeaderDTO headerdto = ModelFileService.GetCurrentModelHeader(GLWell.Id.ToString());
                headerdto.Options.OptionalUpdate = new long[] { 1, 2, 4 };
                ModelFileService.SaveModelFileOptions(headerdto.Options);
                #endregion model file with Choke D Factor Option

                #region Validating tuning and Choke D Factor Calulation
                //Getting Welll Test Data - For Choke D Factor Calculations
                WellTestAndUnitsDTO WellTestForChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(GLWell.Id.ToString());
                Assert.AreEqual("TUNING_NOT_COMPLETE", WellTestForChokeDFactor_US.Value.Status.ToString(), "Mismatch in expected result");

                WellTestDataService.TuneSelectedWellTests(new long[] { WellTestForChokeDFactor_US.Value.Id });
                WellTestAndUnitsDTO WellTestWithChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(GLWell.Id.ToString());

                Assert.IsNotNull(WellTestWithChokeDFactor_US.Value.ChokeDFactor);
                Assert.AreEqual(0.07, (double)WellTestWithChokeDFactor_US.Value.ChokeDFactor, 0.01, "Mismatch Choke D Factor Calculation");
                #endregion Validating tuning and Choke D Factor Calulation

                #region validation with Metric Conversion 
                //Getting Welll Test Data in Metric System
                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                Trace.WriteLine("System set for Metric unit system");

                WellTestAndUnitsDTO WellTestWithChokeDFactor_Metric = WellTestDataService.GetLatestValidWellTestByWellId(GLWell.Id.ToString());
                Assert.IsNotNull(WellTestWithChokeDFactor_Metric.Value.ChokeDFactor);
                Assert.AreEqual(0.07, (double)WellTestWithChokeDFactor_Metric.Value.ChokeDFactor, 0.01, "Mismatch Choke D Factor Calculation");
                #endregion validation with Metric Conversion
            }
            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                _wellsToRemove.Add(GLWell);
            }
        }

        /// Description : FRWM-732 - Add Calculate Choke D Factor in Optional Updates
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PCPWellChokeDFactorOptionalUpdate()
        {
            WellDTO PCPWell = new WellDTO();
            try
            {
                // Set system to US units
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");

                #region PCP Well Creation
                WellConfigurationService.AddWellConfig(new WellConfigDTO()
                {
                    Well = SetDefaultFluidTypeAndPhase(new WellDTO()
                    {
                        Name = "PCPWELL_00001",
                        CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)),
                        WellType = WellTypeId.PCP,
                        FluidPhase = WellFluidPhase.MultiPhase,
                        AssemblyAPI = "PCPWELL_00001",
                        SubAssemblyAPI = "PCPWELL_00001",
                        IntervalAPI = "PCPWELL_00001",
                        DepthCorrectionFactor = 2,
                        WellDepthDatumElevation = 1,
                        WellDepthDatumId = 2
                    })
                });
                PCPWell = WellService.GetWellByName("PCPWELL_00001");
                Assert.IsNotNull(PCPWell);
                #endregion PCP Well Creation

                #region model file without Choke D Factor Option
                //Attaching PCPWell Well Model
                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                byte[] fileAsByteArray;
                ModelFileValidationDataDTO ModelFileValidationData;
                AssemblyDTO assembly = WellboreComponentService.GetAssemblyByWellId(PCPWell.Id.ToString());
                ModelFileOptionDTO options = new ModelFileOptionDTO();
                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };
                modelFile.ApplicableDate = PCPWell.CommissionDate.Value.AddDays(1).ToUniversalTime();
                modelFile.WellId = PCPWell.Id;

                fileAsByteArray = GetByteArray(Path, "PCP-Multiphase.wflx");
                options.CalibrationMethod = CalibrationMethodId.LFactor;
                options.Comment = "PCPWell";
                options.OptionalUpdate = new long[]
                { ((long)OptionalUpdates.UpdateWCT_WGR),
                   ((long)OptionalUpdates.UpdateGOR_CGR),
                   // ((long)OptionalUpdates.CalculateChokeD_Factor)  //Uploading without Choke Factor
                };
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                modelFile.Options = options;
                ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                if (ModelFileValidationData != null)
                    ModelFileService.AddWellModelFile(modelFile);
                else
                    Trace.WriteLine(string.Format("Failed to validate PCPWell model file"));
                #endregion model file without Choke D Factor Option

                #region Entering Well Test Data
                // Inserting Well Test Data
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = PCPWell.Id,
                    SPTCodeDescription = "AllocatableTest",
                    TestDuration = 24,
                    Oil = 190,
                    Water = 141.2m,
                    Gas = 10.40m,
                    AverageTubingPressure = 355,
                    AverageTubingTemperature = 80,
                    GaugePressure = 423,
                    AverageCasingPressure = 45.23m,
                    PumpIntakePressure = 161.19m,
                    PumpDischargePressure = 2130.69m,
                    PolishedRodTorque = 361.35m,
                    PumpTorque = 185.23m,
                    PumpSpeed = 225,
                    FlowLinePressure = 340,
                    FlowLineTemperature = 67.5m,
                    SeparatorPressure = 1523,
                    ChokeSize = 510,
                    MotorCurrent = 180,
                    MotorVolts = 230,
                    Comment = "Choke D Factor Calulations",

                };
                testDataDTO.SampleDate = PCPWell.CommissionDate.Value.AddDays(2).ToUniversalTime();
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(PCPWell.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                #endregion Entering Well Test Data

                //Getting Welll Test Data - Choke D Factor should be null
                WellTestAndUnitsDTO WellTestWithOutChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(PCPWell.Id.ToString());
                Assert.IsNull(WellTestWithOutChokeDFactor_US.Value.ChokeDFactor);

                #region model file with Choke D Factor Option
                //Updating Model File With Choke D Factor
                ModelFileHeaderDTO headerdto = ModelFileService.GetCurrentModelHeader(PCPWell.Id.ToString());
                headerdto.Options.OptionalUpdate = new long[] { 1, 2, 4 };
                ModelFileService.SaveModelFileOptions(headerdto.Options);
                #endregion model file with Choke D Factor Option

                #region Validating tuning and Choke D Factor Calulation
                //Getting Welll Test Data - For Choke D Factor Calculations
                WellTestAndUnitsDTO WellTestForChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(PCPWell.Id.ToString());
                Assert.AreEqual("TUNING_NOT_COMPLETE", WellTestForChokeDFactor_US.Value.Status.ToString(), "Mismatch in expected result");

                WellTestDataService.TuneSelectedWellTests(new long[] { WellTestForChokeDFactor_US.Value.Id });
                WellTestAndUnitsDTO WellTestWithChokeDFactor_US = WellTestDataService.GetLatestValidWellTestByWellId(PCPWell.Id.ToString());

                Assert.IsNotNull(WellTestWithChokeDFactor_US.Value.ChokeDFactor);
                Assert.AreEqual(0.06, (double)WellTestWithChokeDFactor_US.Value.ChokeDFactor, 0.01, "Mismatch Choke D Factor Calculation");
                #endregion Validating tuning and Choke D Factor Calulation

                #region validation with Metric Conversion 
                //Getting Welll Test Data in Metric System
                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");
                Trace.WriteLine("System set for Metric unit system");

                WellTestAndUnitsDTO WellTestWithChokeDFactor_Metric = WellTestDataService.GetLatestValidWellTestByWellId(PCPWell.Id.ToString());
                Assert.IsNotNull(WellTestWithChokeDFactor_Metric.Value.ChokeDFactor);
                Assert.AreEqual(0.06, (double)WellTestWithChokeDFactor_Metric.Value.ChokeDFactor, 0.01, "Mismatch Choke D Factor Calculation");
                #endregion validation with Metric Conversion
            }
            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                _wellsToRemove.Add(PCPWell);
            }
        }

        //// <summary>
        /// Description : Enable Well Analysis for Injection wells - FRWM-6368
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GASInjectionWellAnalysis()
        {
            string facilityId = GetFacilityId("GASINJWELL_", 1);
            try
            {
                // Set system to US units
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");

                #region Adding Well with Well Test
                //Adding Well along with WellTest Data
                WellDTO gasInjectionWell = AddNonRRLWell(facilityId, WellTypeId.GInj, false, CalibrationMethodId.LFactor);
                #endregion Adding Well with Well Test

                #region Running NodelAnalysis and selecting latest well test record
                // Get it back out and use it to load the analysis inputs (?)
                WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(gasInjectionWell.Id.ToString());
                NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());


                Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
                Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.TestData, "Test data is not available in the analysis input");

                Assert.IsNotNull(analysisInput.ModelData.FlowCorrelation, "Flow Correlation is not available in the model data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
                Assert.IsNotNull(analysisInput.TestData.Value.WellHeadPressure, "Tubing head pressure is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.WellHeadTemperature, "Tubing head temperature is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.DownholeGaugePressure, "Downhole pressure gauge is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.GasRate, "Gas rate is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.PartingPressure, "Parting Pressure is not available in test data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.DarcyFlowCoeff, "Darcy Flow Coefficient is not defined in the calibration data");

                Assert.IsNotNull(analysisInput.ModelData.SolutionNode, "Solution node is not available in the model data");
                Assert.IsNotNull(analysisInput.ModelData.StartNode, "Start node is not available in the modal data");
                Assert.AreNotEqual(analysisInput.ModelData.SolutionNode.Value.Name, analysisInput.ModelData.StartNode.Value.Name, "Start and solution node cannot be the same");

                Assert.IsNotNull(analysisInput.TestData.Value.FlowingBottomholePressure, "Flowing bottom hole pressure is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.GasAoF, "Flow at parting pressure is not available in test data");


                Assert.AreEqual("DunsAndRosStd", analysisInput.ModelData.FlowCorrelation.ToString(), "Mismatch betwwen expected and actual Flow correlation");
                Assert.AreEqual((double)latestValidTestDataPair.Value.LFactor, analysisInput.CalibrationData.Value.LFactor, "Mismatch between the calulated LFactor in Well Test and the analysis ");
                Assert.AreEqual((double)latestValidTestDataPair.Value.AverageTubingPressure, analysisInput.TestData.Value.WellHeadPressure, "Mismatch between tubing head pressure in Well Test and in analysis");
                Assert.AreEqual((double)latestValidTestDataPair.Value.AverageTubingTemperature, analysisInput.TestData.Value.WellHeadTemperature, "Mismatch between tubing head temperature in Well Test and in analysis");

                Assert.AreEqual((double)latestValidTestDataPair.Value.GaugePressure, analysisInput.TestData.Value.DownholeGaugePressure, "Mismatch between gauge pressure in Well Test and the analysis ");
                Assert.AreEqual((double)latestValidTestDataPair.Value.Gas, analysisInput.TestData.Value.GasRate, "Mismatch between gas rate in Well Test and in analysis");
                // Assert.AreEqual(2014.70, Math.Round(analysisInput.TestData.Value.PartingPressure, 2 ,1m) , "Mismatch between tubing head temperature in Well Test and in analysis");
                Assert.AreEqual((double)latestValidTestDataPair.Value.ReservoirPressure, analysisInput.CalibrationData.Value.ReservoirPressure, "Mismatch between Reservoir Pressure in Well Test and the analysis ");
                Assert.AreEqual((double)latestValidTestDataPair.Value.DarcyFlowCoefficient, analysisInput.CalibrationData.Value.DarcyFlowCoeff, "Mismatch between Darcy Flow Coefficient in Well Test and the analysis ");
                Assert.AreEqual(2, analysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of solution nodes are available in analysis input modal data");
                Assert.AreEqual(2, analysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of start nodes are available in analysis input modal data");
                // Assert.AreEqual(371.1, analysisInput.TestData.Value.GasAoF, "Mismatch between expected and actual Flow at Parting Pressure in analysis");
                Assert.AreEqual((double)latestValidTestDataPair.Value.FlowingBottomholePressure, analysisInput.TestData.Value.FlowingBottomholePressure, "Mismatch between FBHP in well test and in analysis");
                #endregion Running NodelAnalysis and selecting latest well test record

                #region performing analysis
                // Run the Injection analysis
                AnalysisResultsAndUnitsDTO actual_analysisResult = WellTestDataService.PerformAnalysis(analysisInput);
                // string jsonstring1 = JsonConvert.SerializeObject(actual_analysisResult);
                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                string FileName = "GasInjection_Analysis_json_test_US.json";
                AnalysisResultsAndUnitsDTO expected_analysisResult = JsonConvert.DeserializeObject<AnalysisResultsAndUnitsDTO>(GetJsonString(Path + FileName));
                #endregion performing analysis

                #region validation for InFlow/OutFlow Curve
                //Comparing InFLow / OutFlow curve units and values
                CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.FlowCurves.Units, actual_analysisResult.OperatingPointResults.FlowCurves.Units, "Units not matching for InFlow / OutFlow Curve");

                for (int i = 0; i < actual_analysisResult.OperatingPointResults.FlowCurves.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.FlowCurves.Values[i], actual_analysisResult.OperatingPointResults.FlowCurves.Values[i], "Mismatch at element " + i, null, 0.5);
                }
                Assert.IsNotNull(actual_analysisResult.OperatingPointResults, "Unable to get inflow/outflow curves after GAS Injection Analysis");
                Assert.IsNotNull(actual_analysisResult.OperatingPointResults.FlowCurves, "Unable to get inflow/outflow curve points after GAS Injection Analysis");

                #endregion validation for InFlow/OutFlow Curve

                #region validation for Wellperformance Curve
                //Comparing WellPerformance curve units and values
                CompareObjectsUsingReflection(expected_analysisResult.WellPerformanceCurve.WellPerformanceCurve.Units, actual_analysisResult.WellPerformanceCurve.WellPerformanceCurve.Units, "Units not matching for WellPerformance Curve");

                for (int i = 0; i < actual_analysisResult.OperatingPointResults.FlowCurves.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expected_analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[i], actual_analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[i], "Mismatch at element " + i, null, 0.5);
                }
                Assert.IsNotNull(actual_analysisResult.WellPerformanceCurve, "Unable to get wellperformance curves after GAS Injection Analysis");
                Assert.IsNotNull(actual_analysisResult.WellPerformanceCurve.WellPerformanceCurve, "Unable to get wellperformance curve points after GAS Injection Analysis");
                #endregion validation for Wellperformance Curve

                #region validation for Gradient Curve
                //Comparing Gradient curve units and values
                CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Units, actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Units, "Units not matching for Gradient Curve");

                for (int i = 0; i < actual_analysisResult.OperatingPointResults.FlowCurves.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i], actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i], "Mismatch at element " + i, null, 0.5);
                }
                Assert.IsNotNull(actual_analysisResult.PressureDropResults.GradientCurves, "Unable to get gradient curves after GAS Injection Analysis");
                Assert.IsNotNull(actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves, "Unable to get gradient curve points after GAS Injection Analysis");
                #endregion validation for Gradient Curve

                #region validation for Wellbore Profile Curve
                //Comparing Wellbore profile curve units and values
                CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GasVelocityCurves.GasVelocityCurves.Units, actual_analysisResult.PressureDropResults.GasVelocityCurves.GasVelocityCurves.Units, "Units not matching for Wellbore profile");

                for (int i = 0; i < actual_analysisResult.OperatingPointResults.FlowCurves.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GasVelocityCurves.GasVelocityCurves.Values[i], actual_analysisResult.PressureDropResults.GasVelocityCurves.GasVelocityCurves.Values[i], "Mismatch at element " + i, null, 0.5);
                }
                Assert.IsNotNull(actual_analysisResult.PressureDropResults.GasVelocityCurves, "Unable to get wellbore profile curves after GAS Injection Analysis");
                Assert.IsNotNull(actual_analysisResult.PressureDropResults.GasVelocityCurves.GasVelocityCurves, "Unable to get wellbore profile curve points after GAS Injection Analysis");
                #endregion validation for Wellbore Profile Curve
            }

            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                RemoveWell(facilityId);
            }
        }


        /// <summary>
        /// Description     : Add the Well test,Well Daily Average data and run the analysis for PCP Well.
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PCPWellAnalysis_Tests()
        {
            // This is the path to the  PCP example well model in the codebase.
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("PCP-Multiphase.wflx", WellTypeId.PCP,
                new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.PIAndLFactor,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.TuneRateFactor,
                        (long) OptionalUpdates.TuneFrictionFactor,
                        (long) OptionalUpdates.TuneTorqueFactor,
                    },
                    PumpPressure = PIPandPDPOption.Has_PumpIntakePressure,
                });


            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidTypeAndPhase(new WellDTO() { Name = "PCPTestWell3" + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = WellTypeId.PCP }) });
            WellDTO newWell = WellService.GetWellByName("PCPTestWell3" + wellType.ToString());
            Assert.IsNotNull(newWell);
            _wellsToRemove.Add(newWell);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO();

            options.Comment = "Testing 1 - 2 - 3 ..." + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = newWell.Id;

            byte[] fileAsByteArray = GetByteArray(path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File is not an PCP model file.");
            ModelFileValidationDataDTO modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(modelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            /// Add VSD frequenices to PCP Well

            SettingDTO setting = SettingService.GetSettingByName(SettingServiceStringConstants.WELL_FREQUENCY);


            WellSettingDTO wellsettingdto = new WellSettingDTO
            {
                SettingId = setting.Id,
                WellId = newWell.Id,
                Setting = new SettingDTO { SettingCategory = SettingCategory.PerformanceCurve, SettingType = SettingType.Well, Key = "Well Frequencies", Name = "Well Frequencies", Description = "Well Frequencies", SettingValueType = SettingValueType.DecimalNumberArray },
                NumericArrayValue = new double[] { 50.0, 55.0, 60.0, 65.0 }
            };
            SettingService.SaveWellSetting(wellsettingdto);

            // NOTE: If you change anything in the following well test, it is very likely that this integration test will fail
            //       because the comparisons we do after the analysis assume that this well test was used for the analysis.

            WellTestDTO testDTO = new WellTestDTO
            {
                WellId = newWell.Id,
                TestDuration = 12,
                SPTCodeDescription = "Allocatable Test",
                TuningStatus = "Needs Tuning",
                AverageTubingPressure = 100,
                AverageTubingTemperature = 107,
                AverageCasingPressure = 186,
                PumpIntakePressure = 189,
                PumpDischargePressure = 1800,
                PolishedRodTorque = (decimal)494.16,
                PumpTorque = 360,
                PumpSpeed = 300,
                MotorVolts = 230,
                MotorCurrent = 145,
                FlowLinePressure = 452,
                SeparatorPressure = 84,
                GOR = 1000,
                Oil = 343,
                Gas = 34,
                ChokeSize = 32,
                Water = 85,
                SampleDate = DateTime.Today.ToUniversalTime()
            };

            // Add the well test record to the database.
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(newWell.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDTO));

            //for tunning
            WellTestDTO latestTestData_PCP = WellTestDataService.GetLatestWellTestDataByWellId(newWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_PCP.Id });

            AddWellSettingWithDoubleValues(newWell.Id, "Min Friction Factor Acceptance Limit", 0.30);
            AddWellSettingWithDoubleValues(newWell.Id, "Min Torque Factor Acceptance Limit", 0.80);
            AddWellSettingWithDoubleValues(newWell.Id, "Max L Factor Acceptance Limit", 2.0);


            latestTestData_PCP = WellTestDataService.GetLatestWellTestDataByWellId(newWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_PCP.Id });

            WellTestDTO latestTestDataAfterTune_PCP = WellTestDataService.GetLatestWellTestDataByWellId(newWell.Id.ToString());
            Assert.AreEqual("TUNING_SUCCEEDED", latestTestDataAfterTune_PCP.Status.ToString(), "Well Test Status is not Success");


            // Get it back out and use it to load the analysis inputs (?)
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(newWell.Id.ToString());
            var dailyAverage = new WellDailyAverageValueDTO()
            {
                OilRateInferred = (double?)latestValidTestDataPair.Value.Oil,
                WaterRateInferred = (double?)latestValidTestDataPair.Value.Water,
                GasRateInferred = (double?)latestValidTestDataPair.Value.Gas,
                Status = WellDailyAverageDataStatus.Calculated,
                ChokeDiameter = (double?)latestValidTestDataPair.Value.ChokeSize,
                CHP = (double)(latestValidTestDataPair.Value.AverageCasingPressure ?? 0),
                DHPG = (double?)latestValidTestDataPair.Value.GaugePressure,
                Duration = null,
                EndDateTime = latestValidTestDataPair.Value.SampleDate.AddDays(1),
                StartDateTime = latestValidTestDataPair.Value.SampleDate,
                WellId = newWell.Id,
                WellTestId = latestValidTestDataPair.Value.Id,
            };
            bool result = SurveillanceService.AddUpdateWellDailyAverageData(dailyAverage);
            Assert.IsTrue(result, "Adding daily average record failed.");
            var dailyAverageRecord = SurveillanceService.GetDailyAverages(newWell.Id.ToString(), (DateTime.Today - TimeSpan.FromDays(30)).ToUniversalTime().ToISO8601(), (DateTime.Today + TimeSpan.FromDays(1)).ToUniversalTime().ToISO8601()).Values.FirstOrDefault();
            Assert.IsNotNull(dailyAverageRecord);
            var record_id = dailyAverageRecord.Id;
            NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available in the analysis input");
            //validating AOF and Chokesize
            Assert.IsNotNull(analysisInput.TestData.Value.ChokeSize, "ChokeSize is not available in the analysis input");
            Assert.IsNotNull(analysisInput.TestData.Value.LiquidAoF, "LiquidAoF is not available in the analysis input");
            Assert.IsNull(analysisInput.TestData.Value.GasAoF, "GasAOF is available in the analysis input");

            Assert.IsNotNull(analysisInput.ModelData.SolutionNode, "Solution node is not available in the model data");
            Assert.IsNotNull(analysisInput.ModelData.StartNode, "Start node is not available in the modal data");
            Assert.AreNotEqual(analysisInput.ModelData.SolutionNode.Value.Name, analysisInput.ModelData.StartNode.Value.Name, "Start and solution node cannot be the same");
            Assert.AreEqual(3, analysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of solution nodes are available in analysis input modal data");
            Assert.AreEqual(3, analysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of start nodes are available in analysis input modal data");

            Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ProductivityIndex, "Productivity index is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageCasingPressure ?? 0, 3), (decimal)Math.Round(analysisInput.TestData.Value.CasingHeadPressure, 3), "Mismatch between the provided average casing pressure value and the analysis input test value");
            Assert.AreEqual((latestValidTestDataPair.Value.GaugePressure.HasValue ? Math.Round(latestValidTestDataPair.Value.GaugePressure.Value, 3) : 0m), (decimal)Math.Round(analysisInput.TestData.Value.DownholeGaugePressure, 3), "Mismatch between the provided gauge pressure value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.GOR.Value, 3), analysisInput.TestData.Value.GasOilRatio.HasValue ? (decimal)Math.Round(analysisInput.TestData.Value.GasOilRatio.Value, 3) : 0m, "Mismatch between the provided GOR value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.Gas.Value, 3), (decimal)Math.Round(analysisInput.TestData.Value.GasRate, 3), "Mismatch between the provided gas value and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)Math.Round(analysisInput.TestData.Value.OilRate), "Mismatch between the provided oil and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Id, analysisInput.TestData.Value.Id, "Mismatch between the provided ID and analysis input test ID");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.WaterCut.Value), (decimal)Math.Round(analysisInput.TestData.Value.WaterCut), "Mismatch between the provided water cut value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingPressure.Value), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadPressure), "Mismatch between the provided average tubing pressure value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingTemperature ?? 0.0m), (decimal)Math.Round(analysisInput.TestData.Value.WellHeadTemperature), "Mismatch between the provided average tubing temperature value and analysis input test value");

            // Run the PCP analysis
            PCPAnalysisResultsAndUnitsDTO actual_analysisResult = WellTestDataService.PerformPCPAnalysis(analysisInput);
            // string jsonstring1 = JsonConvert.SerializeObject(actual_analysisResult);
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            string FileName = "PCP_Anaylsys_json_test_US.json";

            PCPAnalysisResultsAndUnitsDTO expected_analysisResult = JsonConvert.DeserializeObject<PCPAnalysisResultsAndUnitsDTO>(GetJsonString(Path + FileName));

            CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedFlowRateCurve.Units, actual_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedFlowRateCurve.Units, "Units not matching for Adjusted Flow Rate Curve");

            for (int i = 0; i < actual_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedFlowRateCurve.Values.Count(); i++)

            {
                CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedFlowRateCurve.Values[i], actual_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedFlowRateCurve.Values[i], "Mismatch at element " + i, null, 0.5);
            }


            CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedTorqueCurve.Units, actual_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedTorqueCurve.Units, "Units not matching for Adjusted Torque Curve");

            for (int i = 0; i < actual_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedTorqueCurve.Values.Count(); i++)

            {
                CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedTorqueCurve.Values[i], actual_analysisResult.PressureDropResults.PumpPerformanceCurves.AdjustedTorqueCurve.Values[i], "Mismatch at element " + i, null, 0.5);
            }

            CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.PumpPerformanceCurves.OperatingPoints.Units, actual_analysisResult.PressureDropResults.PumpPerformanceCurves.OperatingPoints.Units, "Units not matching for Operating Points");

            for (int i = 0; i < actual_analysisResult.PressureDropResults.PumpPerformanceCurves.OperatingPoints.Values.Count(); i++)

            {
                CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.PumpPerformanceCurves.OperatingPoints.Values[i], actual_analysisResult.PressureDropResults.PumpPerformanceCurves.OperatingPoints.Values[i], "Mismatch at element " + i, null, 0.5);
            }


            CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.PumpPerformanceCurves.PumpCurve.Units, actual_analysisResult.PressureDropResults.PumpPerformanceCurves.PumpCurve.Units, "Units not matching for Pump Curve ");

            for (int i = 0; i < actual_analysisResult.PressureDropResults.PumpPerformanceCurves.PumpCurve.Values.Count(); i++)

            {
                CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.PumpPerformanceCurves.PumpCurve.Values[i], actual_analysisResult.PressureDropResults.PumpPerformanceCurves.PumpCurve.Values[i], "Mismatch at element " + i, null, 0.5);
            }


            Assert.IsNotNull(actual_analysisResult);
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults, "Unable to get Operating point results after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.FlowCurves, "Unable to get Flow curves after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.OperatingPoint, "Unable to get Operating point after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.OperatingPoint.Value.GasRate);
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.OperatingPoint.Value.OilRate);
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.OperatingPoint.Value.WaterRate);
            Assert.IsNotNull(actual_analysisResult.PressureDropResults, "Unable to get Pressure drop results after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.PressureDropResults.SolutionPoint, "Unable to get Solution point results after PCP Analysis");
            Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.Oil), actual_analysisResult.PressureDropResults.SolutionPoint.Value.OilRate, 0.5);
            Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.GOR), Math.Round(actual_analysisResult.PressureDropResults.SolutionPoint.Value.ProducedGOR), 0.5);
            Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.WaterCut), actual_analysisResult.PressureDropResults.SolutionPoint.Value.WaterCut, 0.05);
            Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.Water), actual_analysisResult.PressureDropResults.SolutionPoint.Value.WaterRate, 0.5);

            Assert.IsNotNull(actual_analysisResult.PressureDropResults.GradientCurves, "Unable to get gradient curves after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves, "Unable to get gradient curve points after PCP Analysis");
            Assert.AreEqual(Convert.ToDouble(analysisInput.ModelData.SolutionNode.Value.MD), Math.Round(actual_analysisResult.PressureDropResults.GradientCurves.MaximumMD), 0.5);

            Assert.IsNotNull(actual_analysisResult.WellPerformanceCurves, "Unable to get WellPerformanceCurve after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.WellPerformanceCurves.WellPerformanceCurves, "Unable to get WellPerformanceCurve after PCP Analysis");

            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            // -------------- Get well analysis data in US units --------------
            Assert.AreEqual("STB/d", analysisInput.TestData.Units.LiquidAoF.UnitKey, "Incorrect US units for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.Precision);

            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            NodalAnalysisInputAndUnitsDTO analysisInput_metric = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());
            Assert.AreEqual("sm3/d", analysisInput_metric.TestData.Units.LiquidAoF.UnitKey, "Incorrect metric units for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(3, (int)analysisInput_metric.TestData.Units.LiquidAoF.Precision, "Incorrect metric units precision for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.Precision);

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
        }
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateWellTestNewParameter_ESP()
        {
            AddWell("ESP_");
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName));

            //Adding WellTest
            WellTestDTO testDataDTO = new WellTestDTO()
            {
                WellId = well.Id,
                SPTCodeDescription = "Allocatable Test",
                SampleDate = well.CommissionDate.Value.AddDays(5).ToUniversalTime(),
                TestDuration = 24,
                AverageTubingPressure = 200,
                AverageTubingTemperature = 100,
                PumpIntakePressure = 1412.25m,
                PumpDischargePressure = 3067.59m,
                GaugePressure = 2900,
                Oil = 2397.5m,
                Gas = 3596.2m,
                Water = 8000,
                ChokeSize = 50,
                FlowLinePressure = 50,
                FlowLineTemperature = 100,
                SeparatorPressure = 10000,
                Frequency = 20,
            };
            //Saved WellTest Data
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
            Assert.AreEqual(1, WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.Length, "Well Test is not saved successfully");
            Trace.WriteLine("Well test saved successfully");

            //Get Well Test Data
            WellTestArrayAndUnitsDTO getWellTestData = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());

            Assert.AreEqual(well.CommissionDate.Value.AddDays(5).ToUniversalTime(), getWellTestData.Values.FirstOrDefault().SampleDate, "Entered Date is Mismatched");
            Assert.AreEqual(24, getWellTestData.Values.FirstOrDefault().TestDuration.Value, "Entered Duration is Mismatched");
            Assert.AreEqual("AllocatableTest", getWellTestData.Values.FirstOrDefault().SPTCodeDescription, "Entered Quality Code is Mismatched");
            Assert.AreEqual(100, getWellTestData.Values.FirstOrDefault().FlowLineTemperature, "flowline temperature is Mismatched");

            Trace.WriteLine("Get well test successfully");
        }


        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateWellTestNewParameter_WaterInj()
        {
            AddWell("WATERINJWELL_");
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName));
            {
                //add new wellTestData
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = well.Id,
                    SPTCodeDescription = "RepresentativeTest",
                    AverageTubingPressure = 50008888, //Incorect Value
                    AverageTubingTemperature = 65,
                    PumpIntakePressure = 10000,
                    PumpDischargePressure = 11000,
                    GaugePressure = 12000,
                    Water = 8000,
                    ChokeSize = 50,
                    FlowLinePressure = 50,
                    FlowLineTemperature = 100
                };

                testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                // add wellTest with new non RRL properties
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                //WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                List<WellTestDTO> data = new List<WellTestDTO>();
                data.Add(testDataDTO);
                WellTestDTO[] arrComponent = data.ToArray();
                bool addWelltest = WellTestDataService.ImportWellTests(arrComponent);
                WellTestDTO testDataDTOCheck = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.FirstOrDefault();
                Assert.IsNull(testDataDTOCheck);
            }
        }
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateWellTestNewParameter_GasLift()
        {

            AddWell("GLWELL_");
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName));
            {
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = well.Id,

                    SPTCodeDescription = "RepresentativeTest",
                    AverageTubingPressure = 5000,
                    AverageTubingTemperature = 658888, //Incorect Value
                    AverageCasingPressure = 1000,
                    GasInjectionRate = 1000,
                    FlowLinePressure = 50,
                    FlowLineTemperature = 100,
                    SeparatorPressure = 30,
                    GaugePressure = 12000,
                    Oil = (decimal)1497.8,
                    Gas = 500,
                    Water = (decimal)2246.6,
                    ChokeSize = 50,
                };

                testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                // add wellTest with new non RRL properties
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                Assert.AreEqual(1, WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.Length, "Well Test is not saved successfully");
                Trace.WriteLine("Well test saved successfully");

                //Get Well Test Data
                WellTestArrayAndUnitsDTO getWellTestData = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                Assert.AreEqual(100, getWellTestData.Values.FirstOrDefault().FlowLineTemperature, "flowline temperature is Mismatched");

                Trace.WriteLine("Get well test successfully");

            }
        }
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateWellTestNewParameter_NF()
        {

            AddWell("NFWWELL_");
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName));
            {
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = well.Id,
                    SampleDate = well.CommissionDate.Value.AddDays(5).ToUniversalTime(),
                    SPTCodeDescription = "RepresentativeTest",
                    AverageTubingPressure = 5000,
                    AverageTubingTemperature = 65,
                    GaugePressure = 12000,
                    Oil = 5000,
                    Gas = 5008888, //Incorect Value
                    Water = 8000,
                    ChokeSize = 50,
                    FlowLinePressure = 50,
                    FlowLineTemperature = 100,
                    SeparatorPressure = 10000,
                };

                // add wellTest with new non RRL properties
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                Assert.AreEqual(1, WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.Length, "Well Test is not saved successfully");
                Trace.WriteLine("Well test saved successfully");

                //Get Well Test Data
                WellTestArrayAndUnitsDTO getWellTestData = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                Assert.AreEqual(100, getWellTestData.Values.FirstOrDefault().FlowLineTemperature, "flowline temperature is Mismatched");

                Trace.WriteLine("Get well test successfully");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void UpdateWellTestNewParameter_RPOC()
        {

            AddWell("RPOC_");
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName));
            {
                WellTestDTO testDataDTO = new WellTestDTO()
                {
                    WellId = well.Id,
                    SampleDate = well.CommissionDate.Value.AddDays(5).ToUniversalTime(),
                    SPTCodeDescription = "RepresentativeTest",
                    AverageTubingPressure = 5000,
                    AverageTubingTemperature = 65,
                    GaugePressure = 12000,
                    Oil = 5000,
                    Gas = 5008888, //Incorect Value
                    Water = 8000,
                    ChokeSize = 50,
                    FlowLinePressure = 50,
                    FlowLineTemperature = 100,
                    SeparatorPressure = 10000,
                };

                // add wellTest with new non RRL properties
                WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                Assert.AreEqual(1, WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values.Length, "Well Test is not saved successfully");
                Trace.WriteLine("Well test saved successfully");

                //Get Well Test Data
                WellTestArrayAndUnitsDTO getWellTestData = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString());
                Assert.AreEqual(100, getWellTestData.Values.FirstOrDefault().FlowLineTemperature, "flowline temperature is Mismatched");

                Trace.WriteLine("Get well test successfully");
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GroupWellTest_ByDate()
        {
            try
            {
                //Add RRL well and a well test
                CreateWellandWellTest(WellTypeId.RRL);

                //Add GL well and a well test
                CreateWellandWellTest(WellTypeId.GLift);

                //Add ESP well and a well test
                CreateWellandWellTest(WellTypeId.ESP);

                //Add NF well and a well test
                CreateWellandWellTest(WellTypeId.NF);

                //Add GI well and a well test
                CreateWellandWellTest(WellTypeId.GInj);

                //Add PCP well and a well test
                CreateWellandWellTest(WellTypeId.PCP);

                //Add WINJ well and a well test
                CreateWellandWellTest(WellTypeId.WInj);

                //Add Other well and a well test
                CreateWellandWellTest(WellTypeId.OT);

                //Group well test
                GroupWellTestInputDTO groupwelltestDTO = new GroupWellTestInputDTO
                {
                    StartDate = DateTime.Today.AddDays(-30).ToUniversalTime(),
                    EndDate = DateTime.Today.AddDays(5).ToUniversalTime(),
                    UserSelectionType = GroupWellTestUserSelectionTypes.All
                };

                WellTestArrayAndUnitsDTO unitsDTO = WellTestDataService.GetGroupWellTest(groupwelltestDTO);
                int welltests_total = unitsDTO.Values.Count();
                Assert.AreEqual(8, welltests_total, "Total number of well tests values mismatch");

                //negative test - out of range dates
                groupwelltestDTO.StartDate = DateTime.Today.AddDays(1).ToUniversalTime();
                unitsDTO = WellTestDataService.GetGroupWellTest(groupwelltestDTO);
                welltests_total = unitsDTO.Values.Count();
                Assert.AreEqual(0, welltests_total, "No well tests should be present in the grid");
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void NFWWellAnalysisTest_DryGas()
        {
            var modelFileName = "Dry Gas - IPR Auto Tuning.wflx";
            WellTypeId wellType = WellTypeId.NF;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("NFWWELL_", wellType, WellFluidType.DryGas, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 1820,
                Water = 610,
                ChokeSize = 32,
                FlowLinePressure = 600,
                SeparatorPressure = 600,
                TestDuration = 12,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };

            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testData));

            WellTestAndUnitsDTO validWellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(validWellTest, "Added WellTest is not valid");
            Assert.AreEqual(0, validWellTest.Value.Oil, "Actual Oil Rate should be 0 for Dry Gas Fluid Type");
            Assert.AreEqual(testData.CalibrationMethod, validWellTest.Value.CalibrationMethod, "Mismatch found in Calibration Method");
            Assert.AreEqual(testData.AverageTubingPressure, validWellTest.Value.AverageTubingPressure, "Mismatch found in AverageTubingPressure");
            Assert.AreEqual(testData.AverageTubingTemperature, validWellTest.Value.AverageTubingTemperature, "Mismatch found in AverageTubingTemperature");
            Assert.AreEqual(testData.Gas, validWellTest.Value.Gas, "Mismatch found in Gas");
            Assert.AreEqual(testData.Water, validWellTest.Value.Water, "Mismatch found in Water");
            Assert.AreEqual(testData.ChokeSize, validWellTest.Value.ChokeSize, "Mismatch found in ChokeSize");
            Assert.AreEqual(testData.FlowLinePressure, validWellTest.Value.FlowLinePressure, "Mismatch found in FlowLinePressure");
            Assert.AreEqual(testData.SeparatorPressure, validWellTest.Value.SeparatorPressure, "Mismatch found in SeparatorPressure");
            Assert.AreEqual(testData.TestDuration, validWellTest.Value.TestDuration, "Mismatch found in TestDuration");

            var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get Analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.TestData.Value.ChokeSize, "ChokeSize is not defined in the TestData");
            Assert.IsNull(analysisInput.TestData.Value.LiquidAoF, "LiquidAoF is defined in the TestData");
            Assert.IsNotNull(analysisInput.TestData.Value.GasAoF, "GasAoF is not available for dry gas type well");


            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            // -------------- Get well analysis data in US units --------------
            Assert.AreEqual("STB/d", analysisInput.TestData.Units.LiquidAoF.UnitKey, "Incorrect US units for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.Precision);

            Assert.AreEqual("1/64in", analysisInput.TestData.Units.ChokeSize.UnitKey, "Incorrect US units for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.Precision);

            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            NodalAnalysisInputAndUnitsDTO analysisInput_metric = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());

            Assert.AreEqual("mm", analysisInput_metric.TestData.Units.ChokeSize.UnitKey, "Incorrect metric units for Chokesize:" + analysisInput_metric.TestData.Units.ChokeSize.UnitKey);

            Assert.AreEqual("sm3/d", analysisInput_metric.TestData.Units.LiquidAoF.UnitKey, "Incorrect metric units for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(3, (int)analysisInput_metric.TestData.Units.LiquidAoF.Precision, "Incorrect metric units precision for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.Precision);

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void NFWWellAnalysisTest_Condensate()
        {
            var modelFileName = "Condensate Gas - IPR Auto Tuning.wflx";
            var wellType = WellTypeId.NF;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("NFWWELL_", wellType, WellFluidType.Condensate, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 4000,
                AverageTubingTemperature = 100,
                Gas = 35520,
                Water = 5327.6m,
                Oil = 5327.6m,
                ChokeSize = 32,
                FlowLinePressure = 4000,
                SeparatorPressure = 4000,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };

            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testData));

            WellTestAndUnitsDTO validWellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(validWellTest, "Added WellTest is not valid");
            Assert.AreEqual(testData.Oil, validWellTest.Value.Oil, "Actual Oil Rate should be 0 for Dry Gas Fluid Type");
            Assert.AreEqual(testData.CalibrationMethod, validWellTest.Value.CalibrationMethod, "Mismatch found in Calibration Method");
            Assert.AreEqual(testData.AverageTubingPressure, validWellTest.Value.AverageTubingPressure, "Mismatch found in AverageTubingPressure");
            Assert.AreEqual(testData.AverageTubingTemperature, validWellTest.Value.AverageTubingTemperature, "Mismatch found in AverageTubingTemperature");
            Assert.AreEqual(testData.Gas, validWellTest.Value.Gas, "Mismatch found in Gas");
            Assert.AreEqual(testData.Water, validWellTest.Value.Water, "Mismatch found in Water");
            Assert.AreEqual(testData.ChokeSize, validWellTest.Value.ChokeSize, "Mismatch found in ChokeSize");
            Assert.AreEqual(testData.FlowLinePressure, validWellTest.Value.FlowLinePressure, "Mismatch found in FlowLinePressure");
            Assert.AreEqual(testData.SeparatorPressure, validWellTest.Value.SeparatorPressure, "Mismatch found in SeparatorPressure");
            Assert.AreEqual(testData.TestDuration, validWellTest.Value.TestDuration, "Mismatch found in TestDuration");


            var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get Analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.TestData.Value.ChokeSize, "ChokeSize is not defined in the TestData");
            Assert.IsNull(analysisInput.TestData.Value.LiquidAoF, "LiquidAoF is defined in the TestData");
            Assert.IsNotNull(analysisInput.TestData.Value.GasAoF, "GasAoF is not available for dry gas type well");


            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            // -------------- Get well analysis data in US units --------------
            Assert.AreEqual("STB/d", analysisInput.TestData.Units.LiquidAoF.UnitKey, "Incorrect US units for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.Precision);

            Assert.AreEqual("1/64in", analysisInput.TestData.Units.ChokeSize.UnitKey, "Incorrect US units for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.ChokeSize.Precision, "Incorrect US units precision for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.Precision);

            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            NodalAnalysisInputAndUnitsDTO analysisInput_metric = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());

            Assert.AreEqual("mm", analysisInput_metric.TestData.Units.ChokeSize.UnitKey, "Incorrect metric units for Chokesize:" + analysisInput_metric.TestData.Units.ChokeSize.UnitKey);

            Assert.AreEqual("sm3/d", analysisInput_metric.TestData.Units.LiquidAoF.UnitKey, "Incorrect metric units for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(3, (int)analysisInput_metric.TestData.Units.LiquidAoF.Precision, "Incorrect metric units precision for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.Precision);

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
        }

        [TestCategory(TestCategories.WellConfigurationServiceTests), TestMethod]
        public void PLWellAOFCheck_DryGas()
        {
            var modelFileName = "PL-631.wflx";
            WellTypeId wellType = WellTypeId.PLift;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("PGLWELL_", wellType, WellFluidType.DryGas, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                MaximumCasingPressure = 210,
                MinimumCasingPressure = 210,
                MaximumTubingPressure = 160,
                MinimumTubingPressure = 160,
                FlowLinePressure = 160,
                FlowLineTemperature = 400,
                BuildTime = 11,
                AfterFlowTime = 38,
                FallTime = 30,
                RiseTime = 75,
                CycleGasVolume = 10,
                CycleWaterVolume = 1,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testData));

            WellTestAndUnitsDTO validWellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(validWellTest, "Added WellTest is not valid");
            Assert.AreEqual(testData.Oil, validWellTest.Value.Oil, "Actual Oil Rate should be 0 for Dry Gas Fluid Type");
            Assert.AreEqual(testData.CalibrationMethod, validWellTest.Value.CalibrationMethod, "Mismatch found in Calibration Method");
            Assert.AreEqual(testData.AverageTubingPressure, validWellTest.Value.AverageTubingPressure, "Mismatch found in AverageTubingPressure");
            Assert.AreEqual(testData.AverageTubingTemperature, validWellTest.Value.AverageTubingTemperature, "Mismatch found in AverageTubingTemperature");
            Assert.AreEqual(testData.Gas, validWellTest.Value.Gas, "Mismatch found in Gas");
            Assert.AreEqual(testData.Water, validWellTest.Value.Water, "Mismatch found in Water");
            Assert.AreEqual(testData.ChokeSize, validWellTest.Value.ChokeSize, "Mismatch found in ChokeSize");
            Assert.AreEqual(testData.FlowLinePressure, validWellTest.Value.FlowLinePressure, "Mismatch found in FlowLinePressure");
            Assert.AreEqual(testData.SeparatorPressure, validWellTest.Value.SeparatorPressure, "Mismatch found in SeparatorPressure");
            Assert.AreEqual(testData.TestDuration, validWellTest.Value.TestDuration, "Mismatch found in TestDuration");


            var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get Analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available for the obtained Analysis input");
            Assert.IsNull(analysisInput.TestData.Value.ChokeSize, "ChokeSize is defined in the TestData");
            Assert.IsNull(analysisInput.TestData.Value.LiquidAoF, "LiquidAoF is defined in the TestData");
            Assert.IsNotNull(analysisInput.TestData.Value.GasAoF, "GasAoF is not available for dry gas type well");

            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            // -------------- Get well analysis data in US units --------------
            Assert.AreEqual("STB/d", analysisInput.TestData.Units.LiquidAoF.UnitKey, "Incorrect US units for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.Precision);

            Assert.AreEqual("1/64in", analysisInput.TestData.Units.ChokeSize.UnitKey, "Incorrect US units for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.ChokeSize.Precision, "Incorrect US units precision for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.Precision);

            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            NodalAnalysisInputAndUnitsDTO analysisInput_metric = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());

            Assert.AreEqual("mm", analysisInput_metric.TestData.Units.ChokeSize.UnitKey, "Incorrect metric units for Chokesize:" + analysisInput_metric.TestData.Units.ChokeSize.UnitKey);

            Assert.AreEqual("sm3/d", analysisInput_metric.TestData.Units.LiquidAoF.UnitKey, "Incorrect metric units for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(3, (int)analysisInput_metric.TestData.Units.LiquidAoF.Precision, "Incorrect metric units precision for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.Precision);

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");


        }

        [TestCategory(TestCategories.WellConfigurationServiceTests), TestMethod]
        public void PLWellAOFCheck_Condensate()
        {
            var modelFileName = "PL-631.wflx";
            WellTypeId wellType = WellTypeId.PLift;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("PGLWELL_", wellType, WellFluidType.Condensate, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                MaximumCasingPressure = 210,
                MinimumCasingPressure = 210,
                MaximumTubingPressure = 160,
                MinimumTubingPressure = 160,
                FlowLinePressure = 160,
                FlowLineTemperature = 400,
                BuildTime = 11,
                AfterFlowTime = 38,
                FallTime = 30,
                RiseTime = 75,
                CycleGasVolume = 10,
                CycleWaterVolume = 1,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testData));

            WellTestAndUnitsDTO validWellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(validWellTest, "Added WellTest is not valid");
            Assert.AreEqual(testData.Oil, validWellTest.Value.Oil, "Actual Oil Rate should be 0 for Dry Gas Fluid Type");
            Assert.AreEqual(testData.CalibrationMethod, validWellTest.Value.CalibrationMethod, "Mismatch found in Calibration Method");
            Assert.AreEqual(testData.AverageTubingPressure, validWellTest.Value.AverageTubingPressure, "Mismatch found in AverageTubingPressure");
            Assert.AreEqual(testData.AverageTubingTemperature, validWellTest.Value.AverageTubingTemperature, "Mismatch found in AverageTubingTemperature");
            Assert.AreEqual(testData.Gas, validWellTest.Value.Gas, "Mismatch found in Gas");
            Assert.AreEqual(testData.Water, validWellTest.Value.Water, "Mismatch found in Water");
            Assert.AreEqual(testData.ChokeSize, validWellTest.Value.ChokeSize, "Mismatch found in ChokeSize");
            Assert.AreEqual(testData.FlowLinePressure, validWellTest.Value.FlowLinePressure, "Mismatch found in FlowLinePressure");
            Assert.AreEqual(testData.SeparatorPressure, validWellTest.Value.SeparatorPressure, "Mismatch found in SeparatorPressure");
            Assert.AreEqual(testData.TestDuration, validWellTest.Value.TestDuration, "Mismatch found in TestDuration");


            var analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get Analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available for the obtained Analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available for the obtained Analysis input");
            Assert.IsNull(analysisInput.TestData.Value.ChokeSize, "ChokeSize is defined in the TestData");
            Assert.IsNull(analysisInput.TestData.Value.LiquidAoF, "LiquidAoF is defined in the TestData");
            Assert.IsNotNull(analysisInput.TestData.Value.GasAoF, "GasAoF is not available for Condensate type well");


            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");

            // -------------- Get well analysis data in US units --------------
            Assert.AreEqual("STB/d", analysisInput.TestData.Units.LiquidAoF.UnitKey, "Incorrect US units for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.LiquidAoF.Precision, "Incorrect US units precision for Liquid AOF:" + analysisInput.TestData.Units.LiquidAoF.Precision);

            Assert.AreEqual("1/64in", analysisInput.TestData.Units.ChokeSize.UnitKey, "Incorrect US units for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.UnitKey);
            Assert.AreEqual(1, (int)analysisInput.TestData.Units.ChokeSize.Precision, "Incorrect US units precision for ChokeSize:" + analysisInput.TestData.Units.ChokeSize.Precision);

            // Set system to metric units
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            NodalAnalysisInputAndUnitsDTO analysisInput_metric = WellTestDataService.GetAnalysisInputDataAndUnits(validWellTest.Value.Id.ToString());

            Assert.AreEqual("mm", analysisInput_metric.TestData.Units.ChokeSize.UnitKey, "Incorrect metric units for Chokesize:" + analysisInput_metric.TestData.Units.ChokeSize.UnitKey);

            Assert.AreEqual("sm3/d", analysisInput_metric.TestData.Units.LiquidAoF.UnitKey, "Incorrect metric units for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.UnitKey);
            Assert.AreEqual(3, (int)analysisInput_metric.TestData.Units.LiquidAoF.Precision, "Incorrect metric units precision for Liquid AOF:" + analysisInput_metric.TestData.Units.LiquidAoF.Precision);

            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
        }

        //// <summary>
        /// Description : Enable Well Analysis for Water Injection wells - FRWM-6514
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void WaterInjectionWellAnalysis()
        {
            string facilityId = GetFacilityId("WATERINJWELL_", 1);
            try
            {
                // Set system to US units
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");

                #region Adding Well with Well Test
                //Adding Well along with WellTest Data
                WellDTO waterInjectionWell = AddNonRRLWell(facilityId, WellTypeId.WInj, false, CalibrationMethodId.LFactor);
                #endregion Adding Well with Well Test

                #region Running NodelAnalysis and selecting latest well test record
                // Get it back out and use it to load the analysis inputs (?)
                WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(waterInjectionWell.Id.ToString());
                NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());


                Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
                Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
                Assert.IsNotNull(analysisInput.TestData, "Test data is not available in the analysis input");

                Assert.IsNotNull(analysisInput.ModelData.FlowCorrelation, "Flow Correlation is not available in the model data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
                Assert.IsNotNull(analysisInput.TestData.Value.WellHeadPressure, "Tubing head pressure is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.WellHeadTemperature, "Tubing head temperature is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.DownholeGaugePressure, "Downhole pressure gauge is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.WaterRate, "Water rate is not available in test data");

                Assert.IsNotNull(analysisInput.TestData.Value.PartingPressure, "Parting Pressure is not available in test data");
                Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");

                Assert.IsNotNull(analysisInput.ModelData.SolutionNode, "Solution node is not available in the model data");
                Assert.IsNotNull(analysisInput.ModelData.StartNode, "Start node is not available in the modal data");
                Assert.AreNotEqual(analysisInput.ModelData.SolutionNode.Value.Name, analysisInput.ModelData.StartNode.Value.Name, "Start and solution node cannot be the same");

                Assert.IsNotNull(analysisInput.TestData.Value.FlowingBottomholePressure, "Flowing bottom hole pressure is not available in test data");
                Assert.IsNotNull(analysisInput.TestData.Value.LiquidAoF, "Flow at parting pressure is not available in test data");


                Assert.AreEqual("HagedornAndBrownStd", analysisInput.ModelData.FlowCorrelation.ToString(), "Mismatch between expected and actual Flow correlation");
                Assert.AreEqual((double)latestValidTestDataPair.Value.LFactor, analysisInput.CalibrationData.Value.LFactor, "Mismatch between the calulated LFactor in Well Test and the analysis ");
                Assert.AreEqual((double)latestValidTestDataPair.Value.AverageTubingPressure, analysisInput.TestData.Value.WellHeadPressure, "Mismatch between tubing head pressure in Well Test and in analysis");
                Assert.AreEqual((double)latestValidTestDataPair.Value.AverageTubingTemperature, analysisInput.TestData.Value.WellHeadTemperature, "Mismatch between tubing head temperature in Well Test and in analysis");

                Assert.AreEqual((double)latestValidTestDataPair.Value.GaugePressure, analysisInput.TestData.Value.DownholeGaugePressure, "Mismatch between gauge pressure in Well Test and the analysis ");
                Assert.AreEqual((double)latestValidTestDataPair.Value.Water, analysisInput.TestData.Value.WaterRate, "Mismatch between water rate in Well Test and in analysis");
                // Assert.AreEqual(2014.70, Math.Round(analysisInput.TestData.Value.PartingPressure, 2 ,1m) , "Mismatch between tubing head temperature in Well Test and in analysis");
                Assert.AreEqual((double)latestValidTestDataPair.Value.ReservoirPressure, analysisInput.CalibrationData.Value.ReservoirPressure, "Mismatch between Reservoir Pressure in Well Test and the analysis ");
                Assert.AreEqual(2, analysisInput.ModelData.SolutionNodes.Values.Count(), "Incorrect number of solution nodes are available in analysis input modal data");
                Assert.AreEqual(2, analysisInput.ModelData.StartNodes.Values.Count(), "Incorrect number of start nodes are available in analysis input modal data");

                Assert.AreEqual((double)latestValidTestDataPair.Value.FlowingBottomholePressure, analysisInput.TestData.Value.FlowingBottomholePressure, "Mismatch between FBHP in well test and in analysis");
                #endregion Running NodelAnalysis and selecting latest well test record

                #region performing analysis
                // Run the Injection analysis
                AnalysisResultsAndUnitsDTO actual_analysisResult = WellTestDataService.PerformAnalysis(analysisInput);
                // string jsonstring1 = JsonConvert.SerializeObject(actual_analysisResult);
                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                string FileName = "water_Analysis_json_test_US.json";
                AnalysisResultsAndUnitsDTO expected_analysisResult = JsonConvert.DeserializeObject<AnalysisResultsAndUnitsDTO>(GetJsonString(Path + FileName));
                #endregion performing analysis

                #region validation for InFlow/OutFlow Curve
                //Comparing InFLow / OutFlow curve units and values
                CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.FlowCurves.Units, actual_analysisResult.OperatingPointResults.FlowCurves.Units, "Units not matching for InFlow / OutFlow Curve");

                for (int i = 0; i < actual_analysisResult.OperatingPointResults.FlowCurves.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.FlowCurves.Values[i], actual_analysisResult.OperatingPointResults.FlowCurves.Values[i], "Mismatch at element " + i, null, 0.5);
                }
                Assert.IsNotNull(actual_analysisResult.OperatingPointResults, "Unable to get inflow/outflow curves after Water Injection Analysis");
                Assert.IsNotNull(actual_analysisResult.OperatingPointResults.FlowCurves, "Unable to get inflow/outflow curve points after Water Injection Analysis");

                #endregion validation for InFlow/OutFlow Curve

                #region validation for Wellperformance Curve
                //Comparing WellPerformance curve units and values
                CompareObjectsUsingReflection(expected_analysisResult.WellPerformanceCurve.WellPerformanceCurve.Units, actual_analysisResult.WellPerformanceCurve.WellPerformanceCurve.Units, "Units not matching for WellPerformance Curve");

                for (int i = 0; i < actual_analysisResult.OperatingPointResults.FlowCurves.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expected_analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[i], actual_analysisResult.WellPerformanceCurve.WellPerformanceCurve.Values[i], "Mismatch at element " + i, null, 0.5);
                }
                Assert.IsNotNull(actual_analysisResult.WellPerformanceCurve, "Unable to get wellperformance curves after Water Injection Analysis");
                Assert.IsNotNull(actual_analysisResult.WellPerformanceCurve.WellPerformanceCurve, "Unable to get wellperformance curve points after Water Injection Analysis");
                #endregion validation for Wellperformance Curve

                #region validation for Gradient Curve
                //Comparing Gradient curve units and values
                CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Units, actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Units, "Units not matching for Gradient Curve");

                for (int i = 0; i < actual_analysisResult.OperatingPointResults.FlowCurves.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i], actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i], "Mismatch at element " + i, null, 0.5);
                }
                Assert.IsNotNull(actual_analysisResult.PressureDropResults.GradientCurves, "Unable to get gradient curves after Water Injection Analysis");
                Assert.IsNotNull(actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves, "Unable to get gradient curve points after Water Injection Analysis");
                #endregion validation for Gradient Curve

            }

            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                RemoveWell(facilityId);
            }
        }

        public void CreateWellandAddMultipleWellTest(WellTypeId wellTypeId)
        {
            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellTypeId.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellTypeId }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellTypeId.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            //add new wellTestData
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 2,
                SPTCodeDescription = "RepresentativeTest",
                TestDuration = 3,
                Water = 1900,
                WaterGravity = (decimal)1.0239,
                GaugePressure = (decimal)1610
            };

            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(2));
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            WellTestDTO[] addedWelltests = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
            Assert.AreEqual(1, addedWelltests.Count(), "Mismatch in added well tests");

            //add new wellTestData
            var lastTestDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 0,
                SPTCodeDescription = "AllocatableTest",
                TestDuration = 3,
                Water = 1900,
                WaterGravity = (decimal)1.0239,
                GaugePressure = (decimal)1610
            };

            lastTestDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1));
            WellTestUnitsDTO units1 = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units1, lastTestDataDTO));
            WellTestDTO[] addedLastWelltests = WellTestDataService.GetWellTestDataByWellId(well.Id.ToString()).Values;
            Assert.AreEqual(2, addedLastWelltests.Count(), "Mismatch in added well tests");
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GroupWellTest_LastWellTest()
        {
            try
            {
                //Add RRL well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.RRL);

                //Add GL well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.GLift);

                //Add ESP well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.ESP);

                //Add NF well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.NF);

                //Add GI well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.GInj);

                //Add PCP well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.PCP);

                //Add WINJ well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.WInj);

                //Add Other well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.OT);

                //Group well test
                GroupWellTestInputDTO groupwelltestDTO = new GroupWellTestInputDTO
                {
                    UserSelectionType = GroupWellTestUserSelectionTypes.LastTest
                };

                WellTestArrayAndUnitsDTO unitsDTO = WellTestDataService.GetGroupWellTest(groupwelltestDTO);

                int welltests_total = unitsDTO.Values.Count();
                Assert.AreEqual(8, welltests_total, "Total number of Last well tests values mismatch");
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GroupWellTest_AllocatableWellTest()
        {
            try
            {
                //Add RRL well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.RRL);

                //Add GL well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.GLift);

                //Add ESP well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.ESP);

                //Add NF well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.NF);

                //Add GI well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.GInj);

                //Add PCP well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.PCP);

                //Add WINJ well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.WInj);

                //Add Other well and a well test
                CreateWellandAddMultipleWellTest(WellTypeId.OT);

                //Group well test
                GroupWellTestInputDTO groupwelltestDTO = new GroupWellTestInputDTO
                {
                    UserSelectionType = GroupWellTestUserSelectionTypes.LastAllocatableTest
                };

                WellTestArrayAndUnitsDTO unitsDTO = WellTestDataService.GetGroupWellTest(groupwelltestDTO);
                int welltests_total = unitsDTO.Values.Count();
                Assert.AreEqual(8, welltests_total, "Total number of Allocatable well tests values mismatch");
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void AddWellTestFromDailyAverageForGIWICheck()
        {
            if (s_isRunningInATS == false)
            {
                Trace.WriteLine("Test Not executed on Team City due to scheduler constraints");
                return;
            }
            double oldternddays = 90;
            try
            {

                //Add GI well and a well test
                WellDTO ginjwell = AddNonRRLWell(GetFacilityId("GASINJWELL_", 3), WellTypeId.GInj);

                //Add WI well
                WellDTO winjewell = AddNonRRLWell(GetFacilityId("WATERINJWELL_", 3), WellTypeId.WInj);

                _wellsToRemove.Add(ginjwell);
                _wellsToRemove.Add(winjewell);
                UpdateSystemSettings(ginjwell, new string[] { SettingServiceStringConstants.LFACTOR_MAX_AL, SettingServiceStringConstants.LFACTOR_MIN_AL }, new double[] { 1.51, 0.6 });
                UpdateSystemSettings(winjewell, new string[] { SettingServiceStringConstants.LFACTOR_MAX_AL, SettingServiceStringConstants.LFACTOR_MIN_AL }, new double[] { 1.51, 0.6 });
                oldternddays = (double)GetForeSiteToolBoxSettingValue(SettingServiceStringConstants.TIME_SPAN_DAILY_TRENDS);
                SetValuesInSystemSettings(SettingServiceStringConstants.TIME_SPAN_DAILY_TRENDS, "4");
                RunAnalysisTaskScheduler("-runAllocationTimeSpan");

                // Get Well Tests
                var welltestginjwell = WellTestDataService.GetWellTestDataByWellId(ginjwell.Id.ToString());
                var welltestwinjwell = WellTestDataService.GetWellTestDataByWellId(winjewell.Id.ToString());

                //THP : psia [100,200 ]
                //THT :F [65,100]
                //GI: 300 -700
                //WI:  200 -500
                //DHCP :1800 2200
                foreach (var welltestvaluedto in welltestginjwell.Values)
                {
                    Assert.IsTrue(welltestginjwell.Values.Length >= 4, "Well test records were not added ");
                    Assert.AreEqual("LFactor", welltestvaluedto.CalibrationMethod.ToString(), "Tuning Method was not Correct ");

                    Assert.IsNotNull(welltestvaluedto.TestDuration, "Test Duration was NULL");
                    Trace.WriteLine($"Well Test Rates Added for Gas Injection Well:: [US units]  Date   : {welltestvaluedto.TestEndDate} , THP : {welltestvaluedto.AverageTubingPressure } , THT : {welltestvaluedto.AverageTubingTemperature} , Rate {welltestvaluedto.Gas} ,Gauge PResure  : {welltestvaluedto.GaugePressure}");
                    if (welltestvaluedto.TestDuration == 0)
                    {
                        continue; //this is not the well test record added by Integration test from daily average
                    }
                    Assert.AreEqual("Success", welltestvaluedto.TuningStatus, "Tuning Status was not Correct ");
                    Assert.AreEqual("AllocatableTest", welltestvaluedto.SPTCodeDescription, "Well test Quality Code was not Correct ");
                    Assert.AreEqual(AuthenticatedUser.Name, welltestvaluedto.LastChangedUser, "Well test User Name mismatch");
                    Assert.IsTrue(welltestvaluedto.TestEndDate < DateTime.Today.ToUniversalTime(), "Date Time of Welll test was equal or after today");
                    Assert.IsTrue(welltestvaluedto.AverageTubingPressure < 201 && welltestvaluedto.AverageTubingPressure > 100, "Tubing Pressure was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.AverageTubingTemperature < 101 && welltestvaluedto.AverageTubingTemperature > 65, "Tubing Head Temperature was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.GaugePressure < 2200 && welltestvaluedto.GaugePressure > 1800, "Guage Pressure was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.Gas < 701 && welltestvaluedto.Gas > 300, "Gas Rate(Injection Gas Rate) was NULL or no in range");
                }

                foreach (var welltestvaluedto in welltestwinjwell.Values)
                {
                    Assert.IsTrue(welltestwinjwell.Values.Length >= 4, "Well test records were not added ");
                    Assert.AreEqual("LFactor", welltestvaluedto.CalibrationMethod.ToString(), "Tuning Method was not Correct ");
                    Assert.IsNotNull(welltestvaluedto.TestDuration, "Test Duration was NULL");
                    Trace.WriteLine($"Well Test Rates Added for Water Injection Well ::   [US units] Date : {welltestvaluedto.TestEndDate} , THP : {welltestvaluedto.AverageTubingPressure } , THT : {welltestvaluedto.AverageTubingTemperature} , Water Rate {welltestvaluedto.Water} ,Gauge PResure  : {welltestvaluedto.GaugePressure}");
                    if (welltestvaluedto.TestDuration == 0)
                    {
                        continue; //this is not the well test record added by Integration test from daily average
                    }
                    Assert.AreEqual("Success", welltestvaluedto.TuningStatus, "Tuning Status was not Correct ");
                    Assert.AreEqual("AllocatableTest", welltestvaluedto.SPTCodeDescription, "Well test Quality Code was not Correct ");
                    Assert.AreEqual(AuthenticatedUser.Name, welltestvaluedto.LastChangedUser, "Well test User Name mismatch");
                    Assert.IsTrue(welltestvaluedto.TestEndDate < DateTime.Today.ToUniversalTime(), "Date Time of Welll test was equal or after today");
                    Assert.IsTrue(welltestvaluedto.AverageTubingPressure < 301 && welltestvaluedto.AverageTubingPressure > 100, "Tubing Pressure was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.AverageTubingTemperature < 101 && welltestvaluedto.AverageTubingTemperature > 65, "Tubing Head Temperature was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.GaugePressure < 2200 && welltestvaluedto.GaugePressure > 1800, "Guage Pressure was NULL or no in range");
                    //Seems like point was updated from RH2O to RATEH2O ; Hence updated as per lower and upperbounds of RATEH2O;
                    Assert.IsTrue(welltestvaluedto.Water < 701 && welltestvaluedto.Water > 300, "Water Rate(Injection Water Rate) was NULL or no in range");
                }

                ChangeUnitSystemUserSetting("Metric");
                welltestginjwell = WellTestDataService.GetWellTestDataByWellId(ginjwell.Id.ToString());
                welltestwinjwell = WellTestDataService.GetWellTestDataByWellId(winjewell.Id.ToString());
                foreach (var welltestvaluedto in welltestginjwell.Values)
                {
                    Assert.IsTrue(welltestginjwell.Values.Length >= 4, "Well test records were not added ");
                    Assert.IsNotNull(welltestvaluedto.TestDuration, "Test Duration was NULL");
                    Assert.AreEqual("LFactor", welltestvaluedto.CalibrationMethod.ToString(), "Tuning Method was not Correct ");
                    Trace.WriteLine($"Well Test Rates Added for Gas Injection Well ::[Metric units],   Date   : {welltestvaluedto.TestEndDate} , THP : {welltestvaluedto.AverageTubingPressure } , THT : {welltestvaluedto.AverageTubingTemperature} , Gas Rate {welltestvaluedto.Gas} ,Gauge PResure  : {welltestvaluedto.GaugePressure}");
                    if (welltestvaluedto.TestDuration == 0)
                    {
                        continue; //this is not the well test record added by Integration test from daily average
                    }
                    Assert.AreEqual("Success", welltestvaluedto.TuningStatus, "Tuning Status was not Correct ");
                    Assert.AreEqual("AllocatableTest", welltestvaluedto.SPTCodeDescription, "Well test Quality Code was not Correct ");
                    Assert.AreEqual(AuthenticatedUser.Name, welltestvaluedto.LastChangedUser, "Well test User Name mismatch");
                    Assert.IsTrue(welltestvaluedto.TestEndDate < DateTime.Today.ToUniversalTime(), "Date Time of Welll test was equal or after today");
                    Assert.IsTrue(welltestvaluedto.AverageTubingPressure < (decimal?)UnitsConversion("psia", 201) && welltestvaluedto.AverageTubingPressure > (decimal?)UnitsConversion("psia", 100), "Tubing Pressure was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.AverageTubingTemperature < (decimal?)UnitsConversion("F", 101) && welltestvaluedto.AverageTubingTemperature > (decimal?)UnitsConversion("F", 65), "Tubing Head Temperature was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.GaugePressure < (decimal?)UnitsConversion("psia", 2200) && welltestvaluedto.GaugePressure > (decimal?)UnitsConversion("psia", 1800), "Guage Pressure was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.Gas < (decimal?)UnitsConversion("Mscf/d", 701) && welltestvaluedto.Gas > (decimal?)UnitsConversion("Mscf/d", 300), "Gas Rate(Injection Gas Rate) was NULL or no in range");
                }

                foreach (var welltestvaluedto in welltestwinjwell.Values)
                {
                    Assert.IsTrue(welltestwinjwell.Values.Length >= 4, "Well test records were not added ");
                    Assert.IsNotNull(welltestvaluedto.TestDuration, "Test Duration was NULL");
                    Assert.AreEqual("LFactor", welltestvaluedto.CalibrationMethod.ToString(), "Tuning Method was not Correct ");
                    Trace.WriteLine($"Well Test Rates Added for Water Injection Well ::  [Metric units]  Date : {welltestvaluedto.TestEndDate} , test dutation : {welltestvaluedto.TestDuration} , THP : {welltestvaluedto.AverageTubingPressure } , THT : {welltestvaluedto.AverageTubingTemperature} , Water Rate {welltestvaluedto.Water} ,Gauge PResure  : {welltestvaluedto.GaugePressure}");
                    if (welltestvaluedto.TestDuration == 0)
                    {
                        continue; //this is not the well test record added by Integration test from daily average
                    }
                    Assert.AreEqual("Success", welltestvaluedto.TuningStatus, "Tuning Status was not Correct ");
                    Assert.AreEqual("AllocatableTest", welltestvaluedto.SPTCodeDescription, "Well test Quality Code was not Correct ");
                    Assert.AreEqual(AuthenticatedUser.Name, welltestvaluedto.LastChangedUser, "Well test User Name mismatch");
                    Assert.IsTrue(welltestvaluedto.TestEndDate < DateTime.Today.ToUniversalTime(), "Date Time of Welll test was equal or after today");
                    Assert.IsTrue(welltestvaluedto.AverageTubingPressure < (decimal?)UnitsConversion("psia", 301) && welltestvaluedto.AverageTubingPressure > (decimal?)UnitsConversion("psia", 100), "Tubing Pressure was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.AverageTubingTemperature < (decimal?)UnitsConversion("F", 101) && welltestvaluedto.AverageTubingTemperature > (decimal?)UnitsConversion("F", 65), "Tubing Head Temperature was NULL or no in range");
                    Assert.IsTrue(welltestvaluedto.GaugePressure < (decimal?)UnitsConversion("psia", 2200) && welltestvaluedto.GaugePressure > (decimal?)UnitsConversion("psia", 1800), "Guage Pressure was NULL or no in range");
                    //Seems like point was updated from RH2O to RATEH2O ; Hence updated as per lower and upperbounds of RATEH2O;
                    Assert.IsTrue(welltestvaluedto.Water < (decimal?)UnitsConversion("STB/d", 701) && welltestvaluedto.Water > (decimal?)UnitsConversion("STB/d", 300), "Water Rate(Injection Gas Rate) was NULL or no in range");
                }

            }

            finally
            {
                ChangeUnitSystemUserSetting("US");
                SetValuesInSystemSettings(SettingServiceStringConstants.TIME_SPAN_DAILY_TRENDS, oldternddays.ToString());
            }
        }


        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void CompareWellTestforSameChokeSize_PCP()
        {
            string facilityId = GetFacilityId("WFTA1K_", 1);

            // Set system to US units
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
            Trace.WriteLine("System set for US unit system");

            //Adding Well along with WellTest Data  with L Factor Tuning Method
            WellDTO pcpWell = AddNonRRLWell(facilityId, WellTypeId.PCP, false, CalibrationMethodId.LFactor);
            _wellsToRemove.Add(pcpWell);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min L Factor Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max L Factor Acceptance Limit", 2.0);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max Water Cut Acceptance Limit", 1.0);

            AddWellSettingWithDoubleValues(pcpWell.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(pcpWell.Id, "Max GOR Acceptance Limit", 2000.0);

            WellTestDTO latestTestData_PCP = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_PCP.Id });

            WellTestDTO latestTestDataAfterTune_PCP = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            Assert.AreEqual("TUNING_SUCCEEDED", latestTestDataAfterTune_PCP.Status.ToString(), "Well Test Status is not Success");

            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestData_PCP.Id });


            //Adding WellTest 2
            WellTestDTO testDataDTO = new WellTestDTO()
            {
                WellId = pcpWell.Id,
                SPTCodeDescription = "AllocatableTest",
                SampleDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(5),
                TestDuration = 12,
                Oil = (decimal)210.2,
                Water = (decimal)141.2,
                Gas = (decimal)10.40,
                AverageTubingPressure = (decimal)110.00,
                AverageTubingTemperature = (decimal)80.00,
                GaugePressure = (decimal)423.00,
                AverageCasingPressure = (decimal)45.23,
                PumpIntakePressure = (decimal)161.19,
                PumpDischargePressure = (decimal)2130.69,
                PolishedRodTorque = (decimal)361.35,
                PumpTorque = (decimal)185.23,
                PumpSpeed = (decimal)225.00,
                FlowLinePressure = (decimal)1862.00,
                FlowLineTemperature = (decimal)80.00,
                SeparatorPressure = (decimal)1523.00,
                ChokeSize = (decimal)64.00,
                Comment = "PCPWellTest_Comment_Check",
                MotorCurrent = (decimal)180.0,
                MotorVolts = (decimal)230.0
            };

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(pcpWell.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));
            WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(pcpWell.Id.ToString());
            Trace.WriteLine("Well test saved successfully");

            WellTestDTO latestTestData_PCP2 = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_PCP2.Id });

            WellTestDTO latestTestDataAfterTune_PCP2 = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare2 = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestDataAfterTune_PCP2.Id, latestTestData_PCP.Id });

            //Adding WellTest 3
            WellTestDTO testDataDTO2 = new WellTestDTO()
            {
                WellId = pcpWell.Id,
                SPTCodeDescription = "AllocatableTest",
                SampleDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(3),
                TestDuration = 12,
                Oil = (decimal)210.2,
                Water = (decimal)141.2,
                Gas = (decimal)10.40,
                AverageTubingPressure = (decimal)120.00,
                AverageTubingTemperature = (decimal)80.00,
                GaugePressure = (decimal)423.00,
                AverageCasingPressure = (decimal)45.23,
                PumpIntakePressure = (decimal)161.19,
                PumpDischargePressure = (decimal)2130.69,
                PolishedRodTorque = (decimal)361.35,
                PumpTorque = (decimal)185.23,
                PumpSpeed = (decimal)225.00,
                FlowLinePressure = (decimal)1862.00,
                FlowLineTemperature = (decimal)80.00,
                SeparatorPressure = (decimal)1523.00,
                ChokeSize = (decimal)64.00,
                Comment = "PCPWellTest_Comment_Check",
                MotorCurrent = (decimal)180.0,
                MotorVolts = (decimal)230.0
            };

            //Saved WellTest Data
            WellTestUnitsDTO units_2 = WellTestDataService.GetWellTestDefaults(pcpWell.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units_2, testDataDTO2));
            WellTestDTO[] allTunedAgainTests_2 = WellTestDataService.GetAllValidWellTestByWellId(pcpWell.Id.ToString());
            Trace.WriteLine("Well test saved successfully");

            WellTestDTO latestTestData_PCP3 = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_PCP3.Id });

            WellTestDTO latestTestDataAfterTune_PCP3 = WellTestDataService.GetLatestWellTestDataByWellId(pcpWell.Id.ToString());
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare3 = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestDataAfterTune_PCP2.Id, latestTestData_PCP.Id, latestTestDataAfterTune_PCP3.Id });
            Assert.IsNotNull(getWelltestCompare3, "Failed to get Well test compare grid data");

        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void CompareWellTestforSameChokeSize_GL()
        {
            //pick up the right model file
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("GL-01-Base.wflx", WellTypeId.GLift, new ModelFileOptionDTO() { CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), (long)OptionalUpdates.UpdateWCT_WGR, ((long)OptionalUpdates.CalculateChokeD_Factor) } });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);
            //Create a new well
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(10);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            //add new wellTestData
            var testDataDTO = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 600,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 2,
                SPTCodeDescription = "RepresentativeTest",
                TestDuration = 3,
                Water = 1900,
                ChokeSize = 64,
                WaterGravity = (decimal)1.0239,
                GaugePressure = (decimal)1610
            };

            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(5));
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDataDTO));

            AddWellSettingWithDoubleValues(well.Id, "Min L Factor Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(well.Id, "Max L Factor Acceptance Limit", 2.0);
            AddWellSettingWithDoubleValues(well.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(well.Id, "Max Water Cut Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(well.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(well.Id, "Max GOR Acceptance Limit", 2000.0);
            WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
            WellTestDTO latestTestData_GL = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_GL.Id });

            WellTestDTO latestTestDataAfterTune_GL = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestDataAfterTune_GL.Id });

            //add new wellTestData
            var testDataDTO2 = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 500,
                AverageTubingTemperature = 100,
                Gas = 2204m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 2,
                SPTCodeDescription = "RepresentativeTest",
                TestDuration = 3,
                Water = 1900,
                ChokeSize = 64,
                WaterGravity = (decimal)1.0239,
                //LFactor = 1,
                //ReservoirPressure = 5250,
                //ProductivityIndex = (decimal)1.36,
                GaugePressure = (decimal)1610


            };
            testDataDTO2.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(2));
            WellTestUnitsDTO units2 = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units2, testDataDTO2));

            //WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDTO));
            AddWellSettingWithDoubleValues(well.Id, "Min L Factor Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(well.Id, "Max L Factor Acceptance Limit", 2.0);
            AddWellSettingWithDoubleValues(well.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(well.Id, "Max Water Cut Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(well.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(well.Id, "Max GOR Acceptance Limit", 2000.0);

            WellTestDTO[] allTunedAgainTests2 = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
            WellTestDTO latestTestData_GL2 = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_GL2.Id });

            WellTestDTO latestTestDataAfterTune_GL2 = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare2 = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestDataAfterTune_GL2.Id, latestTestDataAfterTune_GL.Id });

            //add new wellTestData
            var testDataDTO3 = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 400,
                AverageTubingTemperature = 100,
                Gas = 2304m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 2,
                SPTCodeDescription = "RepresentativeTest",
                TestDuration = 3,
                Water = 1900,
                ChokeSize = 64,
                WaterGravity = (decimal)1.0239,
                GaugePressure = (decimal)1610


            };
            testDataDTO3.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1));
            WellTestUnitsDTO units3 = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units3, testDataDTO3));

            AddWellSettingWithDoubleValues(well.Id, "Min L Factor Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(well.Id, "Max L Factor Acceptance Limit", 2.0);
            AddWellSettingWithDoubleValues(well.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(well.Id, "Max Water Cut Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(well.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(well.Id, "Max GOR Acceptance Limit", 2000.0);

            WellTestDTO[] allTunedAgainTests3 = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
            WellTestDTO latestTestData_GL3 = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_GL3.Id });

            WellTestDTO latestTestDataAfterTune_GL3 = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare3 = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestDataAfterTune_GL2.Id, latestTestDataAfterTune_GL.Id, latestTestDataAfterTune_GL3.Id });

        }
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void CompareWellTestforSameChokeSize_NF_Condensate()
        {
            var modelFileName = "Condensate Gas - IPR Auto Tuning.wflx";
            var wellType = WellTypeId.NF;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("NFWWELL_", wellType, WellFluidType.Condensate, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 4000,
                AverageTubingTemperature = 100,
                Gas = 35520,
                Water = 5327.6m,
                Oil = 5327.6m,
                ChokeSize = 32,
                FlowLinePressure = 4000,
                SeparatorPressure = 4000,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };

            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testData));

            WellTestAndUnitsDTO validWellTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
            WellTestDTO latestTestData_NF = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_NF.Id });

            WellTestDTO latestTestDataAfterTune_NF = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestDataAfterTune_NF.Id });

            //add new wellTestData
            var testDataDTO2 = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                AverageTubingPressure = 4010,
                AverageTubingTemperature = 100,
                Gas = 35520,
                Water = 5327.6m,
                Oil = 5327.6m,
                ChokeSize = 32,
                FlowLinePressure = 4000,
                SeparatorPressure = 4000,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-4).ToUniversalTime()

            };
            testDataDTO2.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(2));
            WellTestUnitsDTO units2 = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units2, testDataDTO2));

            WellTestDTO[] allTunedAgainTests2 = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
            WellTestDTO latestTestData_NF2 = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_NF2.Id });

            WellTestDTO latestTestDataAfterTune_NF2 = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare2 = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestDataAfterTune_NF2.Id, latestTestDataAfterTune_NF.Id });

            //add new wellTestData with Failure status and check Failure well test should not be visible in compare well list
            var testDataDTO3 = new WellTestDTO
            {
                WellId = well.Id,
                AverageCasingPressure = 2200,
                AverageTubingPressure = 400,
                AverageTubingTemperature = 100,
                Gas = 2304m,
                GasGravity = 0.6722m,
                producedGOR = 1160,
                Oil = 1900,
                OilGravity = 46.2415m,
                SPTCode = 2,
                SPTCodeDescription = "RepresentativeTest",
                TestDuration = 3,
                Water = 1900,
                ChokeSize = 64,
                WaterGravity = (decimal)1.0239,
                GaugePressure = (decimal)1610

            };
            testDataDTO3.SampleDate = (DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1));
            WellTestUnitsDTO units3 = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units3, testDataDTO3));

            WellTestDTO[] allTunedAgainTests3 = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());
            WellTestDTO latestTestData_NF3 = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_NF3.Id });

            WellTestDTO latestTestDataAfterTune_NF3 = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare3 = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestDataAfterTune_NF2.Id, latestTestDataAfterTune_NF.Id, latestTestDataAfterTune_NF3.Id });

        }
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void CompareWellTestforSameChokeSize_ESP()
        {
            // This is the path to the  ESP example well model in the codebase.
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP,
                new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.LFactor,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.CalculateChokeD_Factor
                    }
                });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = "ESPTestWell3" + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            WellDTO newWell = WellService.GetWellByName("ESPTestWell3" + wellType.ToString());
            Assert.IsNotNull(newWell);
            _wellsToRemove.Add(newWell);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO();

            options.Comment = "Testing 1 - 2 - 3 ..." + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(2);
            modelFile.WellId = newWell.Id;

            byte[] fileAsByteArray = GetByteArray(path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File is not an ESP model file.");
            ModelFileValidationDataDTO modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(modelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            WellTestDTO testDTO = new WellTestDTO
            {
                WellId = newWell.Id,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 100,
                AverageTubingTemperature = 101,
                GaugePressure = 104,
                Oil = 108,
                Gas = 109,
                Water = 110,
                ChokeSize = 107,
                FlowLinePressure = 105,
                SeparatorPressure = 106,
                Frequency = 60,
                MotorVolts = 450,
                MotorCurrent = 55,
                SampleDate = DateTime.Today.ToUniversalTime()
            };

            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(newWell.Id.ToString()).Units;
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDTO));
            AddWellSettingWithDoubleValues(newWell.Id, "Min L Factor Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(newWell.Id, "Max L Factor Acceptance Limit", 2.0);
            AddWellSettingWithDoubleValues(newWell.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(newWell.Id, "Max Water Cut Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(newWell.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(newWell.Id, "Max GOR Acceptance Limit", 2000.0);
            WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(newWell.Id.ToString());

            WellTestDTO latestTestData_ESP = WellTestDataService.GetLatestWellTestDataByWellId(newWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_ESP.Id });
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestData_ESP.Id });

            //add new well test data 2
            WellTestDTO testDTO2 = new WellTestDTO
            {
                WellId = newWell.Id,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 100,
                AverageTubingTemperature = 101,
                GaugePressure = 105,
                Oil = 107,
                Gas = 108,
                Water = 110,
                ChokeSize = 107,
                FlowLinePressure = 105,
                SeparatorPressure = 106,
                Frequency = 60,
                MotorVolts = 450,
                MotorCurrent = 55,
                SampleDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(2)
            };

            WellTestUnitsDTO units2 = WellTestDataService.GetWellTestDefaults(newWell.Id.ToString()).Units;
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units2, testDTO2));
            AddWellSettingWithDoubleValues(newWell.Id, "Min L Factor Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(newWell.Id, "Max L Factor Acceptance Limit", 2.0);
            AddWellSettingWithDoubleValues(newWell.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(newWell.Id, "Max Water Cut Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(newWell.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(newWell.Id, "Max GOR Acceptance Limit", 2000.0);
            WellTestDTO[] allTunedAgainTests_2 = WellTestDataService.GetAllValidWellTestByWellId(newWell.Id.ToString());

            WellTestDTO latestTestData_ESP_2 = WellTestDataService.GetLatestWellTestDataByWellId(newWell.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_ESP_2.Id });
            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare2 = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestData_ESP_2.Id });

            //add new well test data 3
            WellTestDTO testDTO3 = new WellTestDTO
            {
                WellId = newWell.Id,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 105,
                AverageTubingTemperature = 101,
                GaugePressure = 105,
                Oil = 105,
                Gas = 107,
                Water = 110,
                ChokeSize = 107,
                FlowLinePressure = 105,
                SeparatorPressure = 106,
                Frequency = 60,
                MotorVolts = 450,
                MotorCurrent = 55,
                SampleDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1)
            };

            WellTestUnitsDTO units3 = WellTestDataService.GetWellTestDefaults(newWell.Id.ToString()).Units;
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units3, testDTO3));
            AddWellSettingWithDoubleValues(newWell.Id, "Min L Factor Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(newWell.Id, "Max L Factor Acceptance Limit", 2.0);
            AddWellSettingWithDoubleValues(newWell.Id, "Min Water Cut Acceptance Limit", 0.1);
            AddWellSettingWithDoubleValues(newWell.Id, "Max Water Cut Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(newWell.Id, "Min GOR Acceptance Limit", 1.0);
            AddWellSettingWithDoubleValues(newWell.Id, "Max GOR Acceptance Limit", 2000.0);
            WellTestDTO[] allTunedAgainTests_3 = WellTestDataService.GetAllValidWellTestByWellId(newWell.Id.ToString());

            WellTestDTO latestTestData_ESP_3 = WellTestDataService.GetLatestWellTestDataByWellId(newWell.Id.ToString());
            //Tune well test
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_ESP_3.Id });

            //Get compare Well test data by Matching same choke size
            WellTestArrayAndUnitsDTO getWelltestCompare3 = WellTestDataService.GetWellTestDataByMatchingChokeSize(new long[] { latestTestData_ESP_2.Id, latestTestData_ESP.Id, latestTestData_ESP_3.Id });
            Assert.IsNotNull(getWelltestCompare3, "Failed to get Well test compare grid data");





        }

        /// <summary>
        /// Tests for: Use Model L Factor for Acceptance Limit Referencefrom model file = "False" in System setting in toolbox
        ///  If Use Model L Factor for Acceptance Limit Reference is set to False (the default), 
        ///  an idealized value of 1.0 is used as the base value.
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void LFactorFlagIsFalseForAcceptanceLimit_NonRRL()
        {

            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
             Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("WellfloWaterInjectionExample1.wflx", WellTypeId.WInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("GL_BlackOil.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR) } }),
             //Tuple.Create("WellfloGasInjectionExample1.wflx", WellTypeId.GInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
              Tuple.Create("PCP-SinglePhase.wflx", WellTypeId.PCP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.UpdateGOR_CGR) } }),

            };
            foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
            {
                int i = 1;
                string model = modelInfo.Item1;
                WellTypeId wellType = modelInfo.Item2;
                ModelFileOptionDTO options = modelInfo.Item3;

                Trace.WriteLine("Testing model: " + model);
                //Create a new well
                WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
                var allWells = WellService.GetAllWells().ToList();
                WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                Assert.IsNotNull(well);
                _wellsToRemove.Add(well);

                ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                options.Comment = "CASETest Upload " + modelInfo.Item1;
                modelFile.Options = options;
                modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i);
                modelFile.WellId = well.Id;

                byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                Assert.IsNotNull(fileAsByteArray);
                modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                Assert.IsNotNull(ModelFileValidationData);
                ModelFileService.AddWellModelFile(modelFile);
                ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                Assert.IsNotNull(newModelFile);
                _modelFilesToRemove.Add(newModelFile.Id.ToString());

                #region ESP

                if (wellType == WellTypeId.ESP)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCode = 0,
                        SPTCodeDescription = "AllocatableTest",
                        //AverageTubingPressure = 3072,
                        AverageTubingTemperature = 200,
                        GaugePressure = 104,
                        Oil = (decimal)2501.80,
                        Gas = 1250,
                        Water = (decimal)3752.60,
                        ChokeSize = 64,
                        Frequency = 70,

                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                    WellTestDTO latestTestData_ESP = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

                    Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_ESP.Status.ToString(), "Well Test Status is not Success");
                }

                #endregion ESP

                #region WaterInjection

                else if (wellType == WellTypeId.WInj)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCode = 0,
                        SPTCodeDescription = "AllocatableTest",
                        AverageTubingPressure = (decimal)3514.7,
                        AverageTubingTemperature = 65,
                        PumpIntakePressure = 10000,
                        PumpDischargePressure = 11000,
                        GaugePressure = 12000,
                        Water = (decimal)6932.80,
                        ChokeSize = 60,
                        FlowLinePressure = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                    WellTestDTO latestTestData_WI = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

                    Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_WI.Status.ToString(), "Well Test Status is not Success");
                }

                #endregion WaterInjection

                #region GasLift

                else if (wellType == WellTypeId.GLift)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCode = 0,
                        SPTCodeDescription = "AllocatableTest",
                        AverageTubingPressure = 96,
                        AverageTubingTemperature = 100,
                        AverageCasingPressure = 1000,
                        GasInjectionRate = 1000,
                        FlowLinePressure = 50,
                        SeparatorPressure = 30,
                        GaugePressure = 12000,
                        Oil = (decimal)599.00,
                        Gas = 1020,
                        Water = (decimal)732.2,
                        ChokeSize = 50,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                    WellTestDTO latestTestData_GL = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

                    Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_GL.Status.ToString(), "Well Test Status is not Success");
                }

                #endregion GasLift

                #region NF

                else if (wellType == WellTypeId.NF)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCode = 2,
                        SPTCodeDescription = "RepresentativeTest",
                        AverageTubingPressure = (decimal)164.7,
                        AverageTubingTemperature = 80,
                        //GaugePressure = 12000,
                        Oil = (decimal)1768.00,
                        Gas = 880,
                        Water = (decimal)589.30,
                        ChokeSize = 50,
                        FlowLinePressure = 50,
                        SeparatorPressure = 10000,
                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                    WellTestDTO latestTestData_NF = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

                    Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_NF.Status.ToString(), "Well Test Status is not Success");
                }

                #endregion NF
                #region PCP

                if (wellType == WellTypeId.PCP)
                {
                    //add new wellTestData
                    WellTestDTO testDataDTO = new WellTestDTO()
                    {
                        WellId = well.Id,
                        SPTCodeDescription = "Allocatable Test",

                        TestDuration = 24,
                        Oil = (decimal)210.2,
                        Water = (decimal)140.2,
                        AverageTubingPressure = (decimal)100.00,
                        AverageTubingTemperature = (decimal)80.00,
                        PumpSpeed = (decimal)225.00,
                        FlowLinePressure = (decimal)1862.00,
                        ChokeSize = (decimal)64.00,
                        Comment = "PCPWellTest_Comment_Check",

                    };

                    testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                    // add wellTest with new non RRL properties
                    WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                    WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                    WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                    WellTestDTO latestTestData_PCP = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

                    Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_PCP.Status.ToString(), "Well Test Status is not Success");

                }

                #endregion PCP

            }

        }

        /// <summary>
        /// Tests for: Use Model L Factor for Acceptance Limit Referencefrom model file = "True" in System setting in toolbox
        ///  If Use Model L Factor for Acceptance Limit Reference is enabled (set to True), 
        ///  the L Factor from the model file is used as the base value.
        /// </summary>

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void LFactorDefaultFlagIsTrueForAcceptanceLimit_NonRRL()
        {
            SetValuesInSystemSettings(SettingServiceStringConstants.MODEL_LFACTOR, "1");

            try
            {
                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = {
             Tuple.Create("WellfloESPExample1_lessthan1_Lfactor.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("WellfloWaterInjectionExample1.wflx", WellTypeId.WInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
             Tuple.Create("GL_BlackOil.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR) } }),
             //Tuple.Create("WellfloGasInjectionExample1.wflx", WellTypeId.GInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.ReservoirPressure, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
              Tuple.Create("PCP-SinglePhase.wflx", WellTypeId.PCP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.UpdateGOR_CGR) } }),

            };
                foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
                {
                    int i = 1;
                    string model = modelInfo.Item1;
                    WellTypeId wellType = modelInfo.Item2;
                    ModelFileOptionDTO options = modelInfo.Item3;

                    Trace.WriteLine("Testing model: " + model);
                    //Create a new well
                    WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = DateTime.Today.AddYears(-2), WellType = wellType }) });
                    var allWells = WellService.GetAllWells().ToList();
                    WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                    Assert.IsNotNull(well);
                    _wellsToRemove.Add(well);

                    ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                    options.Comment = "CASETest Upload " + modelInfo.Item1;
                    modelFile.Options = options;
                    modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(i);
                    modelFile.WellId = well.Id;

                    byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                    Assert.IsNotNull(fileAsByteArray);
                    modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                    Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                    ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
                    Assert.IsNotNull(ModelFileValidationData);
                    ModelFileService.AddWellModelFile(modelFile);
                    ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                    Assert.IsNotNull(newModelFile);
                    _modelFilesToRemove.Add(newModelFile.Id.ToString());

                    #region ESP

                    if (wellType == WellTypeId.ESP)
                    {
                        //add new wellTestData
                        WellTestDTO testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCode = 0,
                            SPTCodeDescription = "AllocatableTest",
                            AverageTubingPressure = 200,
                            //AverageTubingTemperature = 200,
                            GaugePressure = 104,
                            Oil = (decimal)2501.80,
                            Gas = 1250,
                            Water = (decimal)3752.60,
                            ChokeSize = 64,
                            Frequency = 70,

                        };

                        testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                        // add wellTest with new non RRL properties
                        WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                        WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                        WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                        WellTestDTO latestTestData_ESP = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());

                        Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_ESP.Status.ToString(), "Well Test Status is not Success");
                    }

                    #endregion ESP

                    #region WaterInjection

                    else if (wellType == WellTypeId.WInj)
                    {
                        //add new wellTestData
                        WellTestDTO testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCode = 0,
                            SPTCodeDescription = "AllocatableTest",
                            AverageTubingPressure = (decimal)3514.7,
                            AverageTubingTemperature = 65,
                            PumpIntakePressure = 10000,
                            PumpDischargePressure = 11000,
                            GaugePressure = 12000,
                            Water = (decimal)6932.80,
                            ChokeSize = 60,
                            FlowLinePressure = 50,
                        };

                        testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                        // add wellTest with new non RRL properties
                        WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                        WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                        WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                        WellTestDTO latestTestData_WI = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
                        Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_WI.Status.ToString(), "Well Test Status is not Success");
                    }

                    #endregion WaterInjection

                    #region GasLift

                    else if (wellType == WellTypeId.GLift)
                    {
                        //add new wellTestData
                        WellTestDTO testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCode = 0,
                            SPTCodeDescription = "AllocatableTest",
                            AverageTubingPressure = 96,
                            AverageTubingTemperature = 100,
                            AverageCasingPressure = 1000,
                            GasInjectionRate = 1000,
                            FlowLinePressure = 50,
                            SeparatorPressure = 30,
                            GaugePressure = 12000,
                            Oil = (decimal)599.00,
                            Gas = 1020,
                            Water = (decimal)732.2,
                            ChokeSize = 50,
                        };

                        testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                        WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                        WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                        WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                        WellTestDTO latestTestData_GL = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
                        Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_GL.Status.ToString(), "Well Test Status is not Success");
                    }

                    #endregion GasLift

                    #region NF

                    else if (wellType == WellTypeId.NF)
                    {
                        //add new wellTestData
                        WellTestDTO testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCode = 2,
                            SPTCodeDescription = "RepresentativeTest",
                            AverageTubingPressure = (decimal)164.7,
                            AverageTubingTemperature = 80,
                            //GaugePressure = 12000,
                            Oil = (decimal)1768.00,
                            Gas = 880,
                            Water = (decimal)589.30,
                            ChokeSize = 50,
                            FlowLinePressure = 50,
                            SeparatorPressure = 10000,
                        };

                        testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                        WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                        WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                        WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                        WellTestDTO latestTestData_NF = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
                        Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_NF.Status.ToString(), "Well Test Status is not Success");
                    }

                    #endregion NF
                    #region PCP

                    if (wellType == WellTypeId.PCP)
                    {
                        //add new wellTestData
                        WellTestDTO testDataDTO = new WellTestDTO()
                        {
                            WellId = well.Id,
                            SPTCodeDescription = "Allocatable Test",
                            TestDuration = 24,
                            Oil = (decimal)210.2,
                            Water = (decimal)140.2,
                            AverageTubingPressure = (decimal)100.00,
                            AverageTubingTemperature = (decimal)80.00,
                            PumpSpeed = (decimal)225.00,
                            FlowLinePressure = (decimal)1862.00,
                            ChokeSize = (decimal)64.00,
                            Comment = "PCPWellTest_Comment_Check",
                        };

                        testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());
                        // add wellTest with new non RRL properties
                        WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                        WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

                        WellTestDTO[] allTunedAgainTests = WellTestDataService.GetAllValidWellTestByWellId(well.Id.ToString());

                        WellTestDTO latestTestData_PCP = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
                        Assert.AreEqual("TUNING_SUCCEEDED", latestTestData_PCP.Status.ToString(), "Well Test Status is not Success");
                    }

                }

            }
            #endregion PCP
            finally
            {
                SetValuesInSystemSettings(SettingServiceStringConstants.MODEL_LFACTOR, "0");
            }

        }


        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetLatestValidWellTestInfoByWellIds()
        {
            WellDTO well = new WellDTO();
            try
            {
                // Set system to US units
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");

                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = { Tuple.Create("WellfloGasLiftExample1.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
                Tuple.Create("WellfloGasInjectionExample1.wflx", WellTypeId.GInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
                Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } }),
                Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
                Tuple.Create("WellfloWaterInjectionExample1.wflx", WellTypeId.WInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
                Tuple.Create("PCP-Multiphase.wflx", WellTypeId.PCP, new ModelFileOptionDTO() { CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.UpdateGOR_CGR) } }) };
                foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
                {
                    string model = modelInfo.Item1;
                    WellTypeId wellType = modelInfo.Item2;
                    ModelFileOptionDTO options = modelInfo.Item3;

                    Trace.WriteLine("Testing model: " + model);

                    #region creating Well
                    //Create a new well
                    WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), AssemblyAPI = DefaultWellName + wellType.ToString(), SubAssemblyAPI = DefaultWellName + wellType.ToString(), IntervalAPI = DefaultWellName + wellType.ToString(), WellType = wellType, WellStatusId = 2, WellDepthDatumId = 2, WellDepthDatumElevation = 2, WellGroundElevation = 1 }) });
                    var allWells = WellService.GetAllWells().ToList();
                    well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                    Assert.IsNotNull(well);
                    #endregion creating Well

                    #region importing model file
                    ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                    options.Comment = "CASETest Upload " + modelInfo.Item1;
                    modelFile.Options = options;
                    modelFile.ApplicableDate = well.CommissionDate.Value.AddDays(1).ToUniversalTime();
                    modelFile.WellId = well.Id;

                    byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                    Assert.IsNotNull(fileAsByteArray);

                    modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                    Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                    ModelFileService.AddWellModelFile(modelFile);
                    ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                    _modelFilesToRemove.Add(newModelFile.Id.ToString());
                    CommonModelConfigDTO commonModelConfig = ModelFileService.GetCommonModelConfig(well.Id.ToString());
                    Assert.IsNotNull(commonModelConfig);
                    ModelFileOptionDTO ReturnedOptions = newModelFile.Options;
                    Assert.AreEqual(options.CalibrationMethod, ReturnedOptions.CalibrationMethod);
                    Assert.AreEqual(options.OptionalUpdate.Length, ReturnedOptions.OptionalUpdate.Length);
                    Assert.AreEqual(well.Id.ToString(), commonModelConfig.WellId);
                    #endregion importing model file

                    int i = 0;

                    if (wellType == WellTypeId.NF)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 1000,
                                AverageTubingTemperature = 80.3m,
                                GaugePressure = 5800,
                                Oil = 50 + (i * 50),
                                Gas = 50,
                                Water = 35,
                                ChokeSize = 360,
                                FlowLinePressure = 800,
                                FlowLineTemperature = 67.3m,
                                SeparatorPressure = 500,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_NFW = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_NFW = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_NFW);
                    }
                    else if (wellType == WellTypeId.ESP)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 1795,
                                AverageTubingTemperature = 100,
                                AverageCasingPressure = 2600,
                                GaugePressure = 5800,
                                PumpIntakePressure = 2674,
                                PumpDischargePressure = 3067.59m,
                                Oil = 1157 + (i * 50),
                                Gas = 596,
                                Water = 1367,
                                ChokeSize = 360,
                                FlowLinePressure = 1300,
                                FlowLineTemperature = 67.3m,
                                SeparatorPressure = 987,
                                Frequency = 60,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_ESP = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_ESP = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_ESP);
                    }
                    else if (wellType == WellTypeId.GLift)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 1600,
                                AverageTubingTemperature = 100,
                                AverageCasingPressure = 2249.50m,
                                GaugePressure = 5800,
                                Oil = 321 + (i * 100),
                                Gas = 320,
                                GasInjectionRate = 0,
                                Water = 2790.1m,
                                ChokeSize = 360,
                                FlowLinePressure = 1500,
                                FlowLineTemperature = 67.3m,
                                SeparatorPressure = 500,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_GL = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_GL = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_GL);
                    }
                    else if (wellType == WellTypeId.GInj)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 1514,
                                AverageTubingTemperature = 85.3m,
                                GaugePressure = random.Next(500, 1900),
                                Gas = 250 + (i * 50),
                                FlowLinePressure = 800,
                                FlowLineTemperature = 67.3m,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_GASInj = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_GASInj = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_GASInj);
                    }
                    else if (wellType == WellTypeId.WInj)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 2000,
                                AverageTubingTemperature = 50,
                                GaugePressure = 1500,
                                Water = 900,
                                FlowLinePressure = 800,
                                FlowLineTemperature = 50,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_WATERInj = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_WATERInj = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_WATERInj);
                    }
                    else if (wellType == WellTypeId.PCP)
                    {
                        AddWellSettingWithDoubleValues(well.Id, "Min L Factor Acceptance Limit", 0.1);
                        AddWellSettingWithDoubleValues(well.Id, "Max L Factor Acceptance Limit", 2.0);
                        AddWellSettingWithDoubleValues(well.Id, "Min Water Cut Acceptance Limit", 0.1);
                        AddWellSettingWithDoubleValues(well.Id, "Max Water Cut Acceptance Limit", 1.0);
                        AddWellSettingWithDoubleValues(well.Id, "Min GOR Acceptance Limit", 1.0);
                        AddWellSettingWithDoubleValues(well.Id, "Max GOR Acceptance Limit", 50.0);
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                Oil = (decimal)210.2,
                                Water = (decimal)141.2,
                                Gas = (decimal)8.40 + (i * 2),
                                AverageTubingPressure = (decimal)100.00,
                                AverageTubingTemperature = (decimal)80.00,
                                GaugePressure = (decimal)423.00,
                                AverageCasingPressure = (decimal)45.23,
                                PumpIntakePressure = (decimal)161.19,
                                PumpDischargePressure = (decimal)2130.69,
                                PolishedRodTorque = (decimal)361.35,
                                PumpTorque = (decimal)185.23,
                                PumpSpeed = (decimal)225.00,
                                FlowLinePressure = (decimal)1862.00,
                                FlowLineTemperature = (decimal)80.00,
                                SeparatorPressure = (decimal)1523.00,
                                ChokeSize = (decimal)64.00,
                                Comment = "Test Record" + " " + (i + 1),
                                MotorCurrent = (decimal)180.0,
                                MotorVolts = (decimal)230.0
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_PCP = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_PCP = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_PCP);
                    }
                }

                //Veryfying latest valid well test info
                var allWellsList = WellService.GetAllWells();
                List<long> allwellsidList = new List<long>();
                foreach (var individualWell in allWellsList)
                {
                    allwellsidList.Add(individualWell.Id);
                }
                var latestWellTestwithId = WellTestDataService.GetLatestValidWellTestInfoByWellIds(allwellsidList);


                foreach (long wellid in latestWellTestwithId.Keys)
                {
                    Assert.AreEqual("TUNING_SUCCEEDED", latestWellTestwithId[wellid].Value.Status.ToString(), "Mismatch in tunning status");

                    WellDTO wellname = WellService.GetWellsByIds(new long[] { wellid })[0];
                    Trace.WriteLine($"Received latest valid well test record for well :- {wellname.Name}");
                }
                Assert.IsNotNull(latestWellTestwithId);
            }
            finally
            {
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                var GetAllWells = WellService.GetAllWells();
                foreach (var individualWell in GetAllWells)
                {
                    _wellsToRemove.Add(individualWell);
                }
            }
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ApplySensitivitiesForESP_GOR()
        {
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            string FileName = "ESP_Analysis_Json_test_US.json";
            // This is the path to the  ESP example well model in the codebase.
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP,
                new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.LFactor,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        //(long) OptionalUpdates.CalculateChokeD_Factor
                    }
                });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = "ESPTestWell3" + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            WellDTO well = WellService.GetWellByName("ESPTestWell3" + wellType.ToString());
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO();

            options.Comment = "Testing 1 - 2 - 3 ..." + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File is not an ESP model file.");
            ModelFileValidationDataDTO modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(modelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());
            // NOTE: If you change anything in the following well test, it is very likely that this integration test will fail
            //       because the comparisons we do after the analysis assume that this well test was used for the analysis.
            WellTestDTO testDTO = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "AllocatableTest",
                AverageTubingPressure = 1795,
                AverageCasingPressure = 0,
                AverageTubingTemperature = 100,
                PumpIntakePressure = 2674,
                //PumpDischargePressure = 3067.59m,
                //GaugePressure = 2900,
                Oil = 1157,
                Gas = 596,
                Water = 1367,
                ChokeSize = 64,
                FlowLinePressure = 1300,
                SeparatorPressure = 987,
                Frequency = 57,
                SampleDate = DateTime.Today.ToUniversalTime()
            };

            // Add the well test record to the database.
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDTO));
            //for tunning
            WellTestDTO latestTestData_ESP = WellTestDataService.GetLatestWellTestDataByWellId(well.Id.ToString());
            WellTestDataService.TuneSelectedWellTests(new long[] { latestTestData_ESP.Id });
            //get the newly added (latest) well test data
            var latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            // Add Formation GOR Sensitivities to ESP Well
            WellSensitivityDTO wellSensitivitydto = new WellSensitivityDTO
            {
                WellId = well.Id,
                SensitivityType = SensitivityQuantity.FormationGOR,
                DoubleValue = new double[] { 7.5, 1000 }
            };
            string sensitivityGOR = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
            Assert.AreEqual("1", sensitivityGOR, "The Sensitivity Added successfully in DB.");

            var glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            NodalAnalysisSensitivitiesDTO analysisInputWithSensitivities = new NodalAnalysisSensitivitiesDTO();
            analysisInputWithSensitivities.analysisInputs = glAnalysisInput;
            analysisInputWithSensitivities.curveType = 1;
            analysisInputWithSensitivities.sensitivities = wellSensitivitydto;

            // Run the ESP analysis
            ESPAnalysisResultsAndUnitsDTO[] analysisResult = WellTestDataService.PerformESPAnalysisWithSensitivities(analysisInputWithSensitivities);
            Assert.IsNotNull(analysisResult, "ESP Analyis failed to return results");
            //AnalysisResultsAndUnitsDTO[] actualCurveDTO = WellTestDataService.PerformAnalysisWithSensitivities(analysisInputWithSensitivities);
            Trace.WriteLine("Curves Retrieved");

            #region US Unit Verification

            //Reading expected Gradient & Velocity Curve DTO from Json File            
            ESPAnalysisResultsAndUnitsDTO[] expectedCurveDTO = JsonConvert.DeserializeObject<ESPAnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));

            // One time Activity to generate JSON file. Not required for Integration test.
            var json = analysisResult.GetJsonStringFromObject();

            Assert.AreEqual(expectedCurveDTO.Count(), analysisResult.Count(), "Number of Sensitivities and number of Curve Sets retrieved are not matching");

            for (int i = 0; i < analysisResult.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyVelocityCurve(expectedCurveDTO[i].PressureDropResults.GasVelocityCurves, analysisResult[i].PressureDropResults.GasVelocityCurves, wellType);
                Trace.WriteLine("Velocity curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }
            Trace.WriteLine("Verification in US Unit completed");
            #endregion

            //Deleting Sensitivity
            bool IsDeleted = WellService.RemoveWellSensitivityConfiguration(well.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.FormationGOR)));
            Assert.IsTrue(IsDeleted, "The ErosionCoefficient Sensitivity not deleted successfully.");
            #region Metric Unit Verification

            //Now verifying in Metric Unit Sysem
            ChangeUnitSystem("Metric");
            ChangeUnitSystemUserSetting("Metric");
            Trace.WriteLine("System set for Metric unit system");

            FileName = "ESP_Analysis_Json_test_Metric.json";

            //get the newly added (latest) well test data
            latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTestDataPair);

            // Add TubingHeadPressure Sensitivities to NF Well
            wellSensitivitydto = new WellSensitivityDTO
            {
                WellId = well.Id,
                SensitivityType = SensitivityQuantity.FormationGOR,
                DoubleValue = new double[] { 7.5, 1000 }
            };
            sensitivityGOR = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
            Assert.AreEqual("1", sensitivityGOR, "The Sensitivity Added successfully in DB.");

            glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            analysisInputWithSensitivities = new NodalAnalysisSensitivitiesDTO();
            analysisInputWithSensitivities.analysisInputs = glAnalysisInput;
            analysisInputWithSensitivities.curveType = 1;
            analysisInputWithSensitivities.sensitivities = wellSensitivitydto;

            // Run the ESP analysis
            ESPAnalysisResultsAndUnitsDTO[] analysisResult_METRIC = WellTestDataService.PerformESPAnalysisWithSensitivities(analysisInputWithSensitivities);
            Assert.IsNotNull(analysisResult_METRIC, "ESP Analyis failed to return results");
            Trace.WriteLine("Curves Retrieved");

            ESPAnalysisResultsAndUnitsDTO[] expectedCurveDTO_Metric = JsonConvert.DeserializeObject<ESPAnalysisResultsAndUnitsDTO[]>(GetJsonString(Path + FileName));

            Assert.AreEqual(expectedCurveDTO_Metric.Count(), analysisResult_METRIC.Count(), "Number of Sensitivities and number of Curve Sets retrieved are not matching");

            for (int i = 0; i < analysisResult_METRIC.Count(); i++)
            {
                Trace.WriteLine("");
                VerifyVelocityCurve(expectedCurveDTO_Metric[i].PressureDropResults.GasVelocityCurves, analysisResult_METRIC[i].PressureDropResults.GasVelocityCurves, wellType);
                Trace.WriteLine("Velocity curve verification completed for sensitivity " + (i + 1));
                Trace.WriteLine("");
            }
            Trace.WriteLine("Verification in Metric Unit completed");
            #endregion
        }


        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PerformPlungerLiftAnalysisTest()
        {
            var modelFileName = "PL-631.wflx";
            WellTypeId wellType = WellTypeId.PLift;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("PGLWELL_", wellType, WellFluidType.DryGas, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                MaximumCasingPressure = 210,
                MinimumCasingPressure = 210,
                MaximumTubingPressure = 160,
                MinimumTubingPressure = 160,
                FlowLinePressure = 160,
                FlowLineTemperature = 400,
                BuildTime = 11,
                AfterFlowTime = 38,
                FallTime = 30,
                RiseTime = 75,
                CycleGasVolume = 10,
                CycleWaterVolume = 1,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testData));


            // Get it back out and use it to load the analysis inputs (?)
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());

            var dailyAverage = new WellDailyAverageValueDTO()
            {
                OilRateInferred = (double?)latestValidTestDataPair.Value.Oil,
                WaterRateInferred = (double?)latestValidTestDataPair.Value.Water,
                GasRateInferred = (double?)latestValidTestDataPair.Value.Gas,
                Status = WellDailyAverageDataStatus.Calculated,
                ChokeDiameter = (double?)latestValidTestDataPair.Value.ChokeSize,
                CHP = (double)(latestValidTestDataPair.Value.AverageCasingPressure ?? 0),
                DHPG = (double?)latestValidTestDataPair.Value.GaugePressure,
                Duration = null,
                EndDateTime = latestValidTestDataPair.Value.SampleDate.AddDays(1),
                StartDateTime = latestValidTestDataPair.Value.SampleDate,
                WellId = well.Id,
                WellTestId = latestValidTestDataPair.Value.Id,
            };
            bool result = SurveillanceService.AddUpdateWellDailyAverageData(dailyAverage);
            Assert.IsTrue(result, "Adding daily average record failed.");
            var dailyAverageRecord = SurveillanceService.GetDailyAverages(well.Id.ToString(), (DateTime.Today - TimeSpan.FromDays(30)).ToUniversalTime().ToISO8601(), (DateTime.Today + TimeSpan.FromDays(1)).ToUniversalTime().ToISO8601()).Values.FirstOrDefault();
            Assert.IsNotNull(dailyAverageRecord);
            var record_id = dailyAverageRecord.Id;
            NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            Assert.IsNotNull(analysisInput, "Failed to get analysis input with the provided test data");
            Assert.IsNotNull(analysisInput.CalibrationData, "Calibration data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.ModelData, "Model data is not available in the analysis input");
            Assert.IsNotNull(analysisInput.TestData, "Test data is not available in the analysis input");

            Assert.IsNotNull(analysisInput.ModelData.SolutionNode, "Solution node is not available in the model data");
            Assert.IsNotNull(analysisInput.ModelData.StartNode, "Start node is not available in the modal data");
            Assert.AreNotEqual(analysisInput.ModelData.SolutionNode.Value.Name, analysisInput.ModelData.StartNode.Value.Name, "Start and solution node cannot be the same");
            Assert.AreEqual(5, analysisInput.ModelData.SolutionNodes.Values[0].Id, "Incorrect number of solution nodes are available in analysis input modal data");
            Assert.AreEqual(3, analysisInput.ModelData.StartNodes.Values[0].Id, "Incorrect number of start nodes are available in analysis input modal data");

            Assert.IsNotNull(analysisInput.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ProductivityIndex, "Productivity index is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");
            Assert.IsNotNull(analysisInput.CalibrationData.Value.DarcyFlowCoeff, "DarcyFlowCoeff is not defined in the calibration data");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageCasingPressure ?? 0, 3), (decimal)Math.Round(analysisInput.TestData.Value.CasingHeadPressure, 3), "Mismatch between the provided average casing pressure value and the analysis input test value");
            Assert.AreEqual((latestValidTestDataPair.Value.GaugePressure.HasValue ? Math.Round(latestValidTestDataPair.Value.GaugePressure.Value, 3) : 0m), (decimal)Math.Round(analysisInput.TestData.Value.DownholeGaugePressure, 3), "Mismatch between the provided gauge pressure value and analysis input test value");

            // Run the PCP analysis
            PlungerLiftAnalysisResultsAndUnitsDTO actual_analysisResult = WellTestDataService.PerformPlungerLiftAnalysis(analysisInput);

            Assert.IsNotNull(actual_analysisResult);
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults, "Unable to get Operating point results after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.FlowCurves, "Unable to get Flow curves after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.OperatingPoint, "Unable to get Operating point after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.OperatingPoint.Value.GasRate);
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.OperatingPoint.Value.OilRate);
            Assert.IsNotNull(actual_analysisResult.OperatingPointResults.OperatingPoint.Value.WaterRate);
            Assert.IsNotNull(actual_analysisResult.PressureDropResults, "Unable to get Pressure drop results after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.PressureDropResults.SolutionPoint, "Unable to get Solution point results after PCP Analysis");
            //Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.Oil), actual_analysisResult.PressureDropResults.SolutionPoint.Value.OilRate, 0.5);
            //Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.GOR), Math.Round(actual_analysisResult.PressureDropResults.SolutionPoint.Value.ProducedGOR), 0.5);
            Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.WaterCut), actual_analysisResult.PressureDropResults.SolutionPoint.Value.WaterCut, 0.05);
            // Assert.AreEqual(Convert.ToDouble(latestValidTestDataPair.Value.Water), actual_analysisResult.PressureDropResults.SolutionPoint.Value.WaterRate, 0.5);

            Assert.IsNotNull(actual_analysisResult.PressureDropResults.GradientCurves, "Unable to get gradient curves after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves, "Unable to get gradient curve points after PCP Analysis");
            //Assert.AreEqual(Convert.ToDouble(analysisInput.ModelData.SolutionNode.Value.MD), Math.Round(actual_analysisResult.PressureDropResults.GradientCurves.MaximumMD), 0.5);

            Assert.IsNotNull(actual_analysisResult.PressureDropResults.GasVelocityCurves, "Unable to get GasVelocityCurves after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.PressureDropResults.GasVelocityCurves, "Unable to get GasVelocityCurves after PCP Analysis");
            Assert.IsNotNull(actual_analysisResult.PressureDropResults.SolutionPoint, "Unable to get SolutionPoint after PCP Analysis");

            // string jsonstring1 = JsonConvert.SerializeObject(actual_analysisResult);
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
            string FileName = "Plunger_Analysis_Json_test_US.json";

            PlungerLiftAnalysisResultsAndUnitsDTO expected_analysisResult = JsonConvert.DeserializeObject<PlungerLiftAnalysisResultsAndUnitsDTO>(GetJsonString(Path + FileName));

            CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.FlowCurves.Units, actual_analysisResult.OperatingPointResults.FlowCurves.Units, "Units not matching for Flow Curve");

            for (int i = 0; i < actual_analysisResult.OperatingPointResults.FlowCurves.Values.Count(); i++)

            {
                CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.FlowCurves.Values[i], actual_analysisResult.OperatingPointResults.FlowCurves.Values[i], "Mismatch at element " + i, null, 0.5);
            }

            Trace.WriteLine("Verification completed for Flow Curve");
            CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.GasVelocityCurves.GasVelocityCurves.Units, actual_analysisResult.OperatingPointResults.GasVelocityCurves.GasVelocityCurves.Units, "Units not matching for GasVelocityCurves");


            for (int i = 0; i < actual_analysisResult.OperatingPointResults.GasVelocityCurves.GasVelocityCurves.Values.Count(); i++)

            {
                CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.GasVelocityCurves.GasVelocityCurves.Values[i], actual_analysisResult.OperatingPointResults.GasVelocityCurves.GasVelocityCurves.Values[i], "Mismatch at element " + i, null, 0.5);
            }
            CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.MaximumFlowRate, actual_analysisResult.OperatingPointResults.MaximumFlowRate, "MaximumFlowRate value is Mismatch");
            CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.MaximumGasRate, actual_analysisResult.OperatingPointResults.MaximumGasRate, "MaximumGasRate value is Mismatch");
            CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.MaximumOilRate, actual_analysisResult.OperatingPointResults.MaximumOilRate, "MaximumOilRate value is Mismatch");
            CompareObjectsUsingReflection(expected_analysisResult.OperatingPointResults.MaximumPressure, actual_analysisResult.OperatingPointResults.MaximumPressure, "MaximumPressure value is Mismatch");


            CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Units, actual_analysisResult.PressureDropResults.GradientCurves.DepthLines.Units, "Units not matching for GradientCurves");

            CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value, actual_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value, "Mismatch at element ", null, 0.5);

            Trace.WriteLine("Verification completed for Gradient Curve");

            Assert.AreEqual(expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.DownholeGaugeMD, actual_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.DownholeGaugeMD, "DownholeGaugeMD Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.DownholeGaugeTVD, expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.DownholeGaugeTVD, "DownholeGaugeTVD Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.InjectionMD, expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.InjectionMD, "InjectionMD Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.InjectionTVD, expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.InjectionTVD, "InjectionTVD Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.LayerMD, expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.LayerMD, "LayerMD Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.LayerTVD, expected_analysisResult.PressureDropResults.GradientCurves.DepthLines.Value.LayerTVD, "LayerTVD Mismatch");

            CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Units, actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Units, "Units not matching for GradientCurves");

            for (int i = 0; i < actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Values.Count(); i++)

            {
                CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i], actual_analysisResult.PressureDropResults.GradientCurves.GradientCurves.Values[i], "Mismatch at element " + i, null, 0.5);
            }

            CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.SolutionPoint.Units, actual_analysisResult.PressureDropResults.SolutionPoint.Units, "Units not matching for SolutionPoint ");

            CompareObjectsUsingReflection(expected_analysisResult.PressureDropResults.SolutionPoint.Value, actual_analysisResult.PressureDropResults.SolutionPoint.Value, "Mismatch at element ", null, 0.5);
            Trace.WriteLine("Verification completed for SolutionPoint");

            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.AfterflowTime, actual_analysisResult.PressureDropResults.SolutionPoint.Value.AfterflowTime, "AfterflowTime Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.BottomholePressure, actual_analysisResult.PressureDropResults.SolutionPoint.Value.BottomholePressure, "BottomholePressure Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.BubblePointPressure, actual_analysisResult.PressureDropResults.SolutionPoint.Value.BubblePointPressure, "BubblePointPressure Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.BuildUpTime, actual_analysisResult.PressureDropResults.SolutionPoint.Value.BuildUpTime, "BuildUpTime Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.GasRate, actual_analysisResult.PressureDropResults.SolutionPoint.Value.GasRate, "GasRate Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.IPRFlowRate, actual_analysisResult.PressureDropResults.SolutionPoint.Value.IPRFlowRate, "IPRFlowRate Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.IPRGasRate, actual_analysisResult.PressureDropResults.SolutionPoint.Value.IPRGasRate, "IPRGasRate Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.NecessaryCyclesPerDay, actual_analysisResult.PressureDropResults.SolutionPoint.Value.NecessaryCyclesPerDay, "NecessaryCyclesPerDay Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.OilRate, actual_analysisResult.PressureDropResults.SolutionPoint.Value.OilRate, "OilRate Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.OperatingPointStability, actual_analysisResult.PressureDropResults.SolutionPoint.Value.OperatingPointStability, "OperatingPointStability Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.OperatingPointStatus, actual_analysisResult.PressureDropResults.SolutionPoint.Value.OperatingPointStatus, "OperatingPointStatus Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.Pressure, actual_analysisResult.PressureDropResults.SolutionPoint.Value.Pressure, "Pressure Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.ProducedCGR, actual_analysisResult.PressureDropResults.SolutionPoint.Value.ProducedCGR, "ProducedCGR Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.ProducedGLR, actual_analysisResult.PressureDropResults.SolutionPoint.Value.ProducedGLR, "ProducedGLR Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.ProducedGOR, actual_analysisResult.PressureDropResults.SolutionPoint.Value.ProducedGOR, "ProducedGOR Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.Temperature, actual_analysisResult.PressureDropResults.SolutionPoint.Value.Temperature, "Temperature Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.WaterCut, actual_analysisResult.PressureDropResults.SolutionPoint.Value.WaterCut, "WaterCut Mismatch");
            Assert.AreEqual(expected_analysisResult.PressureDropResults.SolutionPoint.Value.WaterRate, actual_analysisResult.PressureDropResults.SolutionPoint.Value.WaterRate, "WaterRate Mismatch");


        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetWellTestTrendByDateRangeNewTest()
        {
            WellDTO well = new WellDTO();
            try
            {
                // Set system to US units
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
                Trace.WriteLine("System set for US unit system");

                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                Tuple<string, WellTypeId, ModelFileOptionDTO>[] models = { Tuple.Create("WellfloGasLiftExample1.wflx", WellTypeId.GLift, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
                Tuple.Create("WellfloGasInjectionExample1.wflx", WellTypeId.GInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }),
                Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.PumpWearFactor) } }),
                Tuple.Create("WellfloNFWExample1.wflx", WellTypeId.NF, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR), ((long)OptionalUpdates.CalculateChokeD_Factor) } }),
                Tuple.Create("WellfloWaterInjectionExample1.wflx", WellTypeId.WInj, new ModelFileOptionDTO(){ CalibrationMethod = CalibrationMethodId.LFactor, OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateGOR_CGR), ((long)OptionalUpdates.UpdateWCT_WGR) } }) };

                foreach (Tuple<string, WellTypeId, ModelFileOptionDTO> modelInfo in models)
                {
                    string model = modelInfo.Item1;
                    WellTypeId wellType = modelInfo.Item2;
                    ModelFileOptionDTO options = modelInfo.Item3;

                    Trace.WriteLine("Testing model: " + model);

                    #region creating Well
                    //Create a new well
                    WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), AssemblyAPI = DefaultWellName + wellType.ToString(), SubAssemblyAPI = DefaultWellName + wellType.ToString(), IntervalAPI = DefaultWellName + wellType.ToString(), WellType = wellType, WellStatusId = 2, WellDepthDatumId = 2, WellDepthDatumElevation = 2, WellGroundElevation = 1 }) });
                    var allWells = WellService.GetAllWells().ToList();
                    well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
                    Assert.IsNotNull(well);
                    _wellsToRemove.Add(well);
                    #endregion creating Well

                    #region importing model file
                    ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

                    options.Comment = "CASETest Upload " + modelInfo.Item1;
                    modelFile.Options = options;
                    modelFile.ApplicableDate = well.CommissionDate.Value.AddDays(1).ToUniversalTime();
                    modelFile.WellId = well.Id;

                    byte[] fileAsByteArray = GetByteArray(Path, modelInfo.Item1);
                    Assert.IsNotNull(fileAsByteArray);

                    modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
                    Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");
                    ModelFileService.AddWellModelFile(modelFile);
                    ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
                    _modelFilesToRemove.Add(newModelFile.Id.ToString());
                    CommonModelConfigDTO commonModelConfig = ModelFileService.GetCommonModelConfig(well.Id.ToString());
                    Assert.IsNotNull(commonModelConfig);
                    ModelFileOptionDTO ReturnedOptions = newModelFile.Options;
                    Assert.AreEqual(options.CalibrationMethod, ReturnedOptions.CalibrationMethod);
                    Assert.AreEqual(options.OptionalUpdate.Length, ReturnedOptions.OptionalUpdate.Length);
                    Assert.AreEqual(well.Id.ToString(), commonModelConfig.WellId);
                    #endregion importing model file

                    int i = 0;

                    if (wellType == WellTypeId.NF)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 1000,
                                AverageTubingTemperature = 80.3m,
                                GaugePressure = 5800,
                                Oil = 100 + (i * 2),
                                Gas = 50,
                                Water = 35,
                                ChokeSize = 360,
                                FlowLinePressure = 800,
                                FlowLineTemperature = 67.3m,
                                SeparatorPressure = 500,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_NFW = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_NFW = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_NFW);
                    }
                    else if (wellType == WellTypeId.ESP)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 1795,
                                AverageTubingTemperature = 100,
                                AverageCasingPressure = 2600,
                                GaugePressure = 5800,
                                PumpIntakePressure = 2674,
                                PumpDischargePressure = 3067.59m,
                                Oil = 1157 + (i * 2),
                                Gas = 596,
                                Water = 1367,
                                ChokeSize = 360,
                                FlowLinePressure = 1300,
                                FlowLineTemperature = 67.3m,
                                SeparatorPressure = 987,
                                Frequency = 60,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_ESP = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_ESP = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_ESP);
                    }
                    else if (wellType == WellTypeId.GLift)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 1600,
                                AverageTubingTemperature = 100,
                                AverageCasingPressure = 2249.50m,
                                GaugePressure = 5800,
                                Oil = 521 + (i * 2),
                                Gas = 320,
                                GasInjectionRate = 0,
                                Water = 2790.1m,
                                ChokeSize = 360,
                                FlowLinePressure = 1500,
                                FlowLineTemperature = 67.3m,
                                SeparatorPressure = 500,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_GL = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_GL = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_GL);
                    }
                    else if (wellType == WellTypeId.GInj)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 1514,
                                AverageTubingTemperature = 85.3m,
                                GaugePressure = random.Next(500, 1900),
                                Gas = 250 + (i * 2),
                                FlowLinePressure = 800,
                                FlowLineTemperature = 67.3m,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_GASInj = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_GASInj = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_GASInj);
                    }
                    else if (wellType == WellTypeId.WInj)
                    {
                        for (i = 0; i < 3; i++)
                        {
                            WellTestDTO testDataDTO = new WellTestDTO()
                            {
                                WellId = well.Id,
                                SPTCodeDescription = "AllocatableTest",
                                TestDuration = 24,
                                AverageTubingPressure = 2000,
                                AverageTubingTemperature = 50,
                                GaugePressure = 1500,
                                Water = 900,
                                FlowLinePressure = 800,
                                FlowLineTemperature = 50,
                                Comment = "Test Record" + " " + (i + 1),
                            };
                            testDataDTO.SampleDate = well.CommissionDate.Value.AddDays(2 + i).ToUniversalTime();
                            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
                            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
                        }
                        WellTestAndUnitsDTO WellTestDataandUnit_WATERInj = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
                        WellTestDTO WellTestData_WATERInj = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
                        Assert.IsNotNull(WellTestData_WATERInj);
                    }




                    var allWellsList = WellService.GetAllWells();
                    List<long> allwellsidList = new List<long>();
                    foreach (var individualWell in allWellsList)
                    {
                        allwellsidList.Add(individualWell.Id);
                    }
                    var latestWellTestwithId = WellTestDataService.GetLatestValidWellTestInfoByWellIds(allwellsidList);


                    foreach (long wellid in latestWellTestwithId.Keys)
                    {

                        Assert.AreEqual("TUNING_SUCCEEDED", latestWellTestwithId[wellid].Value.Status.ToString(), "Mismatch in tunning status");

                        WellDTO wellname = WellService.GetWellsByIds(new long[] { wellid })[0];
                        Trace.WriteLine($"Received latest valid well test record for well :- {wellname.Name}");
                        WellTestTrendList(latestWellTestwithId[wellid].Value.WellId.ToString(), wellname.Name);

                    }


                }

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }

        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void GetWellTestTrendByDateRangeNewPlungerlift()
        {
            var modelFileName = "PL-631.wflx";
            WellTypeId wellType = WellTypeId.PLift;
            var options = new ModelFileOptionDTO
            {
                CalibrationMethod = CalibrationMethodId.DarcyFlowCoefficient,
                OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateWCT_WGR
                    }
            };

            Trace.WriteLine("Testing model: " + modelFileName);

            WellDTO well = AddNonRRLWellGeneralTab("PGLWELL_", wellType, WellFluidType.DryGas, "N/A", "NA");
            AddNonRRLModelFile(well, modelFileName, options.CalibrationMethod, options.OptionalUpdate);
            Trace.WriteLine("Well Added Successfully");

            WellTestDTO testData = new WellTestDTO
            {
                WellId = well.Id,
                SPTCodeDescription = "RepresentativeTest",
                CalibrationMethod = options.CalibrationMethod,
                WellTestType = WellTestType.WellTest,
                MaximumCasingPressure = 210,
                MinimumCasingPressure = 210,
                MaximumTubingPressure = 160,
                MinimumTubingPressure = 160,
                FlowLinePressure = 160,
                FlowLineTemperature = 400,
                BuildTime = 11,
                AfterFlowTime = 38,
                FallTime = 30,
                RiseTime = 75,
                CycleGasVolume = 10,
                CycleWaterVolume = 1,
                TestDuration = 24,
                SampleDate = DateTime.Today.AddDays(-5).ToUniversalTime()
            };
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testData));


            // Get it back out and use it to load the analysis inputs (?)
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            WellTestDTO WellTestData_plunger = WellTestDataService.GetLatestValidWellTestByWellIdInternalUnits(well.Id.ToString());
            Assert.IsNotNull(WellTestData_plunger);

            WellTestTrendList(well.Id.ToString(), well.Name.ToString());
        }

        /// <summary>
        /// This test method is written for veryfying Plunger lift design API's - with / without Sensitivity
        /// </summary>
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void PlungerLiftDesignTest()
        {
            string facilityID = GetFacilityId("PGLWELL_", 1);
            ChangeUnitSystem("US");
            ChangeUnitSystemUserSetting("US");
            SurveillanceServiceTests surtest = new SurveillanceServiceTests();
            try
            {
                #region US Conversion

                #region Create PGL Well
                WellDTO PGLWell = AddNonRRLWell(facilityID, WellTypeId.PLift, false, CalibrationMethodId.None);
                Assert.IsNotNull(PGLWell);
                #endregion Create PGL Well

                #region Default PGL Design - without Sensitivity
                PlungerLiftDesignInputAndUnitsDTO getPGLDesignInputDataDefault_US = WellTestDataService.GetPlungerLiftDesignInputDataAndUnits(PGLWell.Id.ToString());
                Assert.IsNotNull(getPGLDesignInputDataDefault_US);
                Assert.AreEqual(11, getPGLDesignInputDataDefault_US.DesignParameters.Value.BuildUpTime, 0.1, "Mismatch In BuildUp Time");
                Assert.AreEqual(0, getPGLDesignInputDataDefault_US.DesignParameters.Value.OperatingAfterflowTime, 0.1, "Mismatch In After Flow Time");
                Assert.AreEqual(50, getPGLDesignInputDataDefault_US.DesignParameters.Value.DifferentialPressure, 0.1, "Mismatch In Differntial Pressure");
                Assert.AreEqual(50, getPGLDesignInputDataDefault_US.DesignParameters.Value.FlowingTubingHeadPressure, 0.1, "Mismatch In Tubing Head Pressure");
                Assert.AreEqual(35, getPGLDesignInputDataDefault_US.DesignParameters.Value.GasProductionRate, 0.1, "Mismatch In Produced Gas Rate");
                Assert.AreEqual(3.5, getPGLDesignInputDataDefault_US.DesignParameters.Value.LiquidProductionRate, 0.1, "Mismatch In Liquid Rate");
                Assert.AreEqual("Generic", getPGLDesignInputDataDefault_US.DesignParameters.Value.PlungerType, "Mismatch In Plunger Type");
                #endregion Default PGL Design - without Sensitivity

                #region Perform Default Plunger Design
                PlungerLiftDesignResultsAndUnitsDTO actualDefaultResult_US = WellTestDataService.PerformPlungerLiftDesign(getPGLDesignInputDataDefault_US);
                Assert.IsNotNull(actualDefaultResult_US);

                string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                string FileName = "PGLDefaultDesign_US.json";
                PlungerLiftDesignResultsAndUnitsDTO expectedDefaultResult_US = JsonConvert.DeserializeObject<PlungerLiftDesignResultsAndUnitsDTO>(GetJsonString(Path + FileName));

                //-----Veryfying Base Type Graph
                CompareObjectsUsingReflection(expectedDefaultResult_US.BaseTypeGraph.SurfaceTypeGraph.Units, actualDefaultResult_US.BaseTypeGraph.SurfaceTypeGraph.Units, "Mismatch in Base Type Graph Units");
                for (int i = 0; i < actualDefaultResult_US.BaseTypeGraph.SurfaceTypeGraph.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedDefaultResult_US.BaseTypeGraph.SurfaceTypeGraph.Values[i], actualDefaultResult_US.BaseTypeGraph.SurfaceTypeGraph.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Assert.AreEqual(600, actualDefaultResult_US.BaseTypeGraph.MaximumPressure, 0.02, "Mismatch in Maximum Pressure");
                Assert.AreEqual(1319.85, actualDefaultResult_US.BaseTypeGraph.MaximumRate, 0.02, "Mismatch in Maximum Rate");
                Assert.AreEqual(70.8, actualDefaultResult_US.BaseTypeGraph.MaximumVelocity, 0.02, "Mismatch in Maximum Velocity");

                Assert.AreEqual(14.65, actualDefaultResult_US.BaseTypeGraph.MinimumPressure, 0.02, "Mismatch in Minimum Pressure");
                Assert.AreEqual(28.15, actualDefaultResult_US.BaseTypeGraph.MinimumRate, 0.02, "Mismatch in Minimum Rate");
                Assert.AreEqual(10.31, actualDefaultResult_US.BaseTypeGraph.MinimumVelocity, 0.02, "Mismatch in Minimum Velocity");

                Trace.WriteLine("Verification completed for Base Type Graph");

                //-----Veryfying Base Plunger Cycle
                CompareObjectsUsingReflection(expectedDefaultResult_US.PlungerCycles.Units, actualDefaultResult_US.PlungerCycles.Units, "Mismatch in Plunger Cycle Units");
                for (int i = 0; i < actualDefaultResult_US.PlungerCycles.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedDefaultResult_US.PlungerCycles.Values[i], actualDefaultResult_US.PlungerCycles.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Trace.WriteLine("Verification completed for Plunger Cycle");

                //-----Veryfying Sensitivity Plots
                CompareObjectsUsingReflection(expectedDefaultResult_US.SensitivityPlots.SensitivityPlots.Units, actualDefaultResult_US.SensitivityPlots.SensitivityPlots.Units, "Mismatch in Sensitivity Plots Units");
                for (int i = 0; i < actualDefaultResult_US.SensitivityPlots.SensitivityPlots.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedDefaultResult_US.SensitivityPlots.SensitivityPlots.Values[i], actualDefaultResult_US.SensitivityPlots.SensitivityPlots.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Assert.AreEqual(72.86, actualDefaultResult_US.SensitivityPlots.MaximumCycleTime, 0.02, "Mismatch in Maximum Cycle Time");
                Assert.AreEqual(20, actualDefaultResult_US.SensitivityPlots.MaximumCyclesPerDay, 0.02, "Mismatch in Maximum Cycle Per Day");
                Assert.AreEqual(116.65, actualDefaultResult_US.SensitivityPlots.MaximumDailyGasRate, 0.02, "Mismatch in Maximum Daily Gas Rate");
                Assert.AreEqual(9.9, actualDefaultResult_US.SensitivityPlots.MaximumDailyLiquidRate, 0.02, "Mismatch in Daily Liquid Rate");
                Assert.AreEqual(5.8324, actualDefaultResult_US.SensitivityPlots.MaximumGasVolume, 0.02, "Mismatch in Maximum Gas Volume");
                Assert.AreEqual(191.89, actualDefaultResult_US.SensitivityPlots.MaximumPressure, 0.02, "Mismatch in Maximum Pressure");
                Assert.AreEqual(85.83, actualDefaultResult_US.SensitivityPlots.MaximumSlugHeight, 0.02, "Mismatch in Maximum Slug Height");
                Assert.AreEqual(0.5, actualDefaultResult_US.SensitivityPlots.MaximumSlugVolume, 0.02, "Mismatch in Maximum Slug Volume");

                Assert.AreEqual(72.86, actualDefaultResult_US.SensitivityPlots.MinimumCycleTime, 0.02, "Mismatch in Maximum Cycle Time");
                Assert.AreEqual(20, actualDefaultResult_US.SensitivityPlots.MinimumCyclesPerDay, 0.02, "Mismatch in Maximum Cycle Per Day");
                Assert.AreEqual(116.65, actualDefaultResult_US.SensitivityPlots.MinimumDailyGasRate, 0.02, "Mismatch in Maximum Daily Gas Rate");
                Assert.AreEqual(9.9, actualDefaultResult_US.SensitivityPlots.MinimumDailyLiquidRate, 0.02, "Mismatch in Daily Liquid Rate");
                Assert.AreEqual(5.8324, actualDefaultResult_US.SensitivityPlots.MinimumGasVolume, 0.02, "Mismatch in Maximum Gas Volume");
                Assert.AreEqual(149.29, actualDefaultResult_US.SensitivityPlots.MinimumPressure, 0.02, "Mismatch in Maximum Pressure");
                Assert.AreEqual(85.83, actualDefaultResult_US.SensitivityPlots.MinimumSlugHeight, 0.02, "Mismatch in Maximum Slug Height");
                Assert.AreEqual(0.5, actualDefaultResult_US.SensitivityPlots.MinimumSlugVolume, 0.02, "Mismatch in Maximum Slug Volume");

                Trace.WriteLine("Verification completed for Sensitivity Plot");
                #endregion Perform Default Plunger Design

                #region PGL Design - With Sensitivity
                //Getting default sensitivity data
                PlungerLiftDesignSensitivityArrayAndUnitsDTO getDefaultSensitivityData_US = WellTestDataService.GetPlungerLiftDesignSensitivityAndUnits(PGLWell.Id.ToString());

                //Adding Sensitivity
                PlungerLiftDesignSensitivityDTO addSensitivityDataValueRecord_1 = new PlungerLiftDesignSensitivityDTO()
                {
                    CaseNumber = 1,
                    WellId = PGLWell.Id,
                    DifferentialPressure = 300,
                    FlowingTubingHeadPressure = 350,
                    BuildUpTime = 400,
                    OperatingAfterflowTime = 450,
                };

                PlungerLiftDesignSensitivityDTO addSensitivityDataValueRecord_2 = new PlungerLiftDesignSensitivityDTO()
                {
                    CaseNumber = 2,
                    WellId = PGLWell.Id,
                    DifferentialPressure = 350,
                    FlowingTubingHeadPressure = 400,
                    BuildUpTime = 450,
                    OperatingAfterflowTime = 500,
                };

                PlungerLiftDesignSensitivityDTO[] arraySensitivity = new PlungerLiftDesignSensitivityDTO[] { addSensitivityDataValueRecord_1, addSensitivityDataValueRecord_2 };

                //Creating Design DTO for adding Sensitivity record
                PlungerLiftDesignSensitivityArrayAndUnitsDTO createSensitivityDTO = new PlungerLiftDesignSensitivityArrayAndUnitsDTO();
                createSensitivityDTO.Units = getDefaultSensitivityData_US.Units;
                createSensitivityDTO.Values = arraySensitivity;

                //Saving Sensitivity 
                WellTestDataService.SavePlungerLiftDesignSensitivityAndUnits(createSensitivityDTO, PGLWell.Id.ToString());

                //Getting Added Sensitivity Data
                PlungerLiftDesignSensitivityArrayAndUnitsDTO getAddedSensitivityData_US = WellTestDataService.GetPlungerLiftDesignSensitivityAndUnits(PGLWell.Id.ToString());
                Assert.IsNotNull(getAddedSensitivityData_US.Units);
                Assert.IsNotNull(getAddedSensitivityData_US.Values);

                Assert.AreEqual(1, getAddedSensitivityData_US.Values[0].CaseNumber, "Mismatch in Case Number");
                Assert.AreEqual(300, getAddedSensitivityData_US.Values[0].DifferentialPressure, "Mismatch in Differential Pressure");
                Assert.AreEqual(350, getAddedSensitivityData_US.Values[0].FlowingTubingHeadPressure, "Mismatch in Tubing Head Pressure");
                Assert.AreEqual(400, getAddedSensitivityData_US.Values[0].BuildUpTime, "Mismatch in Buildup Time");
                Assert.AreEqual(450, getAddedSensitivityData_US.Values[0].OperatingAfterflowTime, "Mismatch in After Flow Time");

                Assert.AreEqual(2, getAddedSensitivityData_US.Values[1].CaseNumber, "Mismatch in Case Number");
                Assert.AreEqual(350, getAddedSensitivityData_US.Values[1].DifferentialPressure, "Mismatch in Differential Pressure");
                Assert.AreEqual(400, getAddedSensitivityData_US.Values[1].FlowingTubingHeadPressure, "Mismatch in Tubing Head Pressure");
                Assert.AreEqual(450, getAddedSensitivityData_US.Values[1].BuildUpTime, "Mismatch in Buildup Time");
                Assert.AreEqual(500, getAddedSensitivityData_US.Values[1].OperatingAfterflowTime, "Mismatch in After Flow Time");
                #endregion PGL Design - With Sensitivity

                #region Perform Plunger Design for Sensitivity
                getPGLDesignInputDataDefault_US.UseSensitivity = true;
                PlungerLiftDesignResultsAndUnitsDTO actualSensitivityResult_US = WellTestDataService.PerformPlungerLiftDesign(getPGLDesignInputDataDefault_US);
                Assert.IsNotNull(actualSensitivityResult_US);

                Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                FileName = "PGLSensitivityDesign_US.json";

                PlungerLiftDesignResultsAndUnitsDTO expectedSensitivityResult_US = JsonConvert.DeserializeObject<PlungerLiftDesignResultsAndUnitsDTO>(GetJsonString(Path + FileName));
                Assert.IsNotNull(expectedSensitivityResult_US);

                //-----Veryfying Base Type Graph
                CompareObjectsUsingReflection(expectedSensitivityResult_US.BaseTypeGraph.SurfaceTypeGraph.Units, actualSensitivityResult_US.BaseTypeGraph.SurfaceTypeGraph.Units, "Mismatch in Base Type Graph Units");
                for (int i = 0; i < actualSensitivityResult_US.BaseTypeGraph.SurfaceTypeGraph.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedSensitivityResult_US.BaseTypeGraph.SurfaceTypeGraph.Values[i], actualSensitivityResult_US.BaseTypeGraph.SurfaceTypeGraph.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Trace.WriteLine("Verification completed for Base Type Graph");

                //-----Veryfying Base Plunger Cycle
                CompareObjectsUsingReflection(expectedSensitivityResult_US.PlungerCycles.Units, actualSensitivityResult_US.PlungerCycles.Units, "Mismatch in Plunger Cycle Units");
                for (int i = 0; i < actualDefaultResult_US.PlungerCycles.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedSensitivityResult_US.PlungerCycles.Values[i], actualSensitivityResult_US.PlungerCycles.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Trace.WriteLine("Verification completed for Plunger Cycle");

                //-----Veryfying Sensitivity Plots
                CompareObjectsUsingReflection(expectedSensitivityResult_US.SensitivityPlots.SensitivityPlots.Units, actualSensitivityResult_US.SensitivityPlots.SensitivityPlots.Units, "Mismatch in Sensitivity Plots Units");
                for (int i = 0; i < actualDefaultResult_US.SensitivityPlots.SensitivityPlots.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedSensitivityResult_US.SensitivityPlots.SensitivityPlots.Values[i], actualSensitivityResult_US.SensitivityPlots.SensitivityPlots.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Trace.WriteLine("Verification completed for Sensitivity Plot");
                #endregion Perform Plunger Design for Sensitivity

                #endregion US Conversion

                #region Metric Conversion
                ChangeUnitSystem("Metric");
                ChangeUnitSystemUserSetting("Metric");

                double fct_Pressure = 6.894757;
                double fct_GasRate = 28.3168466;
                double fct_LiquidRate = 0.1589873;
                double fct_GasVolume = 28.3168466;
                double fct_SlugVolume = 0.1589873;
                double fct_SlugHight = 0.3048;
                double tol = 0.2;

                #region Default PGL Design - without Sensitivity - Metric
                PlungerLiftDesignInputAndUnitsDTO getPGLDesignInputDataDefault_Metric = WellTestDataService.GetPlungerLiftDesignInputDataAndUnits(PGLWell.Id.ToString());
                Assert.IsNotNull(getPGLDesignInputDataDefault_Metric);
                Assert.AreEqual((double)11, getPGLDesignInputDataDefault_Metric.DesignParameters.Value.BuildUpTime, tol, "Mismatch In BuildUp Time");
                Assert.AreEqual(0, getPGLDesignInputDataDefault_Metric.DesignParameters.Value.OperatingAfterflowTime, tol, "Mismatch In After Flow Time");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(50 * fct_Pressure), 2), getPGLDesignInputDataDefault_Metric.DesignParameters.Value.DifferentialPressure, tol, "Mismatch In Differntial Pressure");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(50 * fct_Pressure), 2), getPGLDesignInputDataDefault_Metric.DesignParameters.Value.FlowingTubingHeadPressure, tol, "Mismatch In Tubing Head Pressure");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(35 * fct_GasRate), 2), getPGLDesignInputDataDefault_Metric.DesignParameters.Value.GasProductionRate, tol, "Mismatch In Produced Gas Rate");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(3.5 * fct_LiquidRate), 2), getPGLDesignInputDataDefault_Metric.DesignParameters.Value.LiquidProductionRate, tol, "Mismatch In Liquid Rate");
                Assert.AreEqual("Generic", getPGLDesignInputDataDefault_Metric.DesignParameters.Value.PlungerType, "Mismatch In Plunger Type");
                #endregion Default PGL Design - without Sensitivity - Metric

                #region Perform Default Plunger Design - Metric
                PlungerLiftDesignResultsAndUnitsDTO actualDefaultResult_Metric = WellTestDataService.PerformPlungerLiftDesign(getPGLDesignInputDataDefault_Metric);
                Assert.IsNotNull(actualDefaultResult_Metric);

                Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                FileName = "PGLDefaultDesign_Metric.json";
                PlungerLiftDesignResultsAndUnitsDTO expectedDefaultResult_Metric = JsonConvert.DeserializeObject<PlungerLiftDesignResultsAndUnitsDTO>(GetJsonString(Path + FileName));
                Assert.IsNotNull(expectedDefaultResult_Metric);

                //-----Veryfying Base Type Graph
                CompareObjectsUsingReflection(expectedDefaultResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Units, actualDefaultResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Units, "Mismatch in Base Type Graph Units");
                for (int i = 0; i < actualDefaultResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedDefaultResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Values[i], actualDefaultResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(600 * fct_Pressure), 2), actualDefaultResult_Metric.BaseTypeGraph.MaximumPressure, tol, "Mismatch in Maximum Pressure");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(1319.85 * fct_GasRate), 2), actualDefaultResult_Metric.BaseTypeGraph.MaximumRate, tol, "Mismatch in Maximum Rate");
                //Assert.AreEqual(70.8, actualDefaultResult_US.BaseTypeGraph.MaximumVelocity, 0.02, "Mismatch in Maximum Velocity");

                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(14.65 * fct_Pressure), 2), actualDefaultResult_Metric.BaseTypeGraph.MinimumPressure, tol, "Mismatch in Minimum Pressure");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(28.15 * fct_GasRate), 2), actualDefaultResult_Metric.BaseTypeGraph.MinimumRate, tol, "Mismatch in Minimum Rate");
                //Assert.AreEqual(10.31, actualDefaultResult_US.BaseTypeGraph.MinimumVelocity, 0.02, "Mismatch in Minimum Velocity");

                Trace.WriteLine("Verification completed for Base Type Graph");

                //-----Veryfying Base Plunger Cycle
                CompareObjectsUsingReflection(expectedDefaultResult_Metric.PlungerCycles.Units, actualDefaultResult_Metric.PlungerCycles.Units, "Mismatch in Plunger Cycle Units");
                for (int i = 0; i < actualDefaultResult_Metric.PlungerCycles.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedDefaultResult_Metric.PlungerCycles.Values[i], actualDefaultResult_Metric.PlungerCycles.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Trace.WriteLine("Verification completed for Plunger Cycle");

                //-----Veryfying Sensitivity Plots
                CompareObjectsUsingReflection(expectedDefaultResult_Metric.SensitivityPlots.SensitivityPlots.Units, actualDefaultResult_Metric.SensitivityPlots.SensitivityPlots.Units, "Mismatch in Sensitivity Plots Units");
                for (int i = 0; i < actualDefaultResult_Metric.SensitivityPlots.SensitivityPlots.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedDefaultResult_Metric.SensitivityPlots.SensitivityPlots.Values[i], actualDefaultResult_Metric.SensitivityPlots.SensitivityPlots.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Assert.AreEqual(72.86, actualDefaultResult_Metric.SensitivityPlots.MaximumCycleTime, tol, "Mismatch in Maximum Cycle Time");
                Assert.AreEqual(20, actualDefaultResult_Metric.SensitivityPlots.MaximumCyclesPerDay, tol, "Mismatch in Maximum Cycle Per Day");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(116.65 * fct_GasRate), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumDailyGasRate, tol, "Mismatch in Maximum Daily Gas Rate");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(9.9 * fct_LiquidRate), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumDailyLiquidRate, tol, "Mismatch in Maximum Daily Liquid Rate");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(5.8324 * fct_GasVolume), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumGasVolume, tol, "Mismatch in Maximum Gas Volume");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(191.89 * fct_Pressure), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumPressure, tol, "Mismatch in Maximum Pressure");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(85.83 * fct_SlugHight), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumSlugHeight, tol, "Mismatch in Maximum Slug Height");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(0.5 * fct_SlugVolume), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumSlugVolume, tol, "Mismatch in Maximum Slug Volume");

                Assert.AreEqual(72.86, actualDefaultResult_Metric.SensitivityPlots.MinimumCycleTime, tol, "Mismatch in Minimum Cycle Time");
                Assert.AreEqual(20, actualDefaultResult_Metric.SensitivityPlots.MinimumCyclesPerDay, tol, "Mismatch in Minimum Cycle Per Day");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(116.65 * fct_GasRate), 2), actualDefaultResult_Metric.SensitivityPlots.MinimumDailyGasRate, tol, "Mismatch in Minimum Daily Gas Rate");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(9.9 * fct_LiquidRate), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumDailyLiquidRate, tol, "Mismatch in Minimum Daily Liquid Rate");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(5.8324 * fct_GasVolume), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumGasVolume, tol, "Mismatch in Minimum Gas Volume");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(149.29 * fct_Pressure), 2), actualDefaultResult_Metric.SensitivityPlots.MinimumPressure, tol, "Mismatch in Minimum Pressure");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(85.83 * fct_SlugHight), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumSlugHeight, tol, "Mismatch in Minimum Slug Height");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(0.5 * fct_SlugVolume), 2), actualDefaultResult_Metric.SensitivityPlots.MaximumSlugVolume, tol, "Mismatch in Minimum Slug Volume");

                Trace.WriteLine("Verification completed for Sensitivity Plot");
                #endregion Perform Default Plunger Design - Metric

                #region PGL Design - With Sensitivity - Metric
                //Getting Added Sensitivity Data
                PlungerLiftDesignSensitivityArrayAndUnitsDTO getAddedSensitivityData_Metric = WellTestDataService.GetPlungerLiftDesignSensitivityAndUnits(PGLWell.Id.ToString());
                Assert.IsNotNull(getAddedSensitivityData_Metric.Units);
                Assert.IsNotNull(getAddedSensitivityData_Metric.Values);

                Assert.AreEqual(1, getAddedSensitivityData_Metric.Values[0].CaseNumber, "Mismatch in Case Number");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(300 * fct_Pressure), 2), getAddedSensitivityData_Metric.Values[0].DifferentialPressure, tol, "Mismatch in Differential Pressure");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(350 * fct_Pressure), 2), getAddedSensitivityData_Metric.Values[0].FlowingTubingHeadPressure, tol, "Mismatch in Tubing Head Pressure");
                Assert.AreEqual(400, getAddedSensitivityData_Metric.Values[0].BuildUpTime, "Mismatch in Buildup Time");
                Assert.AreEqual(450, getAddedSensitivityData_Metric.Values[0].OperatingAfterflowTime, "Mismatch in After Flow Time");

                Assert.AreEqual(2, getAddedSensitivityData_Metric.Values[1].CaseNumber, "Mismatch in Case Number");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(350 * fct_Pressure), 2), getAddedSensitivityData_Metric.Values[1].DifferentialPressure, tol, "Mismatch in Differential Pressure");
                Assert.AreEqual(surtest.GetTruncatedValueforDouble((double)(400 * fct_Pressure), 2), getAddedSensitivityData_Metric.Values[1].FlowingTubingHeadPressure, tol, "Mismatch in Tubing Head Pressure");
                Assert.AreEqual(450, getAddedSensitivityData_Metric.Values[1].BuildUpTime, "Mismatch in Buildup Time");
                Assert.AreEqual(500, getAddedSensitivityData_Metric.Values[1].OperatingAfterflowTime, "Mismatch in After Flow Time");
                #endregion PGL Design - With Sensitivity - Metric

                #region Perform Plunger Design for Sensitivity
                getPGLDesignInputDataDefault_Metric.UseSensitivity = true;
                PlungerLiftDesignResultsAndUnitsDTO actualSensitivityResult_Metric = WellTestDataService.PerformPlungerLiftDesign(getPGLDesignInputDataDefault_Metric);
                Assert.IsNotNull(actualSensitivityResult_Metric);

                Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";
                FileName = "PGLSensitivityDesign_Metric.json";

                PlungerLiftDesignResultsAndUnitsDTO expectedSensitivityResult_Metric = JsonConvert.DeserializeObject<PlungerLiftDesignResultsAndUnitsDTO>(GetJsonString(Path + FileName));
                Assert.IsNotNull(expectedSensitivityResult_Metric);

                //-----Veryfying Base Type Graph
                CompareObjectsUsingReflection(expectedSensitivityResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Units, actualSensitivityResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Units, "Mismatch in Base Type Graph Units");
                for (int i = 0; i < actualSensitivityResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedSensitivityResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Values[i], actualSensitivityResult_Metric.BaseTypeGraph.SurfaceTypeGraph.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Trace.WriteLine("Verification completed for Base Type Graph");

                //-----Veryfying Base Plunger Cycle
                CompareObjectsUsingReflection(expectedSensitivityResult_Metric.PlungerCycles.Units, actualSensitivityResult_Metric.PlungerCycles.Units, "Mismatch in Plunger Cycle Units");
                for (int i = 0; i < actualDefaultResult_Metric.PlungerCycles.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedSensitivityResult_Metric.PlungerCycles.Values[i], actualSensitivityResult_Metric.PlungerCycles.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Trace.WriteLine("Verification completed for Plunger Cycle");

                //-----Veryfying Sensitivity Plots
                CompareObjectsUsingReflection(expectedSensitivityResult_Metric.SensitivityPlots.SensitivityPlots.Units, actualSensitivityResult_Metric.SensitivityPlots.SensitivityPlots.Units, "Mismatch in Sensitivity Plots Units");
                for (int i = 0; i < actualDefaultResult_Metric.SensitivityPlots.SensitivityPlots.Values.Count(); i++)

                {
                    CompareObjectsUsingReflection(expectedSensitivityResult_Metric.SensitivityPlots.SensitivityPlots.Values[i], actualSensitivityResult_Metric.SensitivityPlots.SensitivityPlots.Values[i], "Mismatch at element " + i, null, 0.2);
                }
                Trace.WriteLine("Verification completed for Sensitivity Plot");
                #endregion Perform Plunger Design for Sensitivity

                #endregion Metric Conversion
            }
            finally
            {
                RemoveWell(facilityID);
                ChangeUnitSystem("US");
                ChangeUnitSystemUserSetting("US");
            }
        }

        public void WellTestTrendList(string wellid, string welltestname)
        {
            //var allWells = WellService.GetAllWells().ToList();            
            //var assembly = WellboreComponentService.GetAssemblyByWellId(wellid.ToString());
            string[] trend = new string[]
            { ((int)WellTestQuantity.Invalid).ToString(),
             ((int)WellTestQuantity.TestDuration).ToString(),
             ((int)WellTestQuantity.Oil).ToString(),
             ((int)WellTestQuantity.Gas).ToString(),
             ((int)WellTestQuantity.Water).ToString(),
             ((int)WellTestQuantity.TotalFluid).ToString(),
             ((int)WellTestQuantity.WaterCut).ToString(),
             ((int)WellTestQuantity.GOR).ToString(),
             ((int)WellTestQuantity.AverageCasingPressure).ToString(),
             ((int)WellTestQuantity.AverageTubingPressure).ToString(),
             ((int)WellTestQuantity.PumpIntakePressure).ToString(),
             ((int)WellTestQuantity.AverageTubingTemperature).ToString(),
             ((int)WellTestQuantity.AverageFluidAbovePump).ToString(),
             ((int)WellTestQuantity.GasInjectionRate).ToString(),
             ((int)WellTestQuantity.TotalGasRate).ToString(),
             ((int)WellTestQuantity.PumpDischargePressure).ToString(),
             ((int)WellTestQuantity.GaugePressure).ToString(),
             ((int)WellTestQuantity.LFactor).ToString(),
             ((int)WellTestQuantity.ReservoirPressure).ToString(),
             ((int)WellTestQuantity.FlowingBottomholePressure).ToString(),
             ((int)WellTestQuantity.FlowLinePressure).ToString(),
             ((int)WellTestQuantity.ProductivityIndex).ToString(),
             ((int)WellTestQuantity.ChokeSize).ToString(),
             ((int)WellTestQuantity.Frequency).ToString(),
             ((int)WellTestQuantity.PumpSpeed).ToString(),
             ((int)WellTestQuantity.PumpTorque).ToString(),
             ((int)WellTestQuantity.PolishedRodTorque).ToString(),
             ((int)WellTestQuantity.MotorVolts).ToString(),
             ((int)WellTestQuantity.MotorCurrent).ToString(),
             ((int)WellTestQuantity.MotorTemperature).ToString(),
             ((int)WellTestQuantity.CycleTime).ToString(),
             ((int)WellTestQuantity.MinimumCasingPressure).ToString(),
             ((int)WellTestQuantity.MaximumTubingPressure).ToString(),
             ((int)WellTestQuantity.MinimumTubingPressure).ToString(),
             ((int)WellTestQuantity.CycleGasVolume).ToString(),
             ((int)WellTestQuantity.CycleOilVolume).ToString(),
             ((int)WellTestQuantity.CycleWaterVolume).ToString()

            };


            CygNetTrendDTO[] wellTestTrend = WellTestDataService.GetWellTestTrendByDateRangeNew(trend, wellid.ToString(), DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime().AddMonths(-1)), DTOExtensions.ToISO8601(DateTime.Today.ToUniversalTime()));

            for (int a = 0; a < wellTestTrend.Count(); a++)
            {
                Assert.AreEqual("Success", wellTestTrend[a].ErrorMessage.ToString(), "Exception occurred while plotting the WelltestData trend data: " + wellTestTrend[0].ErrorMessage.ToString() + "For Well" + welltestname.ToString());
            }


        }
        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void CalculatePumpWearFactor()
        {
            string Path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("WellfloESPExample1.wflx",
                                                                                WellTypeId.ESP,
                                                                                new ModelFileOptionDTO()
                                                                                {
                                                                                    CalibrationMethod = CalibrationMethodId.ReservoirPressureAndLFactor,
                                                                                    Comment = "auto test",
                                                                                    PumpPressure = PIPandPDPOption.Has_PumpDischargePressure,
                                                                                    OptionalUpdate = new long[] { ((long)OptionalUpdates.UpdateWCT_WGR),
                                                                                                                                         ((long)OptionalUpdates.UpdateGOR_CGR),
                                                                                                                                         ((long)OptionalUpdates.PumpWearFactor)},
                                                                                });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            // Add a well and test for its existence in the database.
            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = DefaultWellName + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            var allWells = WellService.GetAllWells().ToList();
            WellDTO well = allWells?.FirstOrDefault(w => w.Name.Equals(DefaultWellName + wellType.ToString()));
            Assert.IsNotNull(well);
            _wellsToRemove.Add(well);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO() { };

            options.Comment = "CASETest Upload " + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = well.Id;

            byte[] fileAsByteArray = GetByteArray(Path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File type mismatch");

            ModelFileValidationDataDTO ModelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(ModelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(well.Id.ToString());
            Assert.IsNotNull(newModelFile);

            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            // create an allocatable well test
            WellTestDTO testDataDTO = new WellTestDTO()
            {
                WellId = well.Id,
                SPTCodeDescription = "AllocatableTest",
                AverageTubingPressure = 1615,
                AverageTubingTemperature = 83,
                PumpIntakePressure = 1500,
                PumpDischargePressure = 2000,
                GaugePressure = 1648,
                ReservoirPressure = 3000,
                Oil = 1594,
                Gas = 1862,
                Water = 1832,
                ChokeSize = 76,
                FlowLinePressure = 50,
                SeparatorPressure = 54,
                Frequency = 73,
                MotorVolts = 250,
                MotorCurrent = 48,
            };

            testDataDTO.SampleDate = (DateTime.Today.ToUniversalTime());

            // save well test
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(well.Id.ToString()).Units;

            // We do NOT want to bypass surface parameter validation
            SystemSettingDTO systemSetting = SettingService.GetSystemSettingByName(SettingServiceStringConstants.BYPASS_SURFACE_PARAMETER_VALIDATION);
            SettingService.SaveSystemSetting(new SystemSettingDTO
            {
                SettingId = systemSetting.Id,
                Setting = systemSetting.Setting,
                NumericValue = 1,
            });

            // ------------ Create well settings that ensure that well test validation will succeed. ------------

            SettingDTO setting = SettingService.GetSettingByName(SettingServiceStringConstants.LFACTOR_MIN_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 0.1,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.LFACTOR_MAX_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 2,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.RESERVOIR_PRESSURE_MIN_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 14.7,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.RESERVOIR_PRESSURE_MAX_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 25000,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.PUMPWEARFACTOR_MIN_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 0.1,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.PUMPWEARFACTOR_MAX_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 2.0,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.GOR_MIN_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 0,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.GOR_MAX_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 6000,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.WATERCUT_MIN_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 0,
                WellId = well.Id
            });

            setting = SettingService.GetSettingByName(SettingServiceStringConstants.WATERCUT_MAX_AL);
            SettingService.SaveWellSetting(new WellSettingDTO
            {
                SettingId = setting.Id,
                NumericValue = 0.1,
                WellId = well.Id
            });

            // --------------------------------------------------------------------------------------------

            //int result = WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));
            //Assert.AreEqual(1, result, "Failed to save pump wear factor well test.");
            WellTestDataService.SaveWellTest(new WellTestAndUnitsDTO(units, testDataDTO));

            // The pump wear factor has already been calculated and saved with the well test. All we need to do it retrieve the test.
            WellTestAndUnitsDTO latestValidTest = WellTestDataService.GetLatestValidWellTestByWellId(well.Id.ToString());
            Assert.IsNotNull(latestValidTest, "Could not retrieve latest well test containing the pump wear factor.");

            WellTestDTO latestValidTestDto = latestValidTest.Value;

            WellTestDTO ESPPumpWearFactor = WellTestDataService.CalculateESPPumpWearFactor(latestValidTestDto);
            Assert.IsNotNull(ESPPumpWearFactor);

            // Based on the well model and the well test used in this test, WellFlo calculates the pump wear factor to be 0.1709.
            // Compare the WellFlo result with the WAMI result to verify the pump wear factor.
            //Assert.AreEqual(0.1709, (double)latestValidTestDto.PumpWearFactor, 0.0005, "Pump wear factor misaatch: Expected: {0} Actual: {1}", 0.1709, latestValidTestDto.PumpWearFactor);
            Assert.AreEqual(0.153572, (double)latestValidTestDto.PumpWearFactor, 0.0005, "Pump wear factor misaatch: Expected: {0} Actual: {1}", 0.153572, latestValidTestDto.PumpWearFactor);
        }

        [TestCategory(TestCategories.WellTestServiceTests), TestMethod]
        public void ESPWellAndPumpPerformanceCurveTestsWithSensitivity()
        {
            // This is the path to the  ESP example well model in the codebase.
            const string path = "Weatherford.POP.Server.IntegrationTests.TestDocuments.";

            Tuple<string, WellTypeId, ModelFileOptionDTO> model = Tuple.Create("WellfloESPExample1.wflx", WellTypeId.ESP,
                new ModelFileOptionDTO
                {
                    CalibrationMethod = CalibrationMethodId.LFactor,
                    OptionalUpdate = new long[]
                    {
                        (long) OptionalUpdates.UpdateGOR_CGR,
                        (long) OptionalUpdates.UpdateWCT_WGR,
                        (long) OptionalUpdates.CalculateChokeD_Factor
                    }
                });

            string modelFileName = model.Item1;
            WellTypeId wellType = model.Item2;
            ModelFileOptionDTO options = model.Item3;

            Trace.WriteLine("Testing model: " + modelFileName);

            WellConfigurationService.AddWellConfig(new WellConfigDTO() { Well = SetDefaultFluidType(new WellDTO() { Name = "ESPTestWell3" + wellType.ToString(), CommissionDate = (DateTime.Today - TimeSpan.FromDays(100)), WellType = wellType }) });
            WellDTO newWell = WellService.GetWellByName("ESPTestWell3" + wellType.ToString());
            Assert.IsNotNull(newWell);
            _wellsToRemove.Add(newWell);

            ModelFileBase64DTO modelFile = new ModelFileBase64DTO();

            options.Comment = "Testing 1 - 2 - 3 ..." + model.Item1;
            modelFile.Options = options;
            modelFile.ApplicableDate = DateTime.Today.ToUniversalTime() - TimeSpan.FromDays(1);
            modelFile.WellId = newWell.Id;

            byte[] fileAsByteArray = GetByteArray(path, model.Item1);
            Assert.IsNotNull(fileAsByteArray);
            modelFile.Base64Contents = Convert.ToBase64String(fileAsByteArray);
            Assert.AreEqual(wellType, ModelFileService.GetWellModelType(modelFile), "Model File is not an ESP model file.");
            ModelFileValidationDataDTO modelFileValidationData = ModelFileService.GetModelFileValidation(modelFile);
            Assert.IsNotNull(modelFileValidationData);
            ModelFileService.AddWellModelFile(modelFile);
            ModelFileDTO newModelFile = ModelFileService.GetCurrentModelFile(newWell.Id.ToString());
            Assert.IsNotNull(newModelFile);
            _modelFilesToRemove.Add(newModelFile.Id.ToString());

            /// Add VSD frequenices to ESP Well
            /// 
            SettingDTO setting = SettingService.GetSettingByName(SettingServiceStringConstants.WELL_FREQUENCY);


            WellSettingDTO wellsettingdto = new WellSettingDTO
            {
                SettingId = setting.Id,
                WellId = newWell.Id,
                Setting = new SettingDTO { SettingCategory = SettingCategory.PerformanceCurve, SettingType = SettingType.Well, Key = "Well Frequencies", Name = "Well Frequencies", Description = "Well Frequencies", SettingValueType = SettingValueType.DecimalNumberArray },
                NumericArrayValue = new double[] { 50.0, 55.0, 60.0, 65.0 }
            };
            SettingService.SaveWellSetting(wellsettingdto);

            // NOTE: If you change anything in the following well test, it is very likely that this integration test will fail
            //       because the comparisons we do after the analysis assume that this well test was used for the analysis.
            WellTestDTO testDTO = new WellTestDTO
            {
                WellId = newWell.Id,
                SPTCodeDescription = "RepresentativeTest",
                AverageTubingPressure = 100,
                AverageTubingTemperature = 101,
                AverageCasingPressure = 0,
                GaugePressure = 104,
                Oil = 108,
                Gas = 109,
                Water = 110,
                ChokeSize = 107,
                FlowLinePressure = 105,
                SeparatorPressure = 106,
                Frequency = 60,
                MotorVolts = 450,
                MotorCurrent = 55,
                SampleDate = DateTime.Today.ToUniversalTime()
            };

            // Add the well test record to the database.
            WellTestUnitsDTO units = WellTestDataService.GetWellTestDefaults(newWell.Id.ToString()).Units;
            WellTestDataService.AddWellTestData(new WellTestAndUnitsDTO(units, testDTO));

            // Get it back out and use it to load the analysis inputs (?)
            WellTestAndUnitsDTO latestValidTestDataPair = WellTestDataService.GetLatestValidWellTestByWellId(newWell.Id.ToString());
            // Add Formation GOR Sensitivities to ESP Well
            WellSensitivityDTO wellSensitivitydto = new WellSensitivityDTO
            {
                WellId = newWell.Id,
                SensitivityType = SensitivityQuantity.FormationGOR,
                DoubleValue = new double[] { 7.5, 1000 }
            };
            string sensitivityGOR = WellService.AddUpdateWellSensitivityConfiguration(wellSensitivitydto);
            Assert.AreEqual("1", sensitivityGOR, "The Sensitivity Added successfully in DB.");

            var glAnalysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());


            NodalAnalysisSensitivitiesDTO analysisInputWithSensitivities = new NodalAnalysisSensitivitiesDTO();
            analysisInputWithSensitivities.analysisInputs = glAnalysisInput;
            analysisInputWithSensitivities.curveType = 2;
            analysisInputWithSensitivities.sensitivities = wellSensitivitydto;
            // NodalAnalysisInputAndUnitsDTO analysisInput = WellTestDataService.GetAnalysisInputDataAndUnits(latestValidTestDataPair.Value.Id.ToString());

            Assert.IsNotNull(analysisInputWithSensitivities, "Failed to get analysis input with the provided test data");
            Assert.IsNotNull(analysisInputWithSensitivities.analysisInputs.CalibrationData, "Calibration data is not available in the analysis input");
            Assert.IsNotNull(analysisInputWithSensitivities.analysisInputs.ModelData, "Model data is not available in the analysis input");
            Assert.IsNotNull(analysisInputWithSensitivities.analysisInputs.TestData, "Test data is not available in the analysis input");
            Assert.IsNotNull(analysisInputWithSensitivities.analysisInputs.TestData.Value.ChokeSize, "ChokeSize is not available in the analysis input");

            Assert.IsNotNull(analysisInputWithSensitivities.analysisInputs.ModelData.SolutionNode, "Solution node is not available in the model data");
            Assert.IsNotNull(analysisInputWithSensitivities.analysisInputs.ModelData.StartNode, "Start node is not available in the modal data");
            Assert.AreNotEqual(analysisInputWithSensitivities.analysisInputs.ModelData.SolutionNode.Value.Name, analysisInputWithSensitivities.analysisInputs.ModelData.StartNode.Value.Name, "Start and solution node cannot be the same");
            Assert.AreEqual(3, analysisInputWithSensitivities.analysisInputs.ModelData.SolutionNodes.Values.Count(), "Incorrect number of solution nodes are available in analysis input modal data");
            Assert.AreEqual(3, analysisInputWithSensitivities.analysisInputs.ModelData.StartNodes.Values.Count(), "Incorrect number of atart nodes are available in analysis input modal data");

            Assert.IsNotNull(analysisInputWithSensitivities.analysisInputs.CalibrationData.Value.LFactor, "LFactor is not defined in the calibration data");
            Assert.IsNotNull(analysisInputWithSensitivities.analysisInputs.CalibrationData.Value.ProductivityIndex, "Productivity index is not defined in the calibration data");
            Assert.IsNotNull(analysisInputWithSensitivities.analysisInputs.CalibrationData.Value.ReservoirPressure, "Reservoir pressure is not defined in the calibration data");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageCasingPressure ?? 0, 3), (decimal)Math.Round(analysisInputWithSensitivities.analysisInputs.TestData.Value.CasingHeadPressure, 3), "Mismatch between the provided average casing pressure value and the analysis input test value");
            Assert.AreEqual((latestValidTestDataPair.Value.GaugePressure.HasValue ? Math.Round(latestValidTestDataPair.Value.GaugePressure.Value, 3) : 0m), (decimal)Math.Round(analysisInputWithSensitivities.analysisInputs.TestData.Value.DownholeGaugePressure, 3), "Mismatch between the provided gauge pressure value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.GOR.Value, 3), analysisInputWithSensitivities.analysisInputs.TestData.Value.GasOilRatio.HasValue ? (decimal)Math.Round(analysisInputWithSensitivities.analysisInputs.TestData.Value.GasOilRatio.Value, 3) : 0m, "Mismatch between the provided GOR value and analysis input test value");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.Gas.Value, 3), (decimal)Math.Round(analysisInputWithSensitivities.analysisInputs.TestData.Value.GasRate, 3), "Mismatch between the provided gas value and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Oil, (decimal)Math.Round(analysisInputWithSensitivities.analysisInputs.TestData.Value.OilRate), "Mismatch between the provided oil and analysis input test value");
            Assert.AreEqual(latestValidTestDataPair.Value.Id, analysisInputWithSensitivities.analysisInputs.TestData.Value.Id, "Mismatch between the provided ID and analysis input test ID");

            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.WaterCut.Value), (decimal)Math.Round(analysisInputWithSensitivities.analysisInputs.TestData.Value.WaterCut), "Mismatch between the provided water cut value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingPressure.Value), (decimal)Math.Round(analysisInputWithSensitivities.analysisInputs.TestData.Value.WellHeadPressure), "Mismatch between the provided average tubing pressure value and analysis input test value");
            Assert.AreEqual(Math.Round(latestValidTestDataPair.Value.AverageTubingTemperature ?? 0.0m), (decimal)Math.Round(analysisInputWithSensitivities.analysisInputs.TestData.Value.WellHeadTemperature), "Mismatch between the provided average tubing temperature value and analysis input test value");

            //Run the analysis with Sensitivity
            ESPVSDPerformanceCurvesAndUnitsDTO[] vsdperformancedto = WellTestDataService.GenerateESPPumpPerformanceCurvesWithSensitivities(analysisInputWithSensitivities);

            Assert.IsNotNull(vsdperformancedto, "VSD PErformance Curve DTO was null");


            //*********************WELL PERFORMANCE*********************
            ////**** Verify Base Operating Range Values
            Assert.AreEqual(4077.5, vsdperformancedto[0].BaseOperatingRange.Value.BestEfficiencyInsituFlowRate, 0.5, "BestEfficiencyInsituFlowRate Mismatch");
            Assert.AreEqual(4800, vsdperformancedto[0].BaseOperatingRange.Value.MaximumInsituFlowRate, 0.5, "MaximumInsituFlowRate Mismatch");
            Assert.AreEqual(3200, vsdperformancedto[0].BaseOperatingRange.Value.MinimumInsituFlowRate, 0.5, "MaximumInsituFlowRate Mismatch");

            // //****Verify Base Operating Frequency for 60 Hz , ie For Given Well Test without Performance  Frequencies Used

            Assert.AreEqual(60, vsdperformancedto[0].BasePumpCurve.OperatingFrequency.Value, "Base Operating Frequency Mismatch");
            #region Pump Curve 
            //Verify Head for Base Frequencies
            Assert.AreEqual(3038.37, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[0].DifferentialPressure, 0.5, "Head [0] Mismatch");
            Assert.AreEqual(2844.52, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[1].DifferentialPressure, 0.5, "Head [1] Mismatch");
            Assert.AreEqual(2592.51, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[2].DifferentialPressure, 0.5, "Head [2] Mismatch");
            Assert.AreEqual(2244.56, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[3].DifferentialPressure, 0.5, "Head [3] Mismatch");
            //Verify In Situ Flow rates for Base Frequencies
            Assert.AreEqual(592.7, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[0].InsituFlowRate, 0.5, "InsituFlowRate [0] Mismatch");
            Assert.AreEqual(1623.4, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[1].InsituFlowRate, 0.5, "InsituFlowRate [1] Mismatch");
            Assert.AreEqual(2645.1, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[2].InsituFlowRate, 0.5, "InsituFlowRate [2] Mismatch");
            Assert.AreEqual(3658.5, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[3].InsituFlowRate, 0.5, "InsituFlowRate [3] Mismatch");

            //Verify Horse Power  for Base Frequencies
            Assert.AreEqual(167.26, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[0].HorsePower, 0.5, "HorsePower [0] Mismatch");
            Assert.AreEqual(185.3, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[1].HorsePower, 0.5, "HorsePower [1] Mismatch");
            Assert.AreEqual(200.36, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[2].HorsePower, 0.5, "HorsePower [2] Mismatch");
            Assert.AreEqual(209.32, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[3].HorsePower, 0.5, "HorsePower [3] Mismatch");

            //Verify Efficiency   for Base Frequencies

            Assert.AreEqual(0.1838, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[0].Efficiency, 0.5, "Efficiency [0] Mismatch");
            Assert.AreEqual(0.4254, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[1].Efficiency, 0.5, "Efficiency [1] Mismatch");
            Assert.AreEqual(0.5847, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[2].Efficiency, 0.5, "Efficiency [2] Mismatch");
            Assert.AreEqual(0.6711, vsdperformancedto[0].BasePumpCurve.PumpCurve.Values[3].Efficiency, 0.5, "Efficiency [3] Mismatch");
            #endregion


            //Verify VSD Curves for each Frequency

            #region VSDCURVES
            Assert.AreEqual(50, vsdperformancedto[0].VSDPumpCurves[0].OperatingFrequency.Value, "Frequucny [0] Mismatch");
            Assert.AreEqual(55, vsdperformancedto[0].VSDPumpCurves[1].OperatingFrequency.Value, "Frequucny [1] Mismatch");
            Assert.AreEqual(60, vsdperformancedto[0].VSDPumpCurves[2].OperatingFrequency.Value, "Frequucny [2] Mismatch");
            Assert.AreEqual(65, vsdperformancedto[0].VSDPumpCurves[3].OperatingFrequency.Value, "Frequucny [3] Mismatch");

            Dictionary<string, double[]> dicifrearray = new Dictionary<string, double[]>();
            //Veify the First and Last Values for Pump Curve for all Frequency
            // 50 Hz 
            double[] Frequency0InSituRate = new double[] { 587.8, 5224.7 };
            dicifrearray.Add("Frequency0InSituRate", Frequency0InSituRate);
            double[] Frequency0Head = new double[] { 5883.86, 196.35 };
            dicifrearray.Add("Frequency0Head", Frequency0Head);
            double[] Frequency0Efficiency = new double[] { 0.2147, 0.0662 };
            dicifrearray.Add("Frequency0Efficiency", Frequency0Efficiency);
            double[] Frequency0Power = new double[] { 98.51, 92.23 };
            dicifrearray.Add("Frequency0Power", Frequency0Power);
            double[] Frequency0Differential = new double[] { 2108.13, 68.68 };
            dicifrearray.Add("Frequency0Differential", Frequency0Differential);
            // 55 Hz 
            double[] Frequency1InSituRate = new double[] { 589.9, 5658.6 };
            double[] Frequency1Head = new double[] { 7154.77, 479.73 };
            double[] Frequency1Efficiency = new double[] { 0.1979, 0.1295 };
            double[] Frequency1Power = new double[] { 129.98, 125.06 };
            double[] Frequency1Differential = new double[] { 2554.42, 168.14 };

            dicifrearray.Add("Frequency1InSituRate", Frequency1InSituRate);
            dicifrearray.Add("Frequency1Head", Frequency1Head);
            dicifrearray.Add("Frequency1Efficiency", Frequency1Efficiency);
            dicifrearray.Add("Frequency1Power", Frequency1Power);
            dicifrearray.Add("Frequency1Differential", Frequency1Differential);
            // 60 Hz 

            double[] Frequency2InSituRate = new double[] { 592.7, 6095.3 };
            double[] Frequency2Head = new double[] { 8549.48, 789.64 };
            double[] Frequency2Efficiency = new double[] { 0.1838, 0.1748 };
            double[] Frequency2Power = new double[] { 167.26, 164.59 };
            double[] Frequency2Differential = new double[] { 3038.37, 277.37 };

            dicifrearray.Add("Frequency2InSituRate", Frequency2InSituRate);
            dicifrearray.Add("Frequency2Head", Frequency2Head);
            dicifrearray.Add("Frequency2Efficiency", Frequency2Efficiency);
            dicifrearray.Add("Frequency2Power", Frequency2Power);
            dicifrearray.Add("Frequency2Differential", Frequency2Differential);

            // 65 Hz 
            double[] Frequency3InSituRate = new double[] { 596, 6532.5 };
            double[] Frequency3Head = new double[] { 10066.78, 1122.26 };
            double[] Frequency3Efficiency = new double[] { 0.1718, 0.2079 };
            double[] Frequency3Power = new double[] { 210.69, 211.42 };
            double[] Frequency3Differential = new double[] { 3557.4, 395.13 };

            dicifrearray.Add("Frequency3InSituRate", Frequency3InSituRate);
            dicifrearray.Add("Frequency3Head", Frequency3Head);
            dicifrearray.Add("Frequency3Efficiency", Frequency3Efficiency);
            dicifrearray.Add("Frequency3Power", Frequency3Power);
            dicifrearray.Add("Frequency3Differential", Frequency3Differential);

            for (int i = 0; i < 4; i++)
            {
                string FrequencyInSituRate = "Frequency" + i + "InSituRate";
                string FrequencyHead = "Frequency" + i + "Head";
                string FrequencyEfficiency = "Frequency" + i + "Efficiency";
                string FrequencyPower = "Frequency" + i + "Power";
                string FrequencyDifferential = "Frequency" + i + "Differential";
                int lastvalue = vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values.Length - 1;
                // InSitu Rate For all Frequencies 
                Assert.AreEqual(dicifrearray[FrequencyInSituRate][0], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[0].InsituFlowRate, 0.5, "Mistmatch for first Value of  " + FrequencyInSituRate);
                Assert.AreEqual(dicifrearray[FrequencyInSituRate][1], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[lastvalue].InsituFlowRate, 0.5, "Mistmatch for last  Value of  " + FrequencyInSituRate);

                Assert.AreEqual(dicifrearray[FrequencyDifferential][0], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[0].DifferentialPressure, 0.5, "Mistmatch for first Value of  " + FrequencyDifferential);
                Assert.AreEqual(dicifrearray[FrequencyDifferential][1], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[lastvalue].DifferentialPressure, 0.5, "Mistmatch for last  Value of  " + FrequencyDifferential);

                Assert.AreEqual(dicifrearray[FrequencyHead][0], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[0].Head, 0.5, "Mistmatch for first Value of  " + FrequencyHead);
                Assert.AreEqual(dicifrearray[FrequencyHead][1], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[lastvalue].Head, 0.5, "Mistmatch for last  Value of  " + FrequencyHead);

                Assert.AreEqual(dicifrearray[FrequencyEfficiency][0], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[0].Efficiency, 0.5, "Mistmatch for first Value of  " + FrequencyEfficiency);
                Assert.AreEqual(dicifrearray[FrequencyEfficiency][1], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[lastvalue].Efficiency, 0.5, "Mistmatch for last  Value of  " + FrequencyEfficiency);

                Assert.AreEqual(dicifrearray[FrequencyPower][0], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[0].HorsePower, 0.5, "Mistmatch for first Value of  " + FrequencyPower);
                Assert.AreEqual(dicifrearray[FrequencyPower][1], vsdperformancedto[0].VSDPumpCurves[i].PumpCurve.Values[lastvalue].HorsePower, 0.5, "Mistmatch for last  Value of  " + FrequencyPower);

            }


            #endregion


            //Deleting Sensitivity
            bool IsDeleted = WellService.RemoveWellSensitivityConfiguration(newWell.Id.ToString(), Convert.ToString(((Int32)SensitivityQuantity.FormationGOR)));
            Assert.IsTrue(IsDeleted, "The ErosionCoefficient Sensitivity not deleted successfully.");

        }


    }
}
